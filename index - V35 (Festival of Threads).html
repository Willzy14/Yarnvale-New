<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Yarnvale â€“ Top-Down Prototype (Overworld + Cottage)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <!-- PWA Support -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#182c4e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Yarnvale">
  <link rel="apple-touch-icon" href="icon-192.png">
  
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      background: #050810;
      color: #f5f7ff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px 12px 40px;
    }

    .frame {
      background:#04060f;
      border-radius:16px;
      padding:10px;
      box-shadow:0 18px 40px rgba(0,0,0,0.8);
      width:min(96vw, 640px);
      position:relative;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    canvas {
      image-rendering: pixelated;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.15);
      background:#000;
      display:block;
      width:100%;
      height:auto;
      max-width:608px;
    }

    .hud {
      margin-top:8px;
      font-size:10px;
      text-align:center;
      color:rgba(255,255,255,0.6);
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    .hud .instructions {
      line-height:1.3;
    }

    .music-controls {
      margin-top:6px;
      display:flex;
      gap:8px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
    }

    .music-controls button {
      width:36px;
      height:36px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.12);
      color:rgba(255,255,255,0.7);
      cursor:pointer;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      backdrop-filter:blur(4px);
    }

    .music-controls button:focus-visible,
    .touch-controls button:focus-visible,
    #touch-inventory:focus-visible {
      outline:2px solid #7cd3ff;
      outline-offset:2px;
    }

    .music-controls button.muted::after {
      content:"âœ•";
      position:absolute;
      font-size:12px;
      color:#ffb0b0;
      transform:translate(6px,-6px);
    }

    .music-controls .volume-label {
      display:flex;
      align-items:center;
      justify-content:center;
      height:auto;
    }

    .music-controls input[type="range"] {
      width:80px;
      height:4px;
      -webkit-appearance:none;
      appearance:none;
      background:rgba(255,255,255,0.2);
      border-radius:2px;
      outline:none;
    }

    .music-controls input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance:none;
      width:14px;
      height:14px;
      border-radius:50%;
      background:rgba(255,255,255,0.7);
      border:1px solid rgba(255,255,255,0.3);
      cursor:pointer;
    }

    #touch-inventory {
      display:none;
      position:absolute;
      top:12px;
      right:12px;
      width:120px;
      padding:10px 0;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(7,11,22,0.55);
      color:#f5f7ff;
      font-size:14px;
      text-align:center;
      pointer-events:auto;
      box-shadow:0 10px 24px rgba(0,0,0,0.25);
    }

    #touch-options {
      display:none;
      position:absolute;
      top:12px;
      right:140px;
      width:60px;
      padding:10px 0;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.25);
      background:rgba(7,11,22,0.55);
      color:#f5f7ff;
      font-size:12px;
      text-align:center;
      pointer-events:auto;
      box-shadow:0 10px 24px rgba(0,0,0,0.25);
    }

    #options-overlay {
      display:none;
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:rgba(0,0,0,0.7);
      z-index:100;
      justify-content:center;
      align-items:center;
      pointer-events:auto;
    }

    #options-overlay.open {
      display:flex;
    }

    .options-menu {
      background:rgba(15,20,35,0.95);
      border:1px solid rgba(255,255,255,0.2);
      border-radius:16px;
      padding:24px;
      min-width:220px;
      box-shadow:0 20px 40px rgba(0,0,0,0.5);
      backdrop-filter:blur(8px);
    }

    .options-menu h2 {
      margin:0 0 20px 0;
      text-align:center;
      color:#f5f7ff;
      font-size:18px;
      font-weight:600;
    }

    .options-menu button {
      display:block;
      width:100%;
      padding:12px;
      margin-bottom:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.1);
      color:#f5f7ff;
      font-size:14px;
      cursor:pointer;
      transition:background 0.2s;
    }

    .options-menu button:hover, .options-menu button:active {
      background:rgba(255,255,255,0.2);
    }

    .options-volume {
      margin:16px 0;
    }

    .options-volume label {
      display:block;
      color:rgba(255,255,255,0.7);
      font-size:12px;
      margin-bottom:8px;
    }

    .options-volume input[type="range"] {
      width:100%;
      height:6px;
      -webkit-appearance:none;
      appearance:none;
      background:rgba(255,255,255,0.2);
      border-radius:3px;
      outline:none;
    }

    .options-volume input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:rgba(255,255,255,0.8);
      border:1px solid rgba(255,255,255,0.3);
      cursor:pointer;
    }

    .options-close {
      margin-top:10px;
      background:rgba(100,100,120,0.3) !important;
    }

    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }

    .touch-controls {
      margin-top:6px;
      display:none;
      gap:12px;
      justify-content:space-between;
      align-items:center;
      color:#f5f7ff;
      width:100%;
      pointer-events:auto;
    }

    .dpad {
      display:grid;
      grid-template-columns:repeat(3, 36px);
      grid-template-rows:repeat(3, 36px);
      gap:2px;
      justify-items:center;
      align-items:center;
    }

    .dpad span {
      width:36px;
      height:36px;
    }

    .touch-controls button {
      width:36px;
      height:36px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.12);
      color:rgba(255,255,255,0.7);
      font-size:14px;
      cursor:pointer;
      touch-action:none;
      pointer-events:auto;
      backdrop-filter:blur(4px);
    }

    .touch-actions {
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .touch-actions button {
      width:90px;
    }

    #touch-back {
      display:none;
    }

    #touch-back.visible {
      display:block;
    }

    #touch-gift {
      display:none;
    }

    #touch-gift.visible {
      display:block;
    }

    @media (pointer: coarse) {
      body {
        padding-top:30px;
      }

      .hud .instructions {
        display:none;
      }

      .touch-controls {
        display:flex;
        flex-wrap:wrap;
      }

      .music-controls {
        flex-direction:column;
      }

      #touch-inventory {
        display:block;
        width:120px;
      }

      #touch-options {
        display:block;
      }
    }

    @media (pointer: coarse) and (orientation: landscape) and (max-width: 1100px) {
      body {
        padding:0;
        align-items:stretch;
      }

      .frame {
        width:100vw;
        height:100vh;
        max-width:none;
        border-radius:0;
        padding:0;
        box-shadow:none;
      }

      canvas {
        width:100%;
        height:100%;
        max-width:none;
        border-radius:0;
      }

      .hud {
        position:absolute;
        top:16px;
        left:16px;
        gap:4px;
        width:auto;
        align-items:flex-start;
        background:rgba(5,8,16,0.65);
        padding:10px 14px;
        border-radius:12px;
        box-shadow:0 12px 24px rgba(0,0,0,0.4);
        font-size:11px;
      }

      .hud .instructions {
        display:none;
      }

      .touch-controls {
        position:absolute;
        left:0;
        right:0;
        bottom:0;
        top:auto;
        height: min(45vh, 280px);
        padding:0;
        display:block;
        pointer-events:auto;
        z-index:1;
      }

      .touch-controls .dpad {
        position:absolute;
        left:16px;
        bottom:16px;
        grid-template-columns:repeat(3, 44px);
        grid-template-rows:repeat(3, 44px);
        gap:3px;
      }

      .touch-controls button {
        width:44px;
        height:44px;
        border-radius:50%;
        background:rgba(255,255,255,0.15);
        border:1px solid rgba(255,255,255,0.1);
        color:rgba(255,255,255,0.6);
        font-size:16px;
        pointer-events:auto;
      }

      .touch-actions {
        position:absolute;
        right:16px;
        bottom:16px;
        display:flex;
        flex-direction:column;
        gap:8px;
      }

      .touch-actions button {
        width:60px;
        height:60px;
        padding:0;
        border-radius:50%;
        background:rgba(255,255,255,0.15);
        border:1px solid rgba(255,255,255,0.1);
        color:rgba(255,255,255,0.7);
        font-size:10px;
        align-self:flex-end;
        pointer-events:auto;
      }

      #touch-inventory {
        position:absolute;
        top:16px;
        right:16px;
        width:70px;
        padding:8px 0;
        background:rgba(255,255,255,0.15);
        border:1px solid rgba(255,255,255,0.1);
        color:rgba(255,255,255,0.8);
        font-size:11px;
        border-radius:18px;
        pointer-events:auto;
      }

      #touch-options {
        position:absolute;
        top:16px;
        right:94px;
        width:50px;
        padding:8px 0;
        background:rgba(255,255,255,0.15);
        border:1px solid rgba(255,255,255,0.1);
        color:rgba(255,255,255,0.7);
        font-size:10px;
        border-radius:18px;
      }

      .music-controls {
        display:none;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <!-- Full map size: 19 * 32 by 13 * 32 -->
    <canvas id="game" width="608" height="416" role="img" aria-label="Yarnvale game world"></canvas>
    <div class="hud">
      <div class="instructions">
        Yarnvale Â· <strong>WASD</strong> move Â· <strong>E/Space</strong> interact Â· <strong>I</strong> inventory Â· <strong>F5</strong> save Â· <strong>F9</strong> load
      </div>
    </div>
    <div class="music-controls" id="music-controls">
      <button id="music-toggle" type="button" title="Toggle music" aria-label="Toggle music">
        <span aria-hidden="true">â™ª</span>
      </button>
      <label class="volume-label" for="music-volume">
        <span class="sr-only">Music volume</span>
        <input id="music-volume" type="range" min="0" max="1" step="0.05" value="0.35">
      </label>
    </div>
    <div class="touch-controls" id="touch-controls">
      <div class="dpad">
        <span></span>
        <button type="button" data-dir="up">â–²</button>
        <span></span>
        <button type="button" data-dir="left">â—„</button>
        <span></span>
        <button type="button" data-dir="right">â–º</button>
        <span></span>
        <button type="button" data-dir="down">â–¼</button>
        <span></span>
      </div>
      <div class="touch-actions">
        <button type="button" id="touch-action">Interact</button>
        <button type="button" id="touch-gift">Gift</button>
        <button type="button" id="touch-back">Back</button>
      </div>
    </div>
    <button type="button" id="touch-inventory" class="touch-floating">Inventory</button>
    <button type="button" id="touch-options" class="touch-floating">âš™</button>
    <div id="options-overlay">
      <div class="options-menu">
        <h2 id="options-title">Options</h2>
        <button type="button" id="options-save">ðŸ’¾ Save Game</button>
        <button type="button" id="options-load">ðŸ“‚ Load Game</button>
        <div class="options-volume">
          <label>ðŸ”Š Volume</label>
          <input type="range" id="options-volume" min="0" max="1" step="0.05" value="0.35">
        </div>
        <button type="button" id="options-mute">ðŸ”‡ Mute Sound</button>
        <button type="button" id="options-debug" style="display:none;">ðŸ”“ Debug Mode</button>
        <button type="button" id="options-close" class="options-close">Close</button>
      </div>
    </div>
  </div>

  <script>
    
 // =========================
// CONFIG
// =========================
// #region CONFIG

const ASSET_BASE = 'Yarnvale Assets/Audio/';
const DEFAULT_MASTER_VOLUME = 0.35;

// =========================
// ZONE DISPLAY NAMES
// =========================
const ZONE_DISPLAY_NAMES = {
  overworld: "Yarnya's Farm",
  cottage: "Cottage",
  village: "The Village",
  forest: "Whispering Woods",
  beach: "Sandy Shore",
  mountain: "Frostpeak Mountain",
  cave: "Crystal Cave",
  wetlands: "Misty Marshes"
};

function getZoneDisplayName(mapName) {
  return ZONE_DISPLAY_NAMES[mapName] || mapName;
}
const SHEAR_VOLUME_MULTIPLIER = 0.8;
const FIRE_VOLUME_MULTIPLIER = 0.55;
const MUSIC_INTERIOR_SCALE = 0.55;
const HELPER_LABEL_DURATION = 3500;
let masterVolume = DEFAULT_MASTER_VOLUME;
let audioMuted = false;
const helperLabelState = {};
let currentInteractables = [];
let showOverlayMode = false;
const isFileProtocol = window.location.protocol === 'file:';

const debugState = {
  grid: false,
  collisions: false,
  info: false,
  statusMessage: '',
  statusUntil: 0
};

const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
let GRASS_ZOOM = isCoarsePointer ? 0.45 : 0.30; // ~5% tighter on desktop

const SPRITE_CONFIG = {
  tileSize: 32,
  tileColumns: 8,
  mirrorRightFromLeft: true,
  player: {
    frameWidth: 64,
    frameHeight: 64,
    columns: 4,
    animations: {
      down: [0],
      left: [0],
      right: [0],
      up: [0]
    },
    idleFrameIndex: 0,
    speedTicks: 8
  }
};

function createImageAsset(path, options = {}) {
  const asset = {
    image: new Image(),
    loaded: false,
    error: false,
    path,
    frameWidth: options.frameWidth ?? null,
    frameHeight: options.frameHeight ?? null,
    columns: options.columns ?? null
  };

  asset.image.onload = () => {
    asset.loaded = true;
    if (!asset.columns) {
      const divisor = options.frameWidth ?? SPRITE_CONFIG.tileSize;
      asset.columns = Math.max(1, Math.floor(asset.image.width / divisor));
    }
    if (!asset.frameWidth) {
      if (asset.columns) {
        asset.frameWidth = asset.image.width / asset.columns;
      } else {
        asset.frameWidth = SPRITE_CONFIG.tileSize;
      }
    }
    if (!asset.frameHeight) {
      asset.frameHeight = options.frameHeight ?? asset.image.height ?? SPRITE_CONFIG.tileSize;
    }
  };

  asset.image.onerror = () => {
    asset.error = true;
    console.warn(`Missing art asset: ${path}`);
  };

  asset.image.src = path;
  return asset;
}

const artAssets = {
  terrain: createImageAsset('Yarnvale Assets/Art/Tile Set Grass and Water.png', {
    frameWidth: 256,
    frameHeight: 256
  }),
  foliage: createImageAsset('Yarnvale Assets/Art/Tile Set Trees and Plants.png', {
    frameWidth: 256,
    frameHeight: 256
  }),
  grass1: createImageAsset('Yarnvale Assets/Art/Grass/Grass 1 64.png', {
    frameWidth: 64,
    frameHeight: 64,
    columns: 1
  }),
  grass2: createImageAsset('Yarnvale Assets/Art/Grass/Grass 2 64.png', {
    frameWidth: 64,
    frameHeight: 64,
    columns: 1
  }),
  grass3: createImageAsset('Yarnvale Assets/Art/Grass/Grass 3 64.png', {
    frameWidth: 64,
    frameHeight: 64,
    columns: 1
  }),
  player: createImageAsset('Yarnvale Assets/Art/Sprite/Yarnya Front 64.png', {
    frameWidth: 64,
    frameHeight: 64,
    columns: 1
  }),
  playerDirections: {
    down: createImageAsset('Yarnvale Assets/Art/Sprite/Yarnya Front 64.png', {
      frameWidth: 64,
      frameHeight: 64,
      columns: 1
    }),
    up: createImageAsset('Yarnvale Assets/Art/Sprite/Yarnya Back 64.png', {
      frameWidth: 64,
      frameHeight: 64,
      columns: 1
    }),
    left: createImageAsset('Yarnvale Assets/Art/Sprite/Yarnya Left 64.png', {
      frameWidth: 64,
      frameHeight: 64,
      columns: 1
    }),
    right: createImageAsset('Yarnvale Assets/Art/Sprite/Yarnya Right 64.png', {
      frameWidth: 64,
      frameHeight: 64,
      columns: 1
    })
  },
  goat: createImageAsset('Yarnvale Assets/Art/Animals/Goat.png', {
    columns: 3,
    frameHeight: 332
  })
};

const AudioContextClass = window.AudioContext || window.webkitAudioContext;
let audioContext = null;
let musicGainNode = null;
const musicSources = new Map();
const playerFrameCache = new Map();

function ensureAudioContext() {
  if (audioContext || !AudioContextClass) return;
  try {
    audioContext = new AudioContextClass();
    musicGainNode = audioContext.createGain();
    musicGainNode.gain.value = masterVolume;
    musicGainNode.connect(audioContext.destination);
  } catch (error) {
    console.warn('AudioContext unavailable', error);
    audioContext = null;
    musicGainNode = null;
  }
}

ensureAudioContext();

function connectTrackToGain(audio) {
  ensureAudioContext();
  if (!audioContext || !musicGainNode || musicSources.has(audio)) return;
  try {
    const source = audioContext.createMediaElementSource(audio);
    source.connect(musicGainNode);
    musicSources.set(audio, source);
  } catch (error) {
    console.warn('Unable to route music track through AudioContext', error);
  }
}

function resumeAudioContextIfNeeded() {
  ensureAudioContext();
  if (audioContext && audioContext.state === 'suspended') {
    audioContext.resume().catch(() => {});
  }
}

// #endregion CONFIG

// =========================
// AUDIO
// =========================
// #region AUDIO

const sounds = {};
const footstepVoices = [];
let nextFootstepVoice = 0;

// Load multiple sheep sounds into an array
const sheepSoundFiles = ['Sheep 1.wav', 'Sheep 2.wav', 'Sheep 3.wav'];
const sheepSounds = sheepSoundFiles.map((filename) => {
  const audio = new Audio(ASSET_BASE + filename);
  audio.addEventListener('error', () => {
    console.warn(`Failed to load sheep sound: ${filename}`);
  });
  applySfxVolume(audio, 'sheep');
  return audio;
});

function getInteractablesForMap(mapName) {
  const nodes = interactableLocations
    .filter((item) => item.map === mapName)
    .map((item) => ({ ...item }));

  const doorTiles = doorTilesByMap[mapName] || [];
  doorTiles.forEach(({ x, y }) => {
    // Determine label based on map
    let doorLabel = 'Enter';
    if (mapName === 'overworld') doorLabel = 'Enter Cottage';
    else if (mapName === 'cottage') doorLabel = 'Exit Cottage';
    else if (mapName === 'cave') doorLabel = 'Exit Cave';
    else if (mapName === 'mountain') doorLabel = 'Enter Cave';
    
    nodes.push({
      map: mapName,
      x,
      y,
      label: doorLabel,
      helperRange: 1,
      glow: mapName === 'overworld'
        ? { inner: 'rgba(148, 232, 255, 0.85)', outer: 'rgba(148, 232, 255, 0)' }
        : { inner: 'rgba(255, 228, 180, 0.9)', outer: 'rgba(255, 228, 180, 0)' }
    });
  });

  return nodes;
}

function helperKey(node) {
  return `${node.map}:${node.x},${node.y}`;
}

function drawInteractableGlows(nodes) {
  nodes.forEach((node, index) => {
    const glowColors = node.glow || { inner: 'rgba(255,255,255,0.45)', outer: 'rgba(255,255,255,0)' };
    const centerX = node.x * TILE_SIZE + TILE_SIZE / 2;
    const centerY = node.y * TILE_SIZE + TILE_SIZE / 2;
    const pulse = 0.03 + 0.03 * Math.sin((fireAnimTick + index * 7) * 0.25);
    const radius = TILE_SIZE * (0.45 + pulse);
    const gradient = ctx.createRadialGradient(centerX, centerY, 3, centerX, centerY, radius);
    gradient.addColorStop(0, glowColors.inner);
    gradient.addColorStop(1, glowColors.outer);
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function playerNearInteractable(node) {
  const range = node.helperRange ?? 0;
  const dx = Math.abs(player.x - node.x);
  const dy = Math.abs(player.y - node.y);
  return dx + dy <= range;
}

function updateHelperLabelState(nodes, forceReset = false) {
  const now = performance.now();
  const seen = new Set();

  nodes.forEach((node) => {
    const key = helperKey(node);
    seen.add(key);
    const near = playerNearInteractable(node);
    const state = helperLabelState[key] || { visibleUntil: 0, wasNear: false };

    if (forceReset) {
      state.wasNear = false;
    }

    if (near && !state.wasNear) {
      state.visibleUntil = now + HELPER_LABEL_DURATION;
    }

    state.wasNear = near;
    helperLabelState[key] = state;
  });

  Object.keys(helperLabelState).forEach((key) => {
    if (!seen.has(key)) {
      delete helperLabelState[key];
    }
  });
}

function drawInteractableLabels(nodes) {
  const now = performance.now();
  nodes.forEach((node) => {
    if (!node.label) return;
    const key = helperKey(node);
    const state = helperLabelState[key];
    if (!state || state.visibleUntil < now) return;

    const text = node.label;
    const baseX = node.x * TILE_SIZE + TILE_SIZE / 2;
    const baseY = node.y * TILE_SIZE - 8;
    ctx.font = '11px system-ui';
    const textWidth = ctx.measureText(text).width;
    const padding = 8;
    const boxW = textWidth + padding * 2;
    const boxH = 20;
    const boxX = baseX - boxW / 2;
    const boxY = baseY - boxH;

    ctx.fillStyle = 'rgba(5, 8, 16, 0.85)';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.strokeRect(boxX + 0.5, boxY + 0.5, boxW - 1, boxH - 1);

    ctx.fillStyle = '#f5f7ff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, baseX, boxY + boxH / 2);

    ctx.beginPath();
    ctx.moveTo(baseX - 4, boxY + boxH);
    ctx.lineTo(baseX + 4, boxY + boxH);
    ctx.lineTo(baseX, boxY + boxH + 6);
    ctx.closePath();
    ctx.fillStyle = 'rgba(5, 8, 16, 0.85)';
    ctx.fill();
  });

  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

function getSfxMultiplier(name) {
  return name === 'shear' ? SHEAR_VOLUME_MULTIPLIER : 1;
}

function getEffectiveMasterVolume() {
  return audioMuted ? 0 : masterVolume;
}

function applySfxVolume(audio, name) {
  const effective = getEffectiveMasterVolume();
  audio.volume = Math.min(1, Math.max(0, effective * getSfxMultiplier(name)));
}

function refreshAllSfxVolumes() {
  Object.entries(sounds).forEach(([name, audio]) => applySfxVolume(audio, name));
  sheepSounds.forEach(audio => applySfxVolume(audio, 'sheep'));
  footstepVoices.forEach(audio => applySfxVolume(audio, 'step'));
}


// Helper to load audio with error logging
function loadSound(name, filename) {
  const audio = new Audio(ASSET_BASE + filename);
  applySfxVolume(audio, name);
  audio.addEventListener('error', () => {
    console.warn(`Failed to load sound: ${filename}`);
  });
  sounds[name] = audio;
}

loadSound('step', 'step.wav');
loadSound('shear', 'shear.wav');
loadSound('knit', 'Knit.wav');
loadSound('sell', 'sell.wav');

function createFootstepVoices(count = 3) {
  footstepVoices.length = 0;
  nextFootstepVoice = 0;
  for (let i = 0; i < count; i++) {
    const audio = new Audio(ASSET_BASE + 'step.wav');
    applySfxVolume(audio, 'step');
    audio.addEventListener('error', () => {
      console.warn('Failed to load footstep voice');
    });
    footstepVoices.push(audio);
  }
}

createFootstepVoices(3);

function playFootstepSound() {
  const voice = footstepVoices[nextFootstepVoice];
  nextFootstepVoice = (nextFootstepVoice + 1) % footstepVoices.length;
  if (!voice) {
    if (sounds.step) {
      sounds.step.currentTime = 0;
      sounds.step.play().catch(() => {});
    }
    return;
  }
  voice.currentTime = 0;
  voice.play().catch(() => {});
}

// #endregion AUDIO


// =========================
// AMBIENT AUDIO
// =========================
// #region AMBIENT_AUDIO

const fireLoop = new Audio(ASSET_BASE + 'Fire.wav');
fireLoop.loop = true;
fireLoop.volume = 0;
fireLoop.addEventListener('error', () => {
  console.warn('Failed to load ambient fire loop');
});
let fireLoopActive = false;

function updateFireLoopVolume() {
  const targetVolume = fireLoopActive ? Math.min(1, Math.max(0, getEffectiveMasterVolume() * FIRE_VOLUME_MULTIPLIER)) : 0;
  fireLoop.volume = targetVolume;
  if (fireLoopActive && targetVolume > 0) {
    fireLoop.play().catch(() => {});
  } else {
    fireLoop.pause();
    fireLoop.currentTime = 0;
  }
}

function setFireLoopActive(active) {
  fireLoopActive = active;
  updateFireLoopVolume();
}

// #endregion AMBIENT_AUDIO



// =========================
// MUSIC MANAGER
// =========================
// #region MUSIC

const MUSIC_BASE = `${ASSET_BASE}Background music/`;
const MUSIC_INTERIOR_BASE = `${MUSIC_BASE}In The House/`;
const MUSIC_TRACK_FILES_OVERWORLD = [
  'Golden Fields (1).mp3',
  'Golden Fields (2).mp3',
  'Knitting by the Fire (1).mp3',
  'Knitting by the Fire 2.mp3',
  'Knitting the Threads of Life.mp3',
  'Knitting the Threads of Life (1).mp3',
  'Sunlit Fields (1).mp3',
  'Sunlit Fields 2.mp3',
  'Sunshine Fields (1).mp3',
  'Sunshine Fields 2.mp3',
  'Threads of Harmony.mp3',
  'Threads of Harmony (1).mp3',
  'Threads of the Meadow (1).mp3',
  'Threads of the Meadow 2.mp3'
];

const MUSIC_TRACK_FILES_COTTAGE = [
  'By the Hearth.mp3',
  'By the Hearth (1).mp3',
  'Warm Threads by the Hearth.mp3',
  'Warm Threads by the Hearth (1).mp3'
];

function createMusicTrack(basePath, filename) {
  const audio = new Audio(basePath + filename);
  audio.preload = 'auto';
  audio.loop = false;
  audio.volume = 0;
  audio.addEventListener('error', () => {
    console.warn(`Failed to load music track: ${filename}`);
  });
  connectTrackToGain(audio);
  return audio;
}

const musicTracksByScene = {
  overworld: MUSIC_TRACK_FILES_OVERWORLD.map((file) => createMusicTrack(MUSIC_BASE, file)),
  cottage: MUSIC_TRACK_FILES_COTTAGE.map((file) => createMusicTrack(MUSIC_INTERIOR_BASE, file))
};

// Track per-scene resume info so music continues where it left off when re-entering
const musicResumeState = {
  overworld: null,
  cottage: null
};

const musicState = {
  scene: 'overworld',
  orderByScene: { overworld: [], cottage: [] },
  orderIndexByScene: { overworld: 0, cottage: 0 },
  started: false,
  muted: false,
  volume: masterVolume,
  playing: null,
  sceneScale: 1
};

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function allMusicTracks() {
  return [
    ...(musicTracksByScene.overworld || []),
    ...(musicTracksByScene.cottage || [])
  ];
}

function getActiveTracks() {
  return musicTracksByScene[musicState.scene] || [];
}

function ensureMusicQueue() {
  const scene = musicState.scene;
  const tracks = getActiveTracks();
  if (!tracks.length) return;

  if (!musicState.orderByScene[scene] || musicState.orderByScene[scene].length === 0) {
    musicState.orderByScene[scene] = shuffle(tracks.map((_, idx) => idx));
    musicState.orderIndexByScene[scene] = 0;
  }
}

function currentMusicTrack() {
  ensureMusicQueue();
  const tracks = getActiveTracks();
  const scene = musicState.scene;
  const order = musicState.orderByScene[scene] || [];
  if (!tracks.length || !order.length) return null;
  const orderIndex = musicState.orderIndexByScene[scene] ?? 0;
  const trackIndex = order[orderIndex];
  return tracks[trackIndex];
}

function advanceMusicTrack() {
  const scene = musicState.scene;
  const tracks = getActiveTracks();
  const order = musicState.orderByScene[scene] || [];
  if (!order.length || !tracks.length) return;

  musicState.orderIndexByScene[scene] = (musicState.orderIndexByScene[scene] ?? 0) + 1;
  if (musicState.orderIndexByScene[scene] >= order.length) {
    musicState.orderByScene[scene] = shuffle(tracks.map((_, idx) => idx));
    musicState.orderIndexByScene[scene] = 0;
  }
}

function playCurrentMusic() {
  const track = currentMusicTrack();
  if (!track) return;
  if (musicState.playing && musicState.playing !== track) {
    musicState.playing.pause();
  }
  const scene = musicState.scene;
  const resumeInfo = musicResumeState[scene];
  const tracks = getActiveTracks();
  const order = musicState.orderByScene[scene] || [];
  const orderIndex = musicState.orderIndexByScene[scene] ?? 0;
  const trackIndex = order[orderIndex];

  // If we have resume info for this scene and it matches the current track, keep its timestamp
  if (resumeInfo && typeof resumeInfo.trackIndex === 'number' && resumeInfo.trackIndex === trackIndex) {
    track.currentTime = resumeInfo.time ?? 0;
  } else {
    track.currentTime = 0;
  }
  musicResumeState[scene] = null;
  musicState.playing = track;
  applyMusicVolume();
  track.play().catch((err) => {
    console.warn('Music playback blocked until user interaction', err);
  });
}

function handleMusicEnded() {
  musicState.playing = null;
  advanceMusicTrack();
  playCurrentMusic();
}

function beginMusicOnInteraction() {
  resumeAudioContextIfNeeded();
  if (musicState.started) return;
  ensureAudioContext();
  musicState.started = true;
  allMusicTracks().forEach(track => track.addEventListener('ended', handleMusicEnded));
  playCurrentMusic();
  window.removeEventListener('pointerdown', beginMusicOnInteraction);
  window.removeEventListener('keydown', beginMusicOnInteraction);
}

window.addEventListener('pointerdown', beginMusicOnInteraction);
window.addEventListener('keydown', beginMusicOnInteraction);

// #endregion MUSIC

// =========================
// MUSIC CONTROLS UI
// =========================
// #region MUSIC_CONTROLS

const musicToggleBtn = document.getElementById('music-toggle');
const musicVolumeSlider = document.getElementById('music-volume');

if (musicVolumeSlider) {
  musicVolumeSlider.value = masterVolume.toString();
}

function applyMusicVolume() {
  const effectiveVolume = musicState.muted ? 0 : musicState.volume * musicState.sceneScale;
  const clamped = Math.min(1, Math.max(0, effectiveVolume));
  if (musicGainNode) {
    musicGainNode.gain.value = clamped;
  }
  if (musicState.playing) {
    musicState.playing.volume = clamped;
    musicState.playing.muted = musicState.muted;
  }
}

function updateMusicControls() {
  if (musicToggleBtn) {
    musicToggleBtn.classList.toggle('muted', musicState.muted);
    musicToggleBtn.setAttribute('aria-label', musicState.muted ? 'Unmute music' : 'Mute music');
    musicToggleBtn.setAttribute('aria-pressed', String(!musicState.muted));
  }
  if (musicVolumeSlider && musicVolumeSlider !== document.activeElement) {
    musicVolumeSlider.value = musicState.volume.toString();
  }
}

function setAudioMuted(muted) {
  audioMuted = muted;
  musicState.muted = muted;
  applyMusicVolume();
  refreshAllSfxVolumes();
  updateFireLoopVolume();
  updateMusicControls();
}

function setMusicSceneScale(scale) {
  musicState.sceneScale = Math.min(1, Math.max(0, scale));
  applyMusicVolume();
}

function setMusicScene(scene) {
  if (musicState.scene === scene) return;
  const prevScene = musicState.scene;

  const enteringOverworld = scene === 'overworld' && prevScene !== 'overworld';
  const enteringCottage = scene === 'cottage' && prevScene !== 'cottage';

  // Save resume info for the scene we are leaving
  if (musicState.playing) {
    const prevTracks = musicTracksByScene[prevScene] || [];
    const trackIndex = prevTracks.indexOf(musicState.playing);
    if (trackIndex !== -1) {
      musicResumeState[prevScene] = {
        trackIndex,
        time: musicState.playing.currentTime
      };
    }
    musicState.playing.pause();
    musicState.playing = null;
  }

  musicState.scene = scene;
  musicState.orderByScene[scene] = musicState.orderByScene[scene] || [];
  musicState.orderIndexByScene[scene] = musicState.orderIndexByScene[scene] ?? 0;
  ensureMusicQueue();

  // When returning to overworld, advance to the next track instead of resuming the same one.
  if (enteringOverworld) {
    musicResumeState.overworld = null;
    advanceMusicTrack();
  }

  // When entering cottage, start fresh from the next track instead of resuming.
  if (enteringCottage) {
    musicResumeState.cottage = null;
    advanceMusicTrack();
  }

  if (musicState.started) {
    playCurrentMusic();
  }
}

function setMasterVolume(value) {
  const clamped = Math.min(1, Math.max(0, Number(value)));
  masterVolume = clamped;
  musicState.volume = clamped;
  applyMusicVolume();
  refreshAllSfxVolumes();
  updateFireLoopVolume();
  updateMusicControls();
}

musicToggleBtn?.addEventListener('click', () => {
  resumeAudioContextIfNeeded();
  ensureAudioContext();
  setAudioMuted(!musicState.muted);
  // Sync with options menu mute button
  const optMuteBtn = document.getElementById('options-mute');
  if (optMuteBtn) {
    optMuteBtn.textContent = musicState.muted ? 'ðŸ”Š Unmute Sound' : 'ðŸ”‡ Mute Sound';
  }
});

musicVolumeSlider?.addEventListener('input', (event) => {
  resumeAudioContextIfNeeded();
  setMasterVolume(event.target.value);
  // Sync with options menu volume slider
  const optVolSlider = document.getElementById('options-volume');
  if (optVolSlider) {
    optVolSlider.value = event.target.value;
  }
});

setMasterVolume(masterVolume);


// #endregion MUSIC_CONTROLS


// =========================
// TOUCH INPUT
// =========================
// #region TOUCH_INPUT

const touchControls = document.getElementById('touch-controls');
const touchDirButtons = document.querySelectorAll('[data-dir]');
const touchActionButton = document.getElementById('touch-action');
const touchGiftButton = document.getElementById('touch-gift');
const touchInventoryButton = document.getElementById('touch-inventory');
const touchBackButton = document.getElementById('touch-back');
const touchOptionsButton = document.getElementById('touch-options');
const optionsOverlay = document.getElementById('options-overlay');
const optionsSaveButton = document.getElementById('options-save');
const optionsLoadButton = document.getElementById('options-load');
const optionsVolumeSlider = document.getElementById('options-volume');
const optionsMuteButton = document.getElementById('options-mute');
const optionsCloseButton = document.getElementById('options-close');
const touchControlsNode = document.getElementById('touch-controls');

let optionsMenuOpen = false;

function openOptionsMenu() {
  optionsMenuOpen = true;
  if (optionsOverlay) {
    optionsOverlay.classList.add('open');
  }
  // Sync volume slider with current volume
  if (optionsVolumeSlider) {
    optionsVolumeSlider.value = masterVolume.toString();
  }
  // Update mute button text
  updateMuteButtonText();
  // Trigger audio unlock on mobile
  ensureMobileAudioUnlock();
}

function closeOptionsMenu() {
  optionsMenuOpen = false;
  if (optionsOverlay) {
    optionsOverlay.classList.remove('open');
  }
}

function updateMuteButtonText() {
  if (optionsMuteButton) {
    optionsMuteButton.textContent = musicState.muted ? 'ðŸ”Š Unmute Sound' : 'ðŸ”‡ Mute Sound';
  }
}

function updateTouchControlsVisibility() {
  const overlayQuery = '(pointer: coarse) and (orientation: landscape) and (max-width: 1100px)';
  showOverlayMode = window.matchMedia(overlayQuery).matches;
  if (touchControlsNode) {
    touchControlsNode.style.pointerEvents = 'auto';
  }
}

window.addEventListener('resize', updateTouchControlsVisibility);
updateTouchControlsVisibility();

function setTouchDirection(dir, pressed) {
  if (!(dir in touchDirections)) return;
  touchDirections[dir] = pressed;
}

function bindPointerButton(element, onPress, onRelease) {
  if (!element) return;

  const pressHandler = (event) => {
    event.preventDefault();
    element.setPointerCapture?.(event.pointerId);
    onPress?.(event);
  };

  const releaseHandler = (event) => {
    event.preventDefault();
    onRelease?.(event);
    element.releasePointerCapture?.(event.pointerId);
  };

  element.addEventListener('pointerdown', pressHandler);
  element.addEventListener('pointerup', releaseHandler);
  element.addEventListener('pointerleave', releaseHandler);
  element.addEventListener('pointercancel', releaseHandler);
  element.addEventListener('contextmenu', (event) => event.preventDefault());
}

touchDirButtons.forEach((button) => {
  const dir = button.dataset.dir;
  bindPointerButton(
    button,
    () => {
      // Handle menu navigation with D-pad
      if (craftingMenuOpen) {
        const availableRecipes = getAvailableRecipes();
        if (dir === 'up') {
          craftingMenuSelection = Math.max(0, craftingMenuSelection - 1);
        } else if (dir === 'down') {
          craftingMenuSelection = Math.min(availableRecipes.length - 1, craftingMenuSelection + 1);
        }
      } else if (tailorShopOpen) {
        if (dir === 'up') {
          tailorShopSelection = Math.max(0, tailorShopSelection - 1);
        } else if (dir === 'down') {
          tailorShopSelection = Math.min(tailorBuyPrices.length - 1, tailorShopSelection + 1);
        }
      } else if (dyeShopOpen) {
        if (dir === 'up') {
          dyeShopSelection = Math.max(0, dyeShopSelection - 1);
        } else if (dir === 'down') {
          dyeShopSelection = Math.min(dyeShopTrades.length - 1, dyeShopSelection + 1);
        }
      } else if (merchantShopOpen) {
        if (dir === 'up') {
          merchantShopSelection = Math.max(0, merchantShopSelection - 1);
        } else if (dir === 'down') {
          merchantShopSelection = Math.min(merchantStock.length - 1, merchantShopSelection + 1);
        }
      } else if (farmShopOpen) {
        if (dir === 'up') {
          farmShopSelection = Math.max(0, farmShopSelection - 1);
        } else if (dir === 'down') {
          farmShopSelection = Math.min(farmShopItems.length - 1, farmShopSelection + 1);
        }
      } else if (buildModeActive) {
        // Move build cursor with D-pad
        if (dir === 'up') {
          moveBuildCursor(0, -1);
        } else if (dir === 'down') {
          moveBuildCursor(0, 1);
        } else if (dir === 'left') {
          moveBuildCursor(-1, 0);
        } else if (dir === 'right') {
          moveBuildCursor(1, 0);
        }
      } else if (fastTravelOpen) {
        const destinations = getAvailableFastTravelDestinations();
        if (dir === 'up') {
          fastTravelSelection = Math.max(0, fastTravelSelection - 1);
        } else if (dir === 'down') {
          fastTravelSelection = Math.min(destinations.length - 1, fastTravelSelection + 1);
        }
      } else if (ordersBoardOpen) {
        if (dir === 'left') {
          ordersBoardTab = 'daily';
          ordersBoardSelection = 0;
        } else if (dir === 'right') {
          ordersBoardTab = 'weekly';
          ordersBoardSelection = 0;
        } else if (dir === 'up' && ordersBoardTab === 'daily') {
          ordersBoardSelection = Math.max(0, ordersBoardSelection - 1);
        } else if (dir === 'down' && ordersBoardTab === 'daily') {
          ordersBoardSelection = Math.min(dailyOrders.length - 1, ordersBoardSelection + 1);
        }
      } else if (giftMenuOpen) {
        const items = getGiftableItems();
        if (dir === 'up') {
          giftMenuSelection = Math.max(0, giftMenuSelection - 1);
        } else if (dir === 'down') {
          giftMenuSelection = Math.min(items.length - 1, giftMenuSelection + 1);
        }
      } else if (festivalMenuOpen) {
        if (dir === 'up') {
          festivalMenuSelection = Math.max(0, festivalMenuSelection - 1);
        } else if (dir === 'down') {
          festivalMenuSelection = Math.min(1, festivalMenuSelection + 1);
        }
      } else {
        setTouchDirection(dir, true);
      }
    },
    () => {
      if (!craftingMenuOpen && !tailorShopOpen && !dyeShopOpen && !merchantShopOpen && !farmShopOpen && !fastTravelOpen && !ordersBoardOpen && !buildModeActive && !giftMenuOpen && !festivalMenuOpen) {
        setTouchDirection(dir, false);
      }
    }
  );
});

bindPointerButton(touchActionButton, () => {
  // Handle fishing mini-game
  if (fishingActive) {
    handleFishingInput('action');
    return;
  }
  // Handle loom attune mini-game
  if (loomAttuneActive) {
    handleLoomAttuneInput('action');
    return;
  }
  // Handle knitting sprint mini-game
  if (knittingSprintActive) {
    handleKnittingSprintInput('action');
    return;
  }
  // Handle festival menu
  if (festivalMenuOpen) {
    handleFestivalMenuInput('e');
    return;
  }
  // Handle gift menu - give selected item
  if (giftMenuOpen) {
    giveSelectedGift();
    return;
  }
  if (fastTravelOpen) {
    executeFastTravel();
    return;
  }
  if (ordersBoardOpen) {
    tryCompleteSelectedOrder();
    return;
  }
  if (buildModeActive) {
    placeBuildItem();
    return;
  }
  if (merchantShopOpen) {
    buyFromMerchant();
    return;
  }
  if (dyeShopOpen) {
    tradeAtDyeShop();
    return;
  }
  if (tailorShopOpen) {
    sellToTailor();
    return;
  }
  if (dialogueOpen) {
    advanceDialogue();
    return;
  }
  if (craftingMenuOpen) {
    // Craft selected recipe
    const availableRecipes = getAvailableRecipes();
    const recipe = availableRecipes[craftingMenuSelection];
    if (canAffordRecipe(recipe)) {
      // Check if this will trigger the knitting sprint
      if (recipe.sellPrice && recipe.sellPrice > 0) {
        // Knitting sprint handles the crafting
        craftRecipe(recipe);
      } else {
        // Normal crafting
        craftRecipe(recipe);
        showMessage(`Crafted ${getRecipeOutputsText(recipe)}!`);
        if (sounds.knit) sounds.knit.play().catch(() => {});
      }
    } else {
      showMessage(`Not enough materials for ${recipe.name}.`);
    }
  } else {
    handleAction();
  }
}, null);

// Gift button - opens gift menu when talking to NPC
bindPointerButton(touchGiftButton, () => {
  if (dialogueOpen && currentNPC && !giftMenuOpen) {
    openGiftMenu();
  } else if (giftMenuOpen) {
    giveSelectedGift();
  }
}, null);

bindPointerButton(touchInventoryButton, () => {
  if (craftingMenuOpen) {
    craftingMenuOpen = false;
  } else {
    inventoryOpen = !inventoryOpen;
  }
}, null);

// Back button - closes any open menu (like pressing Escape)
bindPointerButton(touchBackButton, () => {
  if (fishingActive) {
    handleFishingInput('cancel');
    return;
  }
  if (loomAttuneActive) {
    handleLoomAttuneInput('cancel');
    return;
  }
  if (knittingSprintActive) {
    handleKnittingSprintInput('cancel');
    return;
  }
  if (optionsMenuOpen) {
    closeOptionsMenu();
    return;
  }
  if (giftMenuOpen) {
    closeGiftMenu();
    return;
  }
  if (merchantShopOpen) {
    closeMerchantShop();
    return;
  }
  if (dyeShopOpen) {
    closeDyeShop();
    return;
  }
  if (tailorShopOpen) {
    closeTailorShop();
    return;
  }
  if (farmShopOpen) {
    closeFarmShop();
    return;
  }
  if (fastTravelOpen) {
    closeFastTravel();
    return;
  }
  if (ordersBoardOpen) {
    closeOrdersBoard();
    return;
  }
  if (buildModeActive) {
    exitBuildMode();
    return;
  }
  if (dialogueOpen) {
    closeDialogue();
    return;
  }
  if (craftingMenuOpen) {
    craftingMenuOpen = false;
    if (touchBackButton) touchBackButton.classList.remove('visible');
    return;
  }
  if (inventoryOpen) {
    inventoryOpen = false;
    return;
  }
  // Hide self if nothing was open
  if (touchBackButton) touchBackButton.classList.remove('visible');
}, null);

// Options button - opens options menu
bindPointerButton(touchOptionsButton, () => {
  if (optionsMenuOpen) {
    closeOptionsMenu();
  } else {
    openOptionsMenu();
  }
}, null);

// Options menu buttons
if (optionsSaveButton) {
  optionsSaveButton.addEventListener('click', () => {
    saveGame();
    closeOptionsMenu();
  });
}

if (optionsLoadButton) {
  optionsLoadButton.addEventListener('click', () => {
    loadGame();
    closeOptionsMenu();
  });
}

if (optionsVolumeSlider) {
  optionsVolumeSlider.addEventListener('input', (e) => {
    masterVolume = parseFloat(e.target.value);
    musicState.volume = masterVolume;
    applyMusicVolume();
    // Sync with main volume slider too
    if (musicVolumeSlider) {
      musicVolumeSlider.value = masterVolume.toString();
    }
    // Ensure audio is unlocked when adjusting volume
    ensureMobileAudioUnlock();
  });
}

if (optionsMuteButton) {
  optionsMuteButton.addEventListener('click', () => {
    musicState.muted = !musicState.muted;
    applyMusicVolume();
    updateMuteButtonText();
    // Sync with main mute button
    if (musicToggleBtn) {
      musicToggleBtn.classList.toggle('muted', musicState.muted);
    }
    ensureMobileAudioUnlock();
  });
}

if (optionsCloseButton) {
  optionsCloseButton.addEventListener('click', () => {
    closeOptionsMenu();
  });
}

// Close options when clicking overlay background
if (optionsOverlay) {
  optionsOverlay.addEventListener('click', (e) => {
    if (e.target === optionsOverlay) {
      closeOptionsMenu();
    }
  });
}

// Debug mode activation - tap title 5 times to reveal debug button
const optionsTitle = document.getElementById('options-title');
const optionsDebugBtn = document.getElementById('options-debug');
let debugTapCount = 0;
let debugTapTimer = null;

if (optionsTitle && optionsDebugBtn) {
  optionsTitle.addEventListener('click', () => {
    debugTapCount++;
    clearTimeout(debugTapTimer);
    debugTapTimer = setTimeout(() => { debugTapCount = 0; }, 2000);
    
    if (debugTapCount >= 5) {
      optionsDebugBtn.style.display = 'block';
      debugTapCount = 0;
      showMessage('Debug mode revealed!');
    }
  });
  
  optionsDebugBtn.addEventListener('click', () => {
    debugUnlockAll = !debugUnlockAll;
    optionsDebugBtn.textContent = debugUnlockAll ? 'ðŸ”’ Lock Areas' : 'ðŸ”“ Unlock Areas';
    showMessage(debugUnlockAll ? 'ðŸ”“ All areas unlocked!' : 'ðŸ”’ Area locks restored.');
  });
}


function ensureMobileAudioUnlock() {
  resumeAudioContextIfNeeded();
  if (!musicState.started) {
    beginMusicOnInteraction();
  }
}

window.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    ensureMobileAudioUnlock();
  }
});

touchControlsNode?.addEventListener('pointerdown', ensureMobileAudioUnlock);
optionsOverlay?.addEventListener('pointerdown', ensureMobileAudioUnlock);

// #endregion TOUCH_INPUT


// =========================
// ENVIRONMENT AUDIO MANAGEMENT
// =========================
// #region ENV_AUDIO

function handleEnvironmentAudio(mapName) {
  const insideCottage = mapName === 'cottage';
  setMusicSceneScale(insideCottage ? MUSIC_INTERIOR_SCALE : 1);
  setMusicScene(insideCottage ? 'cottage' : 'overworld');
  setFireLoopActive(insideCottage);
}

// #endregion ENV_AUDIO



// =========================
// CONFIG & MAPS
// =========================
// #region CONFIG & MAPS
    const TILE_SIZE = 32;

// =========================
// QUEST/STORY SYSTEM
// =========================
const storyProgress = {
  chapter: 0,
  villagersHelped: 0,
  itemsCrafted: 0,
  shardsFound: 0,
  beachUnlocked: false,
  mountainUnlocked: false,
  caveUnlocked: false,
  loomRestored: false,
  shards: {
    beach: false,
    mountain: false,
    cave: false
  },
  storyFlags: {
    heardLegend: false,
    metBeachNPC: false,
    foundCaveEntrance: false
  }
};

// =========================
// FESTIVAL OF THREADS ARC
// =========================
const festivalProgress = {
  started: false,
  currentStep: 0, // 0=not started, 1=gathering, 2=decorating, 3=ceremony, 4=complete
  materialsGathered: {
    dyes: 0,      // Need 3 dyes (any type)
    feathers: 0,  // Need 2 peacock feathers
    cloth: 0      // Need 1 luxury item (luxuryYarn or any luxury craft)
  },
  decorationsPlaced: 0, // Need to place 3 decorations
  ceremonyWatched: false,
  rewardClaimed: false
};

// Festival requirements
const FESTIVAL_REQUIREMENTS = {
  dyes: 3,
  feathers: 2,
  cloth: 1,
  decorations: 3
};

// Festival reward: 50% discount on fast travel for 10 trips
let festivalFastTravelDiscount = 0;

// Check if festival can start (requires beach unlocked)
function canStartFestival() {
  return storyProgress.beachUnlocked && !festivalProgress.started;
}

// Start the festival arc
function startFestival() {
  if (!canStartFestival()) return;
  festivalProgress.started = true;
  festivalProgress.currentStep = 1;
  showMessage("ðŸŽª The Festival of Threads has begun! Gather materials to help decorate the village!");
}

// Check materials in inventory for festival
function checkFestivalMaterials() {
  // Count dyes
  const dyeCount = (inventory.amberDye || 0) + (inventory.tealDye || 0) + 
                   (inventory.indigoDye || 0) + (inventory.violetDye || 0);
  
  // Count feathers
  const featherCount = inventory.feather || 0;
  
  // Count luxury items
  const luxuryCount = (inventory.luxuryYarn || 0) + (inventory.luxurySocks || 0) + 
                      (inventory.fancyScarf || 0) + (inventory.royalCloak || 0);
  
  return {
    dyes: dyeCount,
    feathers: featherCount,
    cloth: luxuryCount
  };
}

// Donate materials for festival
function donateFestivalMaterials() {
  if (festivalProgress.currentStep !== 1) return false;
  
  const mats = checkFestivalMaterials();
  let donated = false;
  
  // Donate dyes
  if (festivalProgress.materialsGathered.dyes < FESTIVAL_REQUIREMENTS.dyes) {
    const dyeTypes = ['amberDye', 'tealDye', 'indigoDye', 'violetDye'];
    for (const dye of dyeTypes) {
      while ((inventory[dye] || 0) > 0 && festivalProgress.materialsGathered.dyes < FESTIVAL_REQUIREMENTS.dyes) {
        inventory[dye]--;
        festivalProgress.materialsGathered.dyes++;
        donated = true;
      }
    }
  }
  
  // Donate feathers
  if (festivalProgress.materialsGathered.feathers < FESTIVAL_REQUIREMENTS.feathers) {
    while ((inventory.feather || 0) > 0 && festivalProgress.materialsGathered.feathers < FESTIVAL_REQUIREMENTS.feathers) {
      inventory.feather--;
      festivalProgress.materialsGathered.feathers++;
      donated = true;
    }
  }
  
  // Donate luxury cloth
  if (festivalProgress.materialsGathered.cloth < FESTIVAL_REQUIREMENTS.cloth) {
    const luxuryTypes = ['luxuryYarn', 'luxurySocks', 'fancyScarf', 'royalCloak'];
    for (const item of luxuryTypes) {
      while ((inventory[item] || 0) > 0 && festivalProgress.materialsGathered.cloth < FESTIVAL_REQUIREMENTS.cloth) {
        inventory[item]--;
        festivalProgress.materialsGathered.cloth++;
        donated = true;
      }
    }
  }
  
  if (donated) {
    const g = festivalProgress.materialsGathered;
    const r = FESTIVAL_REQUIREMENTS;
    showMessage(`Festival donations: Dyes ${g.dyes}/${r.dyes}, Feathers ${g.feathers}/${r.feathers}, Cloth ${g.cloth}/${r.cloth}`);
    
    // Check if all materials gathered
    if (g.dyes >= r.dyes && g.feathers >= r.feathers && g.cloth >= r.cloth) {
      festivalProgress.currentStep = 2;
      showMessage("ðŸŽ‰ All materials gathered! Time to decorate the village square!");
    }
  } else {
    showMessage("You don't have any festival materials to donate.");
  }
  
  return donated;
}

// Place a festival decoration
function placeFestivalDecoration() {
  if (festivalProgress.currentStep !== 2) return false;
  if (currentMap !== 'village') {
    showMessage("Decorations can only be placed in the village square!");
    return false;
  }
  
  festivalProgress.decorationsPlaced++;
  
  if (festivalProgress.decorationsPlaced >= FESTIVAL_REQUIREMENTS.decorations) {
    festivalProgress.currentStep = 3;
    showMessage("ðŸ® The village is beautifully decorated! The evening ceremony will begin!");
    // Auto-start ceremony after a moment
    setTimeout(() => {
      if (festivalProgress.currentStep === 3) {
        startFestivalCeremony();
      }
    }, 2000);
  } else {
    const remaining = FESTIVAL_REQUIREMENTS.decorations - festivalProgress.decorationsPlaced;
    showMessage(`Decoration placed! ${remaining} more to go!`);
  }
  
  return true;
}

// Festival ceremony
let festivalCeremonyActive = false;
let festivalCeremonyPhase = 0;
let festivalCeremonyTimer = 0;

function startFestivalCeremony() {
  if (festivalProgress.currentStep !== 3) return;
  festivalCeremonyActive = true;
  festivalCeremonyPhase = 1;
  festivalCeremonyTimer = 0;
  showMessage("âœ¨ The Festival of Threads ceremony begins...");
}

function updateFestivalCeremony() {
  if (!festivalCeremonyActive) return;
  
  festivalCeremonyTimer++;
  
  // Phase 1: Lanterns light up (0-120 frames = 2 sec)
  if (festivalCeremonyPhase === 1 && festivalCeremonyTimer >= 120) {
    festivalCeremonyPhase = 2;
    festivalCeremonyTimer = 0;
    showMessage("ðŸ® The lanterns glow with warm light...");
  }
  
  // Phase 2: Fireworks (120-240 frames = 2 sec)
  if (festivalCeremonyPhase === 2 && festivalCeremonyTimer >= 120) {
    festivalCeremonyPhase = 3;
    festivalCeremonyTimer = 0;
    showMessage("ðŸŽ† Colorful threads dance in the evening sky!");
  }
  
  // Phase 3: Reward (240-360 frames = 2 sec)
  if (festivalCeremonyPhase === 3 && festivalCeremonyTimer >= 120) {
    festivalCeremonyPhase = 4;
    festivalCeremonyTimer = 0;
    completeFestival();
  }
  
  // Phase 4: End ceremony (after 60 more frames)
  if (festivalCeremonyPhase === 4 && festivalCeremonyTimer >= 60) {
    festivalCeremonyActive = false;
    festivalCeremonyPhase = 0;
  }
}

function completeFestival() {
  festivalProgress.currentStep = 4;
  festivalProgress.ceremonyWatched = true;
  festivalProgress.rewardClaimed = true;
  
  // Award: 10 free/discounted fast travels
  festivalFastTravelDiscount = 10;
  
  // Bonus gold
  inventory.gold += 50;
  
  showMessage("ðŸŽŠ Festival Complete! You earned 50 gold and 10 FREE fast travels!");
}

// Track festival materials when items are added to inventory
function trackFestivalMaterial(itemId, amount) {
  if (!festivalProgress.started || festivalProgress.currentStep !== 1) return;
  
  // Track dyes
  const dyeItems = ['amberDye', 'tealDye', 'indigoDye', 'crimsonDye', 'goldDye'];
  if (dyeItems.includes(itemId)) {
    festivalProgress.materialsGathered.dyes = Math.min(
      festivalProgress.materialsGathered.dyes + amount,
      FESTIVAL_REQUIREMENTS.dyes
    );
  }
  
  // Track feathers
  if (itemId === 'feather') {
    festivalProgress.materialsGathered.feathers = Math.min(
      festivalProgress.materialsGathered.feathers + amount,
      FESTIVAL_REQUIREMENTS.feathers
    );
  }
  
  // Track luxury cloth
  if (itemId === 'luxuryCloth') {
    festivalProgress.materialsGathered.cloth = Math.min(
      festivalProgress.materialsGathered.cloth + amount,
      FESTIVAL_REQUIREMENTS.cloth
    );
  }
  
  // Check if gathering is complete
  if (checkGatheringComplete()) {
    showMessage("ðŸŽª You've gathered all festival materials! Visit Elder Mara.");
  }
}

// Check if gathering phase is complete
function checkGatheringComplete() {
  const g = festivalProgress.materialsGathered;
  const r = FESTIVAL_REQUIREMENTS;
  return g.dyes >= r.dyes && g.feathers >= r.feathers && g.cloth >= r.cloth;
}

// Get festival status text
function getFestivalStatusText() {
  switch (festivalProgress.currentStep) {
    case 0: return "Not started";
    case 1: 
      const g = festivalProgress.materialsGathered;
      const r = FESTIVAL_REQUIREMENTS;
      return `Gathering: Dyes ${g.dyes}/${r.dyes}, Feathers ${g.feathers}/${r.feathers}, Cloth ${g.cloth}/${r.cloth}`;
    case 2:
      return `Decorating: ${festivalProgress.decorationsPlaced}/${FESTIVAL_REQUIREMENTS.decorations} placed`;
    case 3: return "Ceremony in progress!";
    case 4: return "Complete! ðŸŽ‰";
    default: return "";
  }
}

// Debug mode for testing - unlocks all areas
let debugUnlockAll = false;

function canAccessMap(mapName) {
  if (debugUnlockAll) return true;
  
  switch(mapName) {
    case 'overworld':
    case 'cottage':
    case 'village':
    case 'forest':
      return true; // Always accessible
    case 'beach':
      return storyProgress.beachUnlocked || storyProgress.villagersHelped >= 2;
    case 'mountain':
      return storyProgress.mountainUnlocked || storyProgress.itemsCrafted >= 5;
    case 'cave':
      return storyProgress.caveUnlocked || storyProgress.shards.beach;
    default:
      return false;
  }
}

function checkStoryMilestones() {
  // Check for beach unlock
  if (!storyProgress.beachUnlocked && storyProgress.villagersHelped >= 2) {
    storyProgress.beachUnlocked = true;
    showMessage('âœ¨ The path to the beach has opened! Head east from the village.');
    if (!storyProgress.storyFlags.heardLegend) {
      setTimeout(() => {
        showMessage('Old Barnaby mentioned something about crystal shards...');
      }, 4000);
    }
  }
  
  // Check for mountain unlock
  if (!storyProgress.mountainUnlocked && storyProgress.itemsCrafted >= 5) {
    storyProgress.mountainUnlocked = true;
    showMessage('âœ¨ Your crafting skill has revealed a mountain path! Go north from the forest.');
  }
  
  // Check for cave unlock
  if (!storyProgress.caveUnlocked && storyProgress.shards.beach) {
    storyProgress.caveUnlocked = true;
    showMessage('âœ¨ The crystal shard glows... a cave entrance appears in the mountain!');
  }
  
  // Check for loom restoration
  if (!storyProgress.loomRestored && 
      storyProgress.shards.beach && 
      storyProgress.shards.mountain && 
      storyProgress.shards.cave) {
    storyProgress.loomRestored = true;
    showMessage('ðŸŽ‰ All crystal shards found! The Crystal Loom awakens!');
  }
}

function onVillagerHelped() {
  storyProgress.villagersHelped++;
  checkStoryMilestones();
  
  // First villager helped - tell the legend
  if (storyProgress.villagersHelped === 1 && !storyProgress.storyFlags.heardLegend) {
    storyProgress.storyFlags.heardLegend = true;
    setTimeout(() => {
      showMessage('Granny Maple: "Thank you dear! Have you heard of the Crystal Loom?"');
    }, 2000);
    setTimeout(() => {
      showMessage('"They say its shards are scattered across Yarnvale..."');
    }, 6000);
  }
}

function onItemCrafted() {
  storyProgress.itemsCrafted++;
  checkStoryMilestones();
}

function collectCrystalShard(location) {
  if (storyProgress.shards[location]) return false;
  
  storyProgress.shards[location] = true;
  storyProgress.shardsFound++;
  
  const shardMessages = {
    beach: 'ðŸ’Ž You found the Beach Crystal Shard! It shimmers with ocean blue light.',
    mountain: 'ðŸ’Ž You found the Mountain Crystal Shard! It glows with earthy warmth.',
    cave: 'ðŸ’Ž You found the Cave Crystal Shard! It pulses with ancient power.'
  };
  
  showMessage(shardMessages[location] || 'ðŸ’Ž You found a Crystal Shard!');
  checkStoryMilestones();
  return true;
}

// =========================
// INTRO SYSTEM
// =========================
// #region INTRO

let introState = 'welcome'; // 'welcome' | 'dialogue' | 'complete'
let introDone = false;

// Check if player has seen intro before
function loadIntroState() {
  const saved = localStorage.getItem('introComplete');
  if (saved === 'true') {
    introDone = true;
    introState = 'complete';
  }
}

function completeIntro() {
  introDone = true;
  introState = 'complete';
  localStorage.setItem('introComplete', 'true');
  taskBoardOpen = true; // Show task board after intro
}

function drawIntroScreen() {
  // Semi-transparent overlay
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  if (introState === 'welcome') {
    drawWelcomeScreen();
  } else if (introState === 'dialogue') {
    drawIntroDialogue();
  }
}

function drawWelcomeScreen() {
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Title box
  const boxW = 300;
  const boxH = 200;
  const boxX = centerX - boxW / 2;
  const boxY = centerY - boxH / 2 - 40;
  
  ctx.fillStyle = 'rgba(20, 30, 60, 0.95)';
  ctx.beginPath();
  ctx.roundRect(boxX, boxY, boxW, boxH, 10);
  ctx.fill();
  
  ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(boxX, boxY, boxW, boxH, 10);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#ffc864';
  ctx.font = 'bold 32px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸ§¶ Yarnvale', centerX, boxY + 45);
  
  // Subtitle
  ctx.fillStyle = '#d0d0d0';
  ctx.font = '14px system-ui';
  ctx.fillText('A cozy crafting adventure', centerX, boxY + 70);
  
  // Instructions
  ctx.fillStyle = '#a0a0a0';
  ctx.font = '12px system-ui';
  const instructions = [
    'Use WASD or Arrow Keys to move',
    'Press E to interact with objects',
    'Craft items at your spinning wheel'
  ];
  let instrY = boxY + 100;
  instructions.forEach(line => {
    ctx.fillText(line, centerX, instrY);
    instrY += 20;
  });
  
  // Continue button
  const btnW = 120;
  const btnH = 35;
  const btnX = centerX - btnW / 2;
  const btnY = boxY + boxH - 50;
  
  ctx.fillStyle = '#ffc864';
  ctx.beginPath();
  ctx.roundRect(btnX, btnY, btnW, btnH, 6);
  ctx.fill();
  
  ctx.fillStyle = '#1a1a2e';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Let\'s Begin', centerX, btnY + 23);
  ctx.textAlign = 'left';
  
  // Store button rect for click detection
  window.welcomeBtnRect = { x: btnX, y: btnY, w: btnW, h: btnH };
}

function drawIntroDialogue() {
  const centerX = canvas.width / 2;
  const dialogueY = canvas.height - 130;
  
  // Dialogue box - wider and taller
  const boxW = Math.min(340, canvas.width - 30);
  const boxH = 110;
  const boxX = centerX - boxW / 2;
  
  ctx.fillStyle = 'rgba(20, 30, 60, 0.95)';
  ctx.beginPath();
  ctx.roundRect(boxX, dialogueY, boxW, boxH, 10);
  ctx.fill();
  
  ctx.strokeStyle = 'rgba(100, 200, 150, 0.6)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(boxX, dialogueY, boxW, boxH, 10);
  ctx.stroke();
  
  // NPC name
  ctx.fillStyle = '#64c896';
  ctx.font = 'bold 12px system-ui';
  ctx.fillText('Elder Mara ðŸŒ¾', boxX + 12, dialogueY + 22);
  
  // Dialogue text - shorter lines that fit
  ctx.fillStyle = '#e0e0e0';
  ctx.font = '11px system-ui';
  const text1 = 'Welcome to Yarnvale!';
  const text2 = 'Your cottage and sheep are ready.';
  const text3 = 'Start by shearing the sheep, then spin yarn.';
  
  ctx.fillText(text1, boxX + 12, dialogueY + 44);
  ctx.fillText(text2, boxX + 12, dialogueY + 60);
  ctx.fillText(text3, boxX + 12, dialogueY + 76);
  
  // Continue hint
  ctx.fillStyle = '#888';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'right';
  ctx.fillText('Click to continue...', boxX + boxW - 12, dialogueY + boxH - 10);
  ctx.textAlign = 'left';
  
  // Store dialogue box rect for click detection
  window.dialogueBtnRect = { x: boxX, y: dialogueY, w: boxW, h: boxH };
}

// #endregion INTRO

// =========================
// TASK BOARD SYSTEM
// =========================
// #region TASK_BOARD

let taskBoardOpen = false;  // Closed until intro completes
let taskBoardMinimized = false;

// Task definitions - ordered by progression
const gameTasks = [
  // Tutorial tasks
  { id: 'shearSheep', name: 'Shear a sheep', description: 'Find the sheep and press E to shear', category: 'tutorial', check: () => inventory.wool > 0 || storyProgress.itemsCrafted > 0 },
  { id: 'craftYarn', name: 'Spin wool into yarn', description: 'Use the spinning wheel in the cottage', category: 'tutorial', check: () => inventory.yarn > 0 || inventory.scarf > 0 || inventory.socks > 0 },
  { id: 'craftItem', name: 'Craft your first item', description: 'Make socks, scarf, or mittens', category: 'tutorial', check: () => storyProgress.itemsCrafted >= 1 },
  { id: 'sellItem', name: 'Sell at the market', description: 'Find the market stall and sell crafted goods', category: 'tutorial', check: () => inventory.gold > 0 },
  
  // Early game tasks
  { id: 'helpVillager', name: 'Help a villager', description: 'Find villagers with (!) in The Village', category: 'early', check: () => storyProgress.villagersHelped >= 1, dynamicDesc: () => {
    const count = getAvailableQuestCount();
    if (count > 0) return `${count} villager${count > 1 ? 's' : ''} need${count === 1 ? 's' : ''} help! Look for (!)`;
    return 'No requests available right now';
  }},
  { id: 'visitVillage', name: 'Visit The Village', description: 'Walk south from your farm', category: 'early', check: () => storyProgress.villagersHelped >= 1 || taskProgress.visitedVillage },
  { id: 'meetMerchant', name: 'Meet the traveling merchant', description: 'Wandering Willa appears on your farm', category: 'early', check: () => taskProgress.metMerchant },
  
  // Crystal Loom quest line
  { id: 'hearLegend', name: 'Hear the Crystal Loom legend', description: 'Help villagers to learn the story', category: 'loom', check: () => storyProgress.storyFlags.heardLegend },
  { id: 'unlockBeach', name: 'Unlock the beach', description: 'Help 2 villagers to open the path', category: 'loom', check: () => storyProgress.beachUnlocked },
  { id: 'findBeachShard', name: 'Find the Beach Crystal Shard', description: 'Search the sandy shores', category: 'loom', check: () => storyProgress.shards.beach },
  { id: 'unlockMountain', name: 'Unlock the mountain path', description: 'Craft 5 items to reveal the way', category: 'loom', check: () => storyProgress.mountainUnlocked },
  { id: 'findMountainShard', name: 'Find the Mountain Crystal Shard', description: 'Explore the snowy peaks', category: 'loom', check: () => storyProgress.shards.mountain },
  { id: 'unlockCave', name: 'Discover the crystal cave', description: 'The beach shard reveals the entrance', category: 'loom', check: () => storyProgress.caveUnlocked },
  { id: 'findCaveShard', name: 'Find the Cave Crystal Shard', description: 'Deep in the glowing cave', category: 'loom', check: () => storyProgress.shards.cave },
  { id: 'restoreLoom', name: 'Restore the Crystal Loom', description: 'Gather all three shards', category: 'loom', check: () => storyProgress.loomRestored },
  
  // Festival of Threads tasks
  { id: 'festivalStart', name: 'ðŸŽª Festival of Threads', description: 'Talk to Elder Mara in the village to begin', category: 'festival', check: () => festivalProgress.started },
  { id: 'festivalGather', name: 'Gather festival materials', description: 'Collect dyes, feathers, and luxury cloth', category: 'festival', check: () => festivalProgress.currentStep >= 2, dynamicDesc: () => {
    if (!festivalProgress.started) return 'Start the festival first';
    const g = festivalProgress.materialsGathered;
    const r = FESTIVAL_REQUIREMENTS;
    return `Dyes ${g.dyes}/${r.dyes}, Feathers ${g.feathers}/${r.feathers}, Cloth ${g.cloth}/${r.cloth}`;
  }},
  { id: 'festivalDecorate', name: 'Decorate the village', description: 'Place decorations in the village square', category: 'festival', check: () => festivalProgress.currentStep >= 3, dynamicDesc: () => {
    if (festivalProgress.currentStep < 2) return 'Gather materials first';
    return `Decorations: ${festivalProgress.decorationsPlaced}/${FESTIVAL_REQUIREMENTS.decorations}`;
  }},
  { id: 'festivalComplete', name: 'Attend the ceremony', description: 'Watch the evening celebration', category: 'festival', check: () => festivalProgress.currentStep >= 4 },
  
  // Exploration tasks
  { id: 'exploreForest', name: 'Explore the forest', description: 'Find forageable items', category: 'explore', check: () => taskProgress.foragedFirst },
  { id: 'craftDye', name: 'Craft a dye', description: 'Use foraged items to make dyes', category: 'explore', check: () => inventory.amberDye > 0 || inventory.tealDye > 0 },
  
  // Vendor tasks
  { id: 'visitDyeShop', name: 'Visit the Dye Shop', description: 'Find Iris in south village', category: 'explore', check: () => taskProgress.visitedDyeShop },
  { id: 'tradeAtDyeShop', name: 'Trade at the Dye Shop', description: 'Exchange foraged items for dyes', category: 'explore', check: () => taskProgress.tradedAtDyeShop },
  { id: 'visitTailor', name: 'Visit the Tailor', description: 'Find Master Theo in south village', category: 'explore', check: () => taskProgress.visitedTailor },
  { id: 'sellToTailor', name: 'Sell to the Tailor', description: 'Earn gold from crafted items', category: 'explore', check: () => taskProgress.soldToTailor }
];

// Track additional progress not covered by storyProgress
const taskProgress = {
  visitedVillage: false,
  metMerchant: false,
  foragedFirst: false,
  visitedDyeShop: false,
  tradedAtDyeShop: false,
  visitedTailor: false,
  soldToTailor: false
};

function getTaskStatus(task) {
  return task.check() ? 'complete' : 'incomplete';
}

function getActiveTasks() {
  // Return tasks that are either in progress or recently completed
  const completed = [];
  const active = [];
  
  for (const task of gameTasks) {
    const status = getTaskStatus(task);
    if (status === 'complete') {
      completed.push({ ...task, status });
    } else {
      // Only show next incomplete tasks (up to 3)
      if (active.length < 3) {
        active.push({ ...task, status });
      }
    }
  }
  
  // Show last 2 completed + active tasks
  const recentCompleted = completed.slice(-2);
  return [...recentCompleted, ...active];
}

function toggleTaskBoard() {
  taskBoardOpen = !taskBoardOpen;
  taskBoardMinimized = false;
}

function minimizeTaskBoard() {
  taskBoardMinimized = true;
}

function drawTaskBoardUI() {
  // Don't show task board during intro
  if (!introDone) return;
  
  const isMobile = isCoarsePointer || showOverlayMode;
  
  // Draw minimized button if minimized
  if (taskBoardMinimized || !taskBoardOpen) {
    const btnX = 8;
    const btnY = 54;
    const btnW = isMobile ? 36 : 32;
    const btnH = isMobile ? 36 : 32;
    
    ctx.fillStyle = 'rgba(5, 8, 16, 0.75)';
    ctx.beginPath();
    ctx.roundRect(btnX, btnY, btnW, btnH, 6);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(btnX, btnY, btnW, btnH, 6);
    ctx.stroke();
    
    // Task icon (clipboard)
    ctx.fillStyle = '#a9b3cd';
    ctx.font = isMobile ? '16px system-ui' : '16px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸ“‹', btnX + btnW/2, btnY + btnH/2 + 5);
    ctx.textAlign = 'left';
    
    // Show notification dot if there are active tasks
    const activeTasks = getActiveTasks().filter(t => t.status === 'incomplete');
    if (activeTasks.length > 0) {
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(btnX + btnW - 4, btnY + 6, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = '8px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(activeTasks.length, btnX + btnW - 4, btnY + 9);
      ctx.textAlign = 'left';
    }
    return;
  }
  
  // Full task board panel - smaller on mobile
  const panelX = 8;
  const panelY = 54;
  const panelW = isMobile ? 160 : 220;
  const tasks = getActiveTasks();
  const maxTasksShown = isMobile ? 3 : 5;
  const tasksToShow = tasks.slice(0, maxTasksShown);
  const panelH = isMobile ? Math.min(44 + tasksToShow.length * 28, 140) : Math.min(50 + tasks.length * 36, 260);
  
  // Panel background
  ctx.fillStyle = 'rgba(6, 12, 26, 0.92)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 10);
  ctx.fill();
  
  // Border
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 10);
  ctx.stroke();
  
  // Header
  ctx.fillStyle = 'rgba(40, 60, 100, 0.6)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, isMobile ? 24 : 28, [10, 10, 0, 0]);
  ctx.fill();
  
  ctx.fillStyle = '#f5f7ff';
  ctx.font = isMobile ? 'bold 10px system-ui' : 'bold 11px system-ui';
  ctx.fillText('ðŸ“‹ Tasks', panelX + 8, panelY + (isMobile ? 16 : 18));
  
  // Close button (X) - bigger touch target on mobile
  const closeBtnSize = isMobile ? 22 : 20;
  const closeBtnX = panelX + panelW - closeBtnSize - 2;
  const closeBtnY = panelY + (isMobile ? 1 : 4);
  
  // Close button background - more visible red
  ctx.fillStyle = 'rgba(220, 70, 70, 0.9)';
  ctx.beginPath();
  ctx.roundRect(closeBtnX, closeBtnY, closeBtnSize, closeBtnSize, 4);
  ctx.fill();
  
  // Border for visibility
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.roundRect(closeBtnX, closeBtnY, closeBtnSize, closeBtnSize, 4);
  ctx.stroke();
  
  // X icon - draw as lines for clarity
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  const xPad = 6;
  ctx.moveTo(closeBtnX + xPad, closeBtnY + xPad);
  ctx.lineTo(closeBtnX + closeBtnSize - xPad, closeBtnY + closeBtnSize - xPad);
  ctx.moveTo(closeBtnX + closeBtnSize - xPad, closeBtnY + xPad);
  ctx.lineTo(closeBtnX + xPad, closeBtnY + closeBtnSize - xPad);
  ctx.stroke();
  
  // Crystal Loom progress indicator (hide on mobile to save space)
  if (!isMobile) {
    const shardsFound = (storyProgress.shards.beach ? 1 : 0) + 
                        (storyProgress.shards.mountain ? 1 : 0) + 
                        (storyProgress.shards.cave ? 1 : 0);
    ctx.fillStyle = '#7a8ba8';
    ctx.font = '9px system-ui';
    ctx.fillText(`ðŸ’Ž ${shardsFound}/3`, panelX + panelW - 95, panelY + 18);
  }
  
  // Task list
  let taskY = panelY + (isMobile ? 30 : 38);
  const displayTasks = isMobile ? tasksToShow : tasks;
  displayTasks.forEach((task, i) => {
    const isComplete = task.status === 'complete';
    
    // Checkbox
    const checkSize = isMobile ? 12 : 14;
    ctx.strokeStyle = isComplete ? '#4ade80' : '#7a8ba8';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(panelX + 8, taskY, checkSize, checkSize, 2);
    ctx.stroke();
    
    if (isComplete) {
      ctx.fillStyle = '#4ade80';
      ctx.font = isMobile ? 'bold 9px system-ui' : 'bold 11px system-ui';
      ctx.fillText('âœ“', panelX + (isMobile ? 10 : 12), taskY + (isMobile ? 10 : 12));
    }
    
    // Task name
    ctx.fillStyle = isComplete ? '#6b7280' : '#f5f7ff';
    ctx.font = isComplete ? (isMobile ? '9px system-ui' : '10px system-ui') : (isMobile ? 'bold 9px system-ui' : 'bold 10px system-ui');
    const maxTextW = panelW - 35;
    let taskName = task.name;
    if (ctx.measureText(taskName).width > maxTextW) {
      while (ctx.measureText(taskName + 'â€¦').width > maxTextW && taskName.length > 0) {
        taskName = taskName.slice(0, -1);
      }
      taskName += 'â€¦';
    }
    ctx.fillText(taskName, panelX + (isMobile ? 24 : 30), taskY + (isMobile ? 9 : 11));
    
    // Description (if not complete and not mobile)
    if (!isComplete && task.description && !isMobile) {
      ctx.fillStyle = '#7a8ba8';
      ctx.font = '8px system-ui';
      // Use dynamic description if available
      let desc = (task.dynamicDesc && typeof task.dynamicDesc === 'function') ? task.dynamicDesc() : task.description;
      if (ctx.measureText(desc).width > maxTextW) {
        while (ctx.measureText(desc + 'â€¦').width > maxTextW && desc.length > 0) {
          desc = desc.slice(0, -1);
        }
        desc += 'â€¦';
      }
      ctx.fillText(desc, panelX + 30, taskY + 22);
    }
    
    taskY += isMobile ? (isComplete ? 20 : 26) : (isComplete ? 24 : 36);
  });
  
  // Show "more tasks" indicator on mobile if truncated
  if (isMobile && tasks.length > maxTasksShown) {
    ctx.fillStyle = '#7a8ba8';
    ctx.font = '8px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(`+${tasks.length - maxTasksShown} more`, panelX + panelW/2, panelY + panelH - 4);
    ctx.textAlign = 'left';
  } else if (!isMobile) {
    // Hint at bottom (desktop only)
    ctx.fillStyle = '#555';
    ctx.font = '8px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Press T to toggle', panelX + panelW/2, panelY + panelH - 6);
    ctx.textAlign = 'left';
  }
}

// #endregion TASK_BOARD

    // Tile legend:
    // 0 grass, 1 path, 2 tree (solid), 3 water (solid), 4 fence (solid),
    // 5 cottage roof, 6 door, 7 interior wall (solid), 8 interior floor
    // 9 stone path, 10 market stall (solid), 11 well (solid), 12 flower patch
    // 13 bush, 14 bridge, 15 sign post
    // NEW: 16 sand, 17 ocean (solid), 18 shells, 19 rock (solid), 20 driftwood
    // 21 palm tree (solid), 22 tide pool, 23 cliff (solid), 24 mountain path
    // 25 snow grass, 26 cave entrance, 27 crystal (interactable)
    const maps = {
      overworld: {
        cols: 19,
        rows: 13,
        data: [
          [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
          [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,1,5,5,5,1,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,1,5,5,5,1,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,1,5,6,5,1,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,3,3,0,0,0,0,0,1,0,0,29,0,0,0,0,0,2],
          [2,0,3,3,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2],
        ]
      },
      cottage: {
        cols: 9,
        rows: 7,
        data: [
          [7,7,7,7,7,7,7,7,7],
          [7,8,8,8,8,8,8,8,7],
          [7,8,8,8,8,8,8,8,7],
          [7,8,8,8,8,8,8,8,7],
          [7,8,8,8,8,8,8,8,7],
          [7,8,8,8,6,8,8,8,7],
          [7,7,7,7,7,7,7,7,7]
        ]
      },
      village: {
        cols: 19,
        rows: 13,
        data: [
          [2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,0,9,9,0,0,0,0,1,0,0,0,0,9,9,0,0,2],
          [2,0,0,9,9,0,0,0,8,8,8,0,0,0,9,9,0,0,2],
          [2,0,0,0,0,0,0,0,8,10,8,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,11,0,0,8,8,8,0,0,11,0,1,1,1,1],
          [2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
          [2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1],
          [2,0,0,12,12,0,0,0,0,1,0,0,0,0,12,12,0,0,2],
          [2,0,0,12,12,0,0,0,0,1,0,0,0,0,12,12,0,0,2],
          [2,0,0,0,0,0,0,29,0,1,0,0,0,0,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1],
          [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1]
        ]
      },
      forest: {
        cols: 19,
        rows: 13,
        data: [
          [2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2],
          [1,1,1,0,2,2,0,0,0,1,0,0,0,0,2,2,0,0,2],
          [1,0,1,0,0,2,0,0,0,1,0,0,0,0,0,2,0,0,2],
          [2,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,2],
          [2,2,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,2,2],
          [2,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,0,0,2],
          [2,0,0,0,2,0,0,0,1,1,13,0,0,0,0,0,2,0,2],
          [2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,2,0,2],
          [2,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,2],
          [2,2,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,2,2],
          [2,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,2],
          [2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2],
          [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
        ]
      },
      beach: {
        cols: 19,
        rows: 13,
        data: [
          [17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17],
          [17,17,17,17,22,17,17,17,17,17,17,17,17,22,17,17,17,17,17],
          [17,17,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17],
          [16,16,16,18,16,16,16,20,16,16,16,18,16,16,16,16,16,16,16],
          [16,16,16,16,16,19,16,16,16,16,16,16,16,16,19,16,18,16,16],
          [16,16,18,16,16,16,16,16,21,16,16,16,16,16,16,16,16,16,16],
          [1,1,1,16,16,16,16,16,16,27,16,16,16,16,16,16,16,16,16],
          [16,16,16,16,16,16,20,16,16,16,16,16,21,16,16,16,18,16,16],
          [16,16,16,19,16,16,16,16,16,16,16,16,29,16,16,16,16,16,16],
          [0,0,0,0,16,16,16,16,18,16,16,16,16,16,20,16,16,16,16],
          [2,2,0,0,0,16,16,16,16,16,16,16,19,16,16,16,16,16,16],
          [2,2,2,0,0,0,16,16,16,16,16,16,16,16,16,16,18,16,16],
          [2,2,2,2,2,0,0,16,16,16,16,16,16,16,16,16,16,16,16]
        ]
      },
      mountain: {
        cols: 19,
        rows: 13,
        data: [
          [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23],
          [23,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,23],
          [23,25,25,19,25,25,25,25,24,24,24,25,25,25,19,25,25,25,23],
          [23,25,25,25,25,25,25,25,24,26,24,25,25,25,25,25,25,25,23],
          [23,25,25,25,19,25,25,25,24,24,24,25,25,25,25,19,25,25,23],
          [23,25,25,25,25,25,25,25,25,24,25,25,25,25,25,25,25,25,23],
          [23,25,25,25,25,25,19,25,25,24,25,25,19,25,25,25,25,25,23],
          [23,25,25,25,25,25,25,25,25,24,25,25,25,25,25,25,25,25,23],
          [23,25,25,19,25,25,25,25,25,24,29,25,25,25,25,19,25,25,23],
          [23,25,25,25,25,25,25,25,24,24,24,25,25,25,25,25,25,25,23],
          [23,25,25,25,25,25,25,25,24,27,24,25,25,25,25,25,25,25,23],
          [23,25,25,25,25,25,25,25,1,1,1,25,25,25,25,25,25,25,23],
          [23,23,23,23,23,23,23,23,1,1,1,23,23,23,23,23,23,23,23]
        ]
      },
      cave: {
        cols: 19,
        rows: 13,
        data: [
          [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23],
          [23,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,23],
          [23,8,8,8,19,8,8,8,8,8,8,8,8,19,8,8,8,8,23],
          [23,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,23],
          [23,8,8,8,8,8,19,8,8,8,8,8,19,8,8,8,8,8,23],
          [23,8,8,8,8,8,8,8,8,27,8,8,8,8,8,8,8,8,23],
          [23,8,8,19,8,8,8,8,8,8,8,8,8,8,8,19,8,8,23],
          [23,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,23],
          [23,8,8,8,8,19,8,8,8,8,8,8,8,19,8,8,8,8,23],
          [23,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,23],
          [23,8,8,8,8,8,8,8,8,6,8,8,8,8,8,8,8,8,23],
          [23,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,23],
          [23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23]
        ]
      },
      wetlands: {
        cols: 19,
        rows: 13,
        data: [
          // 30 = wetland grass, 31 = swamp water, 32 = reeds, 33 = lily pads, 34 = dye plant (indigo), 35 = dye plant (violet)
          [2,2,2,2,2,2,0,1,1,1,0,2,2,2,2,2,2,2,2],
          [2,30,30,30,32,30,30,1,31,1,30,30,32,30,30,30,30,2,2],
          [30,30,31,33,31,30,30,30,31,30,30,31,31,33,31,30,30,30,30],
          [30,32,31,31,31,33,30,30,31,30,34,31,31,31,31,32,30,30,30],
          [30,30,30,31,31,31,30,30,30,30,30,33,31,31,30,30,30,19,30],
          [30,30,35,30,33,31,31,30,30,30,30,31,31,33,30,30,30,30,30],
          [1,1,30,30,30,31,31,33,30,29,30,30,31,31,30,30,35,30,30],
          [30,30,30,32,30,30,31,31,30,30,30,33,31,30,30,32,30,30,30],
          [30,30,30,30,30,33,31,31,30,30,30,31,31,30,30,30,30,19,30],
          [30,32,30,30,30,31,33,30,30,30,34,30,33,30,30,32,30,30,30],
          [30,30,30,35,30,30,30,30,30,30,30,30,30,30,35,30,30,30,30],
          [2,30,30,30,30,32,30,30,30,30,30,30,32,30,30,30,30,2,2],
          [2,2,2,2,2,2,30,1,1,1,30,2,2,2,2,2,2,2,2]
        ]
      }
    };

const doorTilesByMap = {};
for (const [name, map] of Object.entries(maps)) {
  doorTilesByMap[name] = [];
  for (let row = 0; row < map.rows; row++) {
    for (let col = 0; col < map.cols; col++) {
      if (map.data[row][col] === 6) {
        doorTilesByMap[name].push({ x: col, y: row });
      }
    }
  }
}

// Static tile layer cache per map to avoid redrawing terrain every frame
const baseMapCanvases = {};

// Animation time for animated tiles (grass, water, trees, etc.)
let animationTime = 0;

function invalidateBaseMaps() {
  Object.keys(baseMapCanvases).forEach(key => delete baseMapCanvases[key]);
}

function ensureBaseMapCanvas(mapName) {
  if (baseMapCanvases[mapName]) return baseMapCanvases[mapName];
  const map = maps[mapName];
  if (!map) return null;

  const offscreen = document.createElement('canvas');
  offscreen.width = map.cols * TILE_SIZE;
  offscreen.height = map.rows * TILE_SIZE;
  const offCtx = offscreen.getContext('2d');
  for (let y = 0; y < map.rows; y++) {
    for (let x = 0; x < map.cols; x++) {
      drawTile(map.data[y][x], x, y, offCtx);
    }
  }

  baseMapCanvases[mapName] = offscreen;
  return offscreen;
}

['grass1', 'grass2', 'grass3'].forEach(name => {
  const asset = artAssets[name];
  if (asset?.image) {
    asset.image.addEventListener('load', invalidateBaseMaps);
  }
});

// ===== INVENTORY =====
let inventoryOpen = false;

let inventory = {
  wool: 0,
  yarn: 0,
  luxuryYarn: 0,
  goatFur: 0,
  feather: 0,
  scarf: 0,
  luxuryScarf: 0,
  mittens: 0,
  luxuryMittens: 0,
  socks: 0,
  luxurySocks: 0,
  hat: 0,
  fancyHat: 0,
  blanket: 0,
  featherFan: 0,
  gold: 0,
  // Dyed items
  tealScarf: 0,
  amberHat: 0,
  tealSocks: 0,
  amberMittens: 0,
  // Shell crafts
  shellNecklace: 0,
  shellChimes: 0,
  // Forest forageables
  mushroom: 0,
  berries: 0,
  wildFlower: 0,
  resin: 0,
  shell: 0,
  // Dyes (crafted from forageables)
  amberDye: 0,
  tealDye: 0,
  brownDye: 0,
  // Special threads from dye shop
  pearlThread: 0,
  // Forest trade items
  mushroomBasket: 0,
  berryJam: 0,
  // Building materials (from Farm Shop)
  fencing: 0,
  gate: 0,
  // Wetlands forageables
  indigoFlower: 0,
  violetFlower: 0,
  reedBundle: 0,
  // Wetland crafted dyes
  indigoDye: 0,
  violetDye: 0
};

// Load intro state from localStorage
loadIntroState();

// =========================
// FORAGEABLE SYSTEM
// =========================
// #region FORAGEABLES

const forageableSpots = [
  // Forest mushrooms (regenerate)
  { id: 'mushroom1', map: 'forest', x: 4, y: 5, type: 'mushroom', respawnTime: 1800, available: true, timer: 0 },
  { id: 'mushroom2', map: 'forest', x: 11, y: 8, type: 'mushroom', respawnTime: 1800, available: true, timer: 0 },
  { id: 'mushroom3', map: 'forest', x: 16, y: 4, type: 'mushroom', respawnTime: 1800, available: true, timer: 0 },
  // Forest berries
  { id: 'berries1', map: 'forest', x: 3, y: 7, type: 'berries', respawnTime: 2400, available: true, timer: 0 },
  { id: 'berries2', map: 'forest', x: 14, y: 6, type: 'berries', respawnTime: 2400, available: true, timer: 0 },
  // Wild flowers (for dyes)
  { id: 'flower1', map: 'forest', x: 6, y: 10, type: 'wildFlower', respawnTime: 3000, available: true, timer: 0 },
  { id: 'flower2', map: 'forest', x: 15, y: 9, type: 'wildFlower', respawnTime: 3000, available: true, timer: 0 },
  // Resin from trees (rare, slower respawn) - moved to walkable tile near trees
  { id: 'resin1', map: 'forest', x: 3, y: 4, type: 'resin', respawnTime: 4800, available: true, timer: 0 },
  // Beach shells (decorative/trade)
  { id: 'shell1', map: 'beach', x: 3, y: 3, type: 'shell', respawnTime: 1200, available: true, timer: 0 },
  { id: 'shell2', map: 'beach', x: 11, y: 3, type: 'shell', respawnTime: 1200, available: true, timer: 0 },
  { id: 'shell3', map: 'beach', x: 16, y: 4, type: 'shell', respawnTime: 1200, available: true, timer: 0 },
  // Wetlands - Indigo dye plants (at tile 34 locations)
  { id: 'indigo1', map: 'wetlands', x: 10, y: 3, type: 'indigoFlower', respawnTime: 3600, available: true, timer: 0 },
  { id: 'indigo2', map: 'wetlands', x: 10, y: 9, type: 'indigoFlower', respawnTime: 3600, available: true, timer: 0 },
  // Wetlands - Violet dye plants (at tile 35 locations)
  { id: 'violet1', map: 'wetlands', x: 2, y: 5, type: 'violetFlower', respawnTime: 3600, available: true, timer: 0 },
  { id: 'violet2', map: 'wetlands', x: 16, y: 6, type: 'violetFlower', respawnTime: 3600, available: true, timer: 0 },
  { id: 'violet3', map: 'wetlands', x: 3, y: 10, type: 'violetFlower', respawnTime: 3600, available: true, timer: 0 },
  { id: 'violet4', map: 'wetlands', x: 14, y: 10, type: 'violetFlower', respawnTime: 3600, available: true, timer: 0 }
];

// =========================
// COLLECTIBLE SPAWN VALIDATION
// =========================
// Check if a tile is valid for placing collectibles
function isValidCollectibleTile(mapName, x, y) {
  const map = maps[mapName];
  if (!map) return false;
  if (x < 0 || y < 0 || x >= map.cols || y >= map.rows) return false;
  
  const tile = map.data[y][x];
  
  // Solid/blocked tiles that collectibles should NOT spawn on:
  // 2=tree, 3=water, 4=fence, 7=wall, 10=market stall, 11=well,
  // 17=ocean, 19=rock, 21=palm tree, 22=tide pool, 23=cliff, 31=swamp water
  const blockedTiles = [2, 3, 4, 7, 10, 11, 17, 19, 21, 22, 23, 31];
  return !blockedTiles.includes(tile);
}

// Validate all forageable spots on game load
function validateForageableSpots() {
  forageableSpots.forEach(spot => {
    if (!isValidCollectibleTile(spot.map, spot.x, spot.y)) {
      console.warn(`Forageable '${spot.id}' at (${spot.x}, ${spot.y}) on ${spot.map} is on a blocked tile!`);
    }
  });
}

// Run validation on load
validateForageableSpots();

const forageableInfo = {
  mushroom: { name: 'Mushroom', color: '#c49a6c', icon: 'ðŸ„', message: 'You found a mushroom!' },
  berries: { name: 'Wild Berries', color: '#8b3a62', icon: 'ðŸ«', message: 'You picked some wild berries!' },
  wildFlower: { name: 'Wild Flower', color: '#d4a5e8', icon: 'ðŸŒ¸', message: 'You picked a beautiful wild flower!' },
  resin: { name: 'Tree Resin', color: '#d4a020', icon: 'ðŸ’§', message: 'You collected some sticky tree resin!' },
  shell: { name: 'Seashell', color: '#f5e6d3', icon: 'ðŸš', message: 'You found a pretty seashell!' },
  indigoFlower: { name: 'Indigo Flower', color: '#4060c0', icon: 'ðŸ’™', message: 'You picked a rare indigo flower!' },
  violetFlower: { name: 'Violet Flower', color: '#9060c0', icon: 'ðŸ’œ', message: 'You picked a beautiful violet flower!' }
};

// Add shell to inventory if not present (legacy check)
// if (inventory.shell === undefined) inventory.shell = 0;

function updateForageables() {
  forageableSpots.forEach(spot => {
    if (!spot.available) {
      spot.timer++;
      if (spot.timer >= spot.respawnTime) {
        spot.available = true;
        spot.timer = 0;
      }
    }
  });
}

function getForageableAt(map, x, y) {
  return forageableSpots.find(spot => 
    spot.map === map && spot.x === x && spot.y === y && spot.available
  );
}

function collectForageable(spot) {
  if (!spot || !spot.available) return false;
  
  const info = forageableInfo[spot.type];
  if (!info) return false;
  
  spot.available = false;
  spot.timer = 0;
  inventory[spot.type] = (inventory[spot.type] || 0) + 1;
  showMessage(info.message);
  
  // Track first forage for task board
  if (!taskProgress.foragedFirst) {
    taskProgress.foragedFirst = true;
  }
  
  return true;
}

function drawForageables() {
  forageableSpots.forEach(spot => {
    if (spot.map !== currentMap || !spot.available) return;
    
    const info = forageableInfo[spot.type];
    if (!info) return;
    
    const px = spot.x * TILE_SIZE;
    const py = spot.y * TILE_SIZE;
    
    // Gentle bobbing animation
    const bob = Math.sin(animationTime * 2 + spot.x * 0.5) * 2;
    
    // Draw glow/highlight
    ctx.fillStyle = `rgba(255, 255, 200, ${0.2 + Math.sin(animationTime * 3) * 0.1})`;
    ctx.beginPath();
    ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 12, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw icon
    ctx.font = '18px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(info.icon, px + TILE_SIZE/2, py + TILE_SIZE/2 + 6 + bob);
    ctx.textAlign = 'left';
  });
}

// #endregion FORAGEABLES

// ===== CRAFTING MENU =====
let craftingMenuOpen = false;
let craftingMenuSelection = 0;

const craftingRecipes = [
  // --- Material Processing ---
  {
    id: 'luxuryYarn',
    name: 'Luxury Yarn',
    description: 'Soft blend of wool and goat fur',
    inputs: { wool: 1, goatFur: 1 },
    outputs: { luxuryYarn: 2 },
    color: '#c8a0f0'
  },
  {
    id: 'yarn',
    name: 'Yarn',
    description: 'Spin wool into yarn',
    inputs: { wool: 2 },
    outputs: { yarn: 1 },
    color: '#f098c8'
  },
  // --- Basic Items ---
  {
    id: 'socks',
    name: 'Socks',
    description: 'Cosy knitted socks',
    inputs: { yarn: 2 },
    outputs: { socks: 1 },
    sellPrice: 8,
    color: '#a8d8a8'
  },
  {
    id: 'mittens',
    name: 'Mittens',
    description: 'Warm fluffy mittens',
    inputs: { goatFur: 2 },
    outputs: { mittens: 1 },
    sellPrice: 15,
    color: '#e8d0c0'
  },
  {
    id: 'scarf',
    name: 'Scarf',
    description: 'A cosy knitted scarf',
    inputs: { yarn: 3 },
    outputs: { scarf: 1 },
    sellPrice: 10,
    color: '#f2d27a'
  },
  {
    id: 'hat',
    name: 'Hat',
    description: 'A warm woolly hat',
    inputs: { yarn: 2, wool: 1 },
    outputs: { hat: 1 },
    sellPrice: 12,
    color: '#7eb8e8'
  },
  // --- Premium Items ---
  {
    id: 'luxuryMittens',
    name: 'Luxury Mittens',
    description: 'Silky soft premium mittens',
    inputs: { luxuryYarn: 2 },
    outputs: { luxuryMittens: 1 },
    sellPrice: 20,
    color: '#e0b8f0'
  },
  {
    id: 'luxuryScarf',
    name: 'Luxury Scarf',
    description: 'An exquisite shimmering scarf',
    inputs: { luxuryYarn: 3 },
    outputs: { luxuryScarf: 1 },
    sellPrice: 25,
    color: '#d8a0f8'
  },
  // --- Large Items ---
  {
    id: 'blanket',
    name: 'Blanket',
    description: 'A large cosy blanket',
    inputs: { yarn: 4, wool: 2 },
    outputs: { blanket: 1 },
    sellPrice: 30,
    color: '#f0c8a0'
  },
  // --- Dyes (from forageables) ---
  {
    id: 'amberDye',
    name: 'Amber Dye',
    description: 'Warm golden dye from resin and flowers',
    inputs: { resin: 1, wildFlower: 2 },
    outputs: { amberDye: 1 },
    color: '#d4a020'
  },
  {
    id: 'tealDye',
    name: 'Teal Dye',
    description: 'Cool blue-green dye from berries',
    inputs: { berries: 3, wildFlower: 1 },
    outputs: { tealDye: 1 },
    color: '#20a0a0'
  },
  {
    id: 'indigoDye',
    name: 'Indigo Dye',
    description: 'Deep blue dye from marsh indigo flowers',
    inputs: { indigoFlower: 2 },
    outputs: { indigoDye: 1 },
    color: '#4060c0'
  },
  {
    id: 'violetDye',
    name: 'Violet Dye',
    description: 'Rich purple dye from marsh violets',
    inputs: { violetFlower: 2 },
    outputs: { violetDye: 1 },
    color: '#9060c0'
  },
  // --- Forest Trade Items ---
  {
    id: 'mushroomBasket',
    name: 'Mushroom Basket',
    description: 'A basket of foraged mushrooms',
    inputs: { mushroom: 5 },
    outputs: { mushroomBasket: 1 },
    sellPrice: 15,
    color: '#c49a6c'
  },
  {
    id: 'berryJam',
    name: 'Berry Jam',
    description: 'Sweet jam from wild berries',
    inputs: { berries: 4 },
    outputs: { berryJam: 1 },
    sellPrice: 12,
    color: '#8b3a62'
  },
  // --- Feather Crafts ---
  {
    id: 'fancyHat',
    name: 'Fancy Hat',
    description: 'A decorative hat with peacock feathers',
    inputs: { hat: 1, feather: 2 },
    outputs: { fancyHat: 1 },
    sellPrice: 35,
    color: '#1a7f9a'
  },
  {
    id: 'featherFan',
    name: 'Feather Fan',
    description: 'An elegant decorative fan',
    inputs: { feather: 4 },
    outputs: { featherFan: 1 },
    sellPrice: 40,
    color: '#2d8b6e'
  },
  // --- Luxury Socks ---
  {
    id: 'luxurySocks',
    name: 'Luxury Socks',
    description: 'Extra soft socks from luxury yarn',
    inputs: { luxuryYarn: 2 },
    outputs: { luxurySocks: 1 },
    sellPrice: 18,
    color: '#e8c0f0'
  },
  // --- Dyed Items ---
  {
    id: 'tealScarf',
    name: 'Teal Scarf',
    description: 'A beautifully dyed teal scarf',
    inputs: { scarf: 1, tealDye: 1 },
    outputs: { tealScarf: 1 },
    sellPrice: 22,
    color: '#20a0a0'
  },
  {
    id: 'amberHat',
    name: 'Amber Hat',
    description: 'A warm hat with golden amber tones',
    inputs: { hat: 1, amberDye: 1 },
    outputs: { amberHat: 1 },
    sellPrice: 24,
    color: '#d4a020'
  },
  {
    id: 'tealSocks',
    name: 'Teal Socks',
    description: 'Stylish teal-dyed socks',
    inputs: { socks: 1, tealDye: 1 },
    outputs: { tealSocks: 1 },
    sellPrice: 18,
    color: '#30b0b0'
  },
  {
    id: 'amberMittens',
    name: 'Amber Mittens',
    description: 'Cosy mittens with warm amber hue',
    inputs: { mittens: 1, amberDye: 1 },
    outputs: { amberMittens: 1 },
    sellPrice: 28,
    color: '#e0b040'
  },
  // --- Shell Crafts ---
  {
    id: 'shellNecklace',
    name: 'Shell Necklace',
    description: 'A decorative beach-themed accessory',
    inputs: { shell: 5, yarn: 1 },
    outputs: { shellNecklace: 1 },
    sellPrice: 25,
    color: '#f0e8d0'
  },
  {
    id: 'shellChimes',
    name: 'Shell Chimes',
    description: 'Wind chimes made from ocean shells',
    inputs: { shell: 8 },
    outputs: { shellChimes: 1 },
    sellPrice: 35,
    color: '#c8e0f0'
  },
  // --- New Premium Clothing ---
  {
    id: 'sweater',
    name: 'Sweater',
    description: 'A warm cozy sweater',
    inputs: { yarn: 5, wool: 2 },
    outputs: { sweater: 1 },
    sellPrice: 35,
    color: '#8eb8d8'
  },
  {
    id: 'cape',
    name: 'Cape',
    description: 'A stylish flowing cape',
    inputs: { luxuryYarn: 4, feather: 1 },
    outputs: { cape: 1 },
    sellPrice: 45,
    color: '#9058a0'
  },
  {
    id: 'poncho',
    name: 'Poncho',
    description: 'A versatile warm poncho',
    inputs: { yarn: 4, goatFur: 2 },
    outputs: { poncho: 1 },
    sellPrice: 38,
    color: '#c08858'
  },
  // --- Plushies (Cute!) ---
  {
    id: 'sheepPlush',
    name: 'Sheep Plushie',
    description: 'An adorable stuffed sheep toy',
    inputs: { softFur: 3, wool: 2 },
    outputs: { sheepPlush: 1 },
    sellPrice: 28,
    color: '#f0f0f0'
  },
  {
    id: 'bunnyPlush',
    name: 'Bunny Plushie',
    description: 'A cuddly stuffed bunny',
    inputs: { softFur: 4, amberDye: 1 },
    outputs: { bunnyPlush: 1 },
    sellPrice: 32,
    color: '#e8d0a8'
  },
  // --- Decorative Items ---
  {
    id: 'banner',
    name: 'Festival Banner',
    description: 'Colorful decorative banner',
    inputs: { yarn: 3, tealDye: 1, amberDye: 1 },
    outputs: { banner: 1 },
    sellPrice: 30,
    color: '#e06080'
  },
  {
    id: 'lantern',
    name: 'Yarn Lantern',
    description: 'A decorative woven lantern',
    inputs: { yarn: 2, resin: 2 },
    outputs: { lantern: 1 },
    sellPrice: 22,
    color: '#f8d888'
  },
  // --- Shell Jewelry Set ---
  {
    id: 'shellBracelet',
    name: 'Shell Bracelet',
    description: 'A delicate shell bracelet',
    inputs: { shell: 3, yarn: 1 },
    outputs: { shellBracelet: 1 },
    sellPrice: 18,
    color: '#f8e8d8'
  },
  {
    id: 'shellEarrings',
    name: 'Shell Earrings',
    description: 'Elegant dangling shell earrings',
    inputs: { shell: 2 },
    outputs: { shellEarrings: 1 },
    sellPrice: 15,
    color: '#e8f0f8'
  },
  // --- Friendship-Unlocked Recipes ---
  {
    id: 'luxurySocksPlus',
    name: 'Luxury Socks+',
    description: 'Premium socks (Granny\'s secret pattern)',
    inputs: { luxuryYarn: 3, softFur: 1 },
    outputs: { luxurySocksPlus: 1 },
    sellPrice: 30,
    color: '#e8c8f8',
    requiresFriendship: 'luxurySocks'
  },
  {
    id: 'dyeBundle',
    name: 'Dye Bundle',
    description: 'A mixed set of dyes (Felix\'s technique)',
    inputs: { berries: 2, wildFlower: 2, resin: 1 },
    outputs: { amberDye: 1, tealDye: 1 },
    color: '#a080c0',
    requiresFriendship: 'dyeBundle'
  },
  {
    id: 'rainbowYarn',
    name: 'Rainbow Yarn',
    description: 'Multicolored magical yarn',
    inputs: { yarn: 2, amberDye: 1, tealDye: 1 },
    outputs: { rainbowYarn: 2 },
    color: '#ff88aa',
    requiresFriendship: 'rainbowYarn'
  },
  {
    id: 'fancyScarf',
    name: 'Fancy Scarf',
    description: 'Theo\'s signature scarf design',
    inputs: { luxuryYarn: 3, feather: 1 },
    outputs: { fancyScarf: 1 },
    sellPrice: 40,
    color: '#8060b0',
    requiresFriendship: 'fancyScarf'
  },
  {
    id: 'royalCloak',
    name: 'Royal Cloak',
    description: 'A majestic cloak fit for royalty',
    inputs: { luxuryYarn: 6, feather: 3, amberDye: 1 },
    outputs: { royalCloak: 1 },
    sellPrice: 80,
    color: '#6030a0',
    requiresFriendship: 'royalCloak'
  },
  {
    id: 'flowerCrown',
    name: 'Flower Crown',
    description: 'A beautiful crown of woven flowers',
    inputs: { wildFlower: 5, yarn: 1 },
    outputs: { flowerCrown: 1 },
    sellPrice: 20,
    color: '#f0a0c0',
    requiresFriendship: 'flowerCrown'
  },
  {
    id: 'herbalDye',
    name: 'Herbal Dye',
    description: 'Iris\'s special herbal dye blend',
    inputs: { herbs: 4, berries: 2 },
    outputs: { herbalDye: 2 },
    color: '#60a040',
    requiresFriendship: 'herbalDye'
  },
  {
    id: 'enchantedYarn',
    name: 'Enchanted Yarn',
    description: 'Yarn imbued with crystal magic',
    inputs: { luxuryYarn: 2, crystalShard: 1 },
    outputs: { enchantedYarn: 2 },
    color: '#a0e0f0',
    requiresFriendship: 'enchantedYarn'
  }
];

// Get recipes available to the player (filters out friendship-locked ones)
function getAvailableRecipes() {
  return craftingRecipes.filter(recipe => {
    if (!recipe.requiresFriendship) return true;
    return isRecipeUnlockedByFriendship(recipe.requiresFriendship);
  });
}

function canAffordRecipe(recipe) {
  for (const [item, amount] of Object.entries(recipe.inputs)) {
    if ((inventory[item] || 0) < amount) return false;
  }
  return true;
}

function craftRecipe(recipe) {
  if (!canAffordRecipe(recipe)) return false;
  
  // For sellable items, offer Knitting Sprint mini-game
  if (recipe.sellPrice && recipe.sellPrice > 0) {
    startKnittingSprint(recipe);
    craftingMenuOpen = false;
    return true;
  }
  
  // For non-sellable items, craft normally
  // Deduct inputs
  for (const [item, amount] of Object.entries(recipe.inputs)) {
    inventory[item] -= amount;
  }
  
  // Add outputs (with loom attune bonus if active)
  for (const [item, amount] of Object.entries(recipe.outputs)) {
    let finalAmount = amount;
    
    // Apply loom attune bonus
    if (loomAttuneBonusCrafts > 0) {
      finalAmount += 1;
    }
    
    inventory[item] = (inventory[item] || 0) + finalAmount;
    
    // Track for festival
    trackFestivalMaterial(item, finalAmount);
  }
  
  // Consume loom attune bonus
  if (loomAttuneBonusCrafts > 0) {
    loomAttuneBonusCrafts--;
    if (loomAttuneBonusCrafts === 0) {
      showMessage("Loom attunement faded. Craft bonus ended.");
    }
  }
  
  // Track story progress
  onItemCrafted();
  
  return true;
}

function getRecipeInputsText(recipe) {
  return Object.entries(recipe.inputs)
    .map(([item, amount]) => `${amount} ${item}`)
    .join(' + ');
}

function getRecipeOutputsText(recipe) {
  return Object.entries(recipe.outputs)
    .map(([item, amount]) => `${amount} ${item}`)
    .join(', ');
}




let message = null;
let messageExpiryTime = 0; // timestamp when current message should disappear

// One starter sheep in the paddock (overworld)
const sheep = {
  map: 'overworld',
  x: 5,
  y: 7,
  hasWool: true,
  woolTimer: 0, // counts frames until wool grows back
  // Wandering properties
  homeX: 5,
  homeY: 7,
  wanderRadius: 3,
  moveTimer: 0,
  moveDelay: 180, // frames between move attempts (~3 seconds at 60fps)
  isMoving: false,
  targetX: 5,
  targetY: 7,
  px: 5 * 32, // pixel position for smooth movement
  py: 7 * 32,
  moveProgress: 0,
  facing: 'down'
};

// Second sheep in the paddock (overworld) - TEST SHEEP
const sheep2 = {
  map: 'overworld',
  x: 7,
  y: 8,
  hasWool: true,
  woolTimer: 0,
  homeX: 7,
  homeY: 8,
  wanderRadius: 2,
  moveTimer: 0,
  moveDelay: 200,
  isMoving: false,
  targetX: 7,
  targetY: 8,
  px: 7 * 32,
  py: 8 * 32,
  moveProgress: 0,
  facing: 'down'
};

// One goat in the paddock (overworld)
const goat = {
  map: 'overworld',
  x: 14,
  y: 8,
  hasFur: true,
  furTimer: 0,
  // Wandering properties
  homeX: 14,
  homeY: 8,
  wanderRadius: 3,
  moveTimer: 0,
  moveDelay: 150,
  isMoving: false,
  targetX: 14,
  targetY: 8,
  px: 14 * 32,
  py: 8 * 32,
  moveProgress: 0,
  facing: 'down'
};

// Peacock for decorative feathers (overworld)
const peacock = {
  map: 'overworld',
  x: 15,
  y: 7,
  hasFeathers: true,
  featherTimer: 0,
  // Wandering properties
  homeX: 15,
  homeY: 7,
  wanderRadius: 3,
  moveTimer: 0,
  moveDelay: 120, // peacocks are more active
  isMoving: false,
  targetX: 15,
  targetY: 7,
  px: 15 * 32,
  py: 7 * 32,
  moveProgress: 0,
  facing: 'down',
  displayTimer: 0 // for tail fanning animation
};

// =========================
// ANIMAL WANDERING SYSTEM
// =========================
// #region ANIMAL_WANDERING

const ANIMAL_MOVE_SPEED = 2; // pixels per frame (slower than player)
const ANIMAL_MOVE_FRAMES = TILE_SIZE / ANIMAL_MOVE_SPEED;

function isValidAnimalTile(animal, tx, ty) {
  // Check bounds
  if (tx < 0 || ty < 0 || tx >= maps[animal.map].cols || ty >= maps[animal.map].rows) return false;
  
  // Check distance from home
  const dx = Math.abs(tx - animal.homeX);
  const dy = Math.abs(ty - animal.homeY);
  if (dx > animal.wanderRadius || dy > animal.wanderRadius) return false;
  
  // Check if tile is walkable (grass, path, interior floor)
  const mapData = maps[animal.map].data;
  const tile = mapData[ty][tx];
  // Allow: grass(0), path(1), interior floor(8), flower patch(12)
  if (tile !== 0 && tile !== 1 && tile !== 8 && tile !== 12) return false;
  
  // Check collision with player (only if on same map)
  if (animal.map === currentMap && tx === player.x && ty === player.y) return false;
  
  // Check collision with other animals
  if (animal !== sheep && tx === sheep.x && ty === sheep.y && sheep.map === animal.map) return false;
  if (animal !== sheep2 && tx === sheep2.x && ty === sheep2.y && sheep2.map === animal.map) return false;
  if (animal !== goat && tx === goat.x && ty === goat.y && goat.map === animal.map) return false;
  if (animal !== peacock && tx === peacock.x && ty === peacock.y && peacock.map === animal.map) return false;
  
  return true;
}

function updateAnimalWandering(animal) {
  // Only update if on same map as player (optimization) or nearby
  // For now, always update animals on overworld
  
  // Handle ongoing movement
  if (animal.isMoving) {
    animal.moveProgress++;
    const t = animal.moveProgress / ANIMAL_MOVE_FRAMES;
    
    // Lerp pixel position
    const startX = animal.x * TILE_SIZE;
    const startY = animal.y * TILE_SIZE;
    const endX = animal.targetX * TILE_SIZE;
    const endY = animal.targetY * TILE_SIZE;
    
    animal.px = startX + (endX - startX) * t;
    animal.py = startY + (endY - startY) * t;
    
    // Complete movement
    if (animal.moveProgress >= ANIMAL_MOVE_FRAMES) {
      animal.x = animal.targetX;
      animal.y = animal.targetY;
      animal.px = animal.x * TILE_SIZE;
      animal.py = animal.y * TILE_SIZE;
      animal.isMoving = false;
      animal.moveProgress = 0;
      // Random delay before next move
      animal.moveDelay = 120 + Math.floor(Math.random() * 180); // 2-5 seconds
      animal.moveTimer = 0;
    }
    return;
  }
  
  // Increment move timer
  animal.moveTimer++;
  
  // Check if it's time to try moving
  if (animal.moveTimer < animal.moveDelay) return;
  
  // 40% chance to stay still, 60% chance to try moving
  if (Math.random() < 0.4) {
    animal.moveTimer = 0;
    animal.moveDelay = 60 + Math.floor(Math.random() * 120); // shorter delay when staying still
    return;
  }
  
  // Pick a random direction
  const directions = [
    { dx: 0, dy: -1, facing: 'up' },
    { dx: 0, dy: 1, facing: 'down' },
    { dx: -1, dy: 0, facing: 'left' },
    { dx: 1, dy: 0, facing: 'right' }
  ];
  
  // Shuffle directions for randomness
  for (let i = directions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [directions[i], directions[j]] = [directions[j], directions[i]];
  }
  
  // Try each direction
  for (const dir of directions) {
    const newX = animal.x + dir.dx;
    const newY = animal.y + dir.dy;
    
    if (isValidAnimalTile(animal, newX, newY)) {
      animal.targetX = newX;
      animal.targetY = newY;
      animal.facing = dir.facing;
      animal.isMoving = true;
      animal.moveProgress = 0;
      break;
    }
  }
  
  // Reset timer whether move succeeded or not
  animal.moveTimer = 0;
}

// #endregion ANIMAL_WANDERING

// Knitting spot inside the cottage (must be on a floor tile)
const knittingSpot = {
  map: 'cottage',
  x: 3,
  y: 4  // Crafting table - left side of room
};

const marketSpot = {
  map: 'village',
  x: 9,  // Central building in The Village - the Village Market
  y: 5   // Right in front of market stall (tile 10)
};

const fireplaceSpot = {
  map: 'cottage',
  x: 2,
  y: 1
};

// ===== TRAVELING MERCHANT (Wandering Willa) =====
const travelingMerchant = {
  name: 'Wandering Willa',
  map: 'overworld',
  x: 2,
  y: 5,
  isPresent: false,
  spawnTimer: 0,
  spawnDelay: 3600, // 60 seconds at 60fps before first appearance
  stayDuration: 1800, // stays for 30 seconds
  stayTimer: 0,
  color: '#9b59b6'
};

// Merchant shop state
let merchantShopOpen = false;
let merchantShopSelection = 0;

// Items the traveling merchant sells
const merchantStock = [
  { id: 'redDye', name: 'Red Dye', price: 25, description: 'Vibrant crimson dye' },
  { id: 'blueDye', name: 'Blue Dye', price: 25, description: 'Deep ocean blue dye' },
  { id: 'greenDye', name: 'Green Dye', price: 25, description: 'Fresh forest green dye' },
  { id: 'goldenThread', name: 'Golden Thread', price: 50, description: 'Rare shimmering thread' },
  { id: 'silkRibbon', name: 'Silk Ribbon', price: 35, description: 'Luxurious silk ribbon' },
  { id: 'mysteryPattern', name: 'Mystery Pattern', price: 75, description: 'A secret knitting pattern' }
];

// ===== VILLAGE VENDOR SHOPS =====

// Dye Shop State
let dyeShopOpen = false;
let dyeShopSelection = 0;

// Dye shop trades - trade foraged items for dyes
const dyeShopTrades = [
  { give: 'berries', giveAmount: 3, receive: 'tealDye', receiveName: 'Teal Dye', description: 'Trade 3 berries for teal dye' },
  { give: 'wildFlower', giveAmount: 3, receive: 'amberDye', receiveName: 'Amber Dye', description: 'Trade 3 flowers for amber dye' },
  { give: 'resin', giveAmount: 2, receive: 'goldenThread', receiveName: 'Golden Thread', description: 'Trade 2 resin for golden thread' },
  { give: 'mushroom', giveAmount: 5, receive: 'brownDye', receiveName: 'Brown Dye', description: 'Trade 5 mushrooms for brown dye' },
  { give: 'shell', giveAmount: 4, receive: 'pearlThread', receiveName: 'Pearl Thread', description: 'Trade 4 shells for pearl thread' }
];

// Tailor Shop State
let tailorShopOpen = false;
let tailorShopSelection = 0;

// Tailor buys crafted items for gold
const tailorBuyPrices = [
  { id: 'scarf', name: 'Scarf', price: 25 },
  { id: 'socks', name: 'Socks', price: 20 },
  { id: 'mittens', name: 'Mittens', price: 30 },
  { id: 'hat', name: 'Hat', price: 28 },
  { id: 'blanket', name: 'Blanket', price: 55 },
  { id: 'luxuryScarf', name: 'Luxury Scarf', price: 60 },
  { id: 'luxuryMittens', name: 'Luxury Mittens', price: 70 },
  { id: 'luxurySocks', name: 'Luxury Socks', price: 65 },
  { id: 'mushroomBasket', name: 'Mushroom Basket', price: 40 },
  { id: 'berryJam', name: 'Berry Jam', price: 35 }
];

// Open/Close Dye Shop
function openDyeShop() {
  dyeShopOpen = true;
  dyeShopSelection = 0;
  taskProgress.visitedDyeShop = true;
  if (touchBackButton) touchBackButton.classList.add('visible');
}

function closeDyeShop() {
  dyeShopOpen = false;
  dyeShopSelection = 0;
  if (touchBackButton) touchBackButton.classList.remove('visible');
  showMessage("Iris: \"Come back with more foraged goods!\"");
}

// Trade at dye shop
function tradeAtDyeShop() {
  if (!dyeShopOpen) return;
  
  const trade = dyeShopTrades[dyeShopSelection];
  if (!trade) return;
  
  const haveAmount = inventory[trade.give] || 0;
  if (haveAmount < trade.giveAmount) {
    showMessage(`Need ${trade.giveAmount} ${trade.give}! You have ${haveAmount}.`);
    return;
  }
  
  inventory[trade.give] -= trade.giveAmount;
  inventory[trade.receive] = (inventory[trade.receive] || 0) + 1;
  showMessage(`Iris: "Wonderful! Here's your ${trade.receiveName}!"`);
  
  // Track for festival
  trackFestivalMaterial(trade.receive, 1);
  
  // Track for task board
  if (!taskProgress.tradedAtDyeShop) {
    taskProgress.tradedAtDyeShop = true;
  }
}

// Draw Dye Shop UI
function drawDyeShopUI() {
  if (!dyeShopOpen) return;
  
  const panelW = 320;
  const panelH = 260;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Panel background - darker purple for better contrast
  ctx.fillStyle = 'rgba(60, 40, 80, 0.98)';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  
  // Border
  ctx.strokeStyle = '#d8a0ff';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX + 1, panelY + 1, panelW - 2, panelH - 2);
  
  // Title
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText("ðŸŽ¨ Iris's Dye Shop ðŸŽ¨", panelX + panelW/2, panelY + 20);
  
  // Subtitle
  ctx.fillStyle = '#d8a0ff';
  ctx.font = '10px system-ui';
  ctx.fillText('Trade foraged items for dyes!', panelX + panelW/2, panelY + 36);
  ctx.textAlign = 'left';
  
  // Trade list
  const startY = panelY + 55;
  dyeShopTrades.forEach((trade, i) => {
    const y = startY + i * 32;
    const isSelected = i === dyeShopSelection;
    const haveAmount = inventory[trade.give] || 0;
    const canTrade = haveAmount >= trade.giveAmount;
    
    // Selection highlight
    if (isSelected) {
      ctx.fillStyle = 'rgba(216, 160, 255, 0.3)';
      ctx.fillRect(panelX + 8, y - 10, panelW - 16, 28);
    }
    
    // Trade info - bright white/yellow for readability
    ctx.fillStyle = canTrade ? '#ffffff' : '#aaaaaa';
    ctx.font = isSelected ? 'bold 11px system-ui' : '11px system-ui';
    ctx.fillText(`${trade.giveAmount}x ${trade.give} â†’ ${trade.receiveName}`, panelX + 16, y + 4);
    
    // Show current stock - bright green/red
    ctx.fillStyle = canTrade ? '#80ff80' : '#ff9090';
    ctx.font = '10px system-ui';
    ctx.fillText(`(Have: ${haveAmount})`, panelX + panelW - 80, y + 4);
  });
  
  // Instructions
  ctx.fillStyle = '#d8a0ff';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('â†‘â†“ Select | Enter/Tap to Trade | ESC to close', panelX + panelW/2, panelY + panelH - 12);
  ctx.textAlign = 'left';
}

// Open/Close Tailor Shop
function openTailorShop() {
  tailorShopOpen = true;
  tailorShopSelection = 0;
  taskProgress.visitedTailor = true;
  if (touchBackButton) touchBackButton.classList.add('visible');
}

function closeTailorShop() {
  tailorShopOpen = false;
  tailorShopSelection = 0;
  if (touchBackButton) touchBackButton.classList.remove('visible');
  showMessage("Theo: \"Quality work deserves quality pay. Return anytime!\"");
}

// Sell to tailor
function sellToTailor() {
  if (!tailorShopOpen) return;
  
  const item = tailorBuyPrices[tailorShopSelection];
  if (!item) return;
  
  const haveAmount = inventory[item.id] || 0;
  if (haveAmount < 1) {
    showMessage(`You don't have any ${item.name} to sell!`);
    return;
  }
  
  inventory[item.id]--;
  inventory.gold = (inventory.gold || 0) + item.price;
  showMessage(`Sold ${item.name} for ${item.price}g! Theo: "Excellent craftsmanship!"`);
  
  // Track for task board
  if (!taskProgress.soldToTailor) {
    taskProgress.soldToTailor = true;
  }
}

// Draw Tailor Shop UI
function drawTailorShopUI() {
  if (!tailorShopOpen) return;
  
  const panelW = 320;
  const panelH = 300;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Panel background
  ctx.fillStyle = 'rgba(92, 64, 51, 0.95)';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  
  // Border
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX + 1, panelY + 1, panelW - 2, panelH - 2);
  
  // Title
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText("âœ‚ï¸ Master Theo's Tailoring âœ‚ï¸", panelX + panelW/2, panelY + 20);
  
  // Gold display
  ctx.fillStyle = '#ffd700';
  ctx.font = '12px system-ui';
  ctx.fillText(`Your Gold: ${inventory.gold || 0}g`, panelX + panelW/2, panelY + 38);
  
  // Subtitle
  ctx.fillStyle = '#d4a574';
  ctx.font = '10px system-ui';
  ctx.fillText('Sell your crafted goods!', panelX + panelW/2, panelY + 52);
  ctx.textAlign = 'left';
  
  // Items list
  const startY = panelY + 68;
  tailorBuyPrices.forEach((item, i) => {
    const y = startY + i * 22;
    const isSelected = i === tailorShopSelection;
    const haveAmount = inventory[item.id] || 0;
    const canSell = haveAmount >= 1;
    
    // Selection highlight
    if (isSelected) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.fillRect(panelX + 8, y - 8, panelW - 16, 20);
    }
    
    // Item info
    ctx.fillStyle = canSell ? '#ffffff' : '#888888';
    ctx.font = '11px system-ui';
    ctx.fillText(`${item.name}`, panelX + 16, y + 4);
    
    // Price
    ctx.fillStyle = '#ffd700';
    ctx.fillText(`${item.price}g`, panelX + 160, y + 4);
    
    // Stock
    ctx.fillStyle = canSell ? '#90EE90' : '#666666';
    ctx.fillText(`(Have: ${haveAmount})`, panelX + 220, y + 4);
  });
  
  // Instructions
  ctx.fillStyle = '#d4a574';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('â†‘â†“ Select | Enter/Tap to Sell | ESC to close', panelX + panelW/2, panelY + panelH - 12);
  ctx.textAlign = 'left';
}

// ===== BARNABY'S FARM SHOP =====

// Farm Shop State
let farmShopOpen = false;
let farmShopSelection = 0;

// Build Mode State
let buildModeActive = false;
let selectedBuildItem = null; // 'fencing' or 'gate'
let buildCursorX = 0;
let buildCursorY = 0;

// Placed structures tracking (for pen detection later)
const placedStructures = [];

// Fast Travel System
let fastTravelOpen = false;
let fastTravelSelection = 0;
const FAST_TRAVEL_FEE = 5; // Gold cost per travel

// Signpost locations - these are where signposts exist on each map
const signpostLocations = {
  overworld: { x: 12, y: 8, name: 'Farm', unlocked: true }, // Start unlocked
  village: { x: 7, y: 10, name: 'Village', unlocked: false },
  forest: { x: 5, y: 8, name: 'Forest', unlocked: false },
  beach: { x: 12, y: 8, name: 'Beach', unlocked: false },
  mountain: { x: 10, y: 8, name: 'Mountain', unlocked: false },
  wetlands: { x: 9, y: 6, name: 'Marshes', unlocked: false }
};

// Get list of unlocked fast travel destinations (excluding current map)
function getAvailableFastTravelDestinations() {
  const destinations = [];
  for (const [mapId, data] of Object.entries(signpostLocations)) {
    if (data.unlocked && mapId !== currentMap) {
      destinations.push({ mapId, ...data });
    }
  }
  return destinations;
}

// Open fast travel menu
function openFastTravel() {
  const destinations = getAvailableFastTravelDestinations();
  if (destinations.length === 0) {
    showMessage("No other signposts discovered yet. Explore more!");
    return;
  }
  fastTravelOpen = true;
  fastTravelSelection = 0;
  if (touchBackButton) touchBackButton.classList.add('visible');
}

// Close fast travel menu
function closeFastTravel() {
  fastTravelOpen = false;
  fastTravelSelection = 0;
  if (touchBackButton) touchBackButton.classList.remove('visible');
}

// Execute fast travel to selected destination
function executeFastTravel() {
  const destinations = getAvailableFastTravelDestinations();
  if (destinations.length === 0) return;
  
  const destination = destinations[fastTravelSelection];
  if (!destination) return;
  
  // Check if festival discount applies (free fast travel)
  if (festivalFastTravelDiscount > 0) {
    festivalFastTravelDiscount--;
    
    // Close menu and travel
    closeFastTravel();
    
    // Transition to destination map
    currentMap = destination.mapId;
    mapData = maps[currentMap].data;
    
    // Position player near the signpost
    player.x = destination.x;
    player.y = destination.y + 1;
    player.px = player.x * TILE_SIZE;
    player.py = player.y * TILE_SIZE;
    player.targetX = player.x;
    player.targetY = player.y;
    player.isMoving = false;
    
    handleEnvironmentAudio(currentMap);
    invalidateBaseMaps();
    
    showMessage(`Arrived at ${destination.name}! (FREE - ${festivalFastTravelDiscount} trips left)`);
    return;
  }
  
  // Apply friendship discount from Mosswort
  const discountedFee = applyDiscount(FAST_TRAVEL_FEE, 'fastTravel');
  
  // Check if player has enough gold (or has a voucher - future feature)
  if ((inventory.gold || 0) < discountedFee) {
    showMessage(`Not enough gold! Fast travel costs ${discountedFee}g.`);
    return;
  }
  
  // Deduct fee
  inventory.gold -= discountedFee;
  
  // Close menu and travel
  closeFastTravel();
  
  // Transition to destination map
  currentMap = destination.mapId;
  mapData = maps[currentMap].data;
  
  // Position player near the signpost
  player.x = destination.x;
  player.y = destination.y + 1; // One tile below signpost
  player.px = player.x * TILE_SIZE;
  player.py = player.y * TILE_SIZE;
  player.targetX = player.x;
  player.targetY = player.y;
  player.isMoving = false;
  
  // Update audio for new map
  handleEnvironmentAudio(currentMap);
  invalidateBaseMaps();
  
  const savings = FAST_TRAVEL_FEE - discountedFee;
  const savingsMsg = savings > 0 ? ` (Saved ${savings}g!)` : '';
  showMessage(`Arrived at ${destination.name}! (-${discountedFee}g)${savingsMsg}`);
}

// Unlock a signpost when player interacts with it
function unlockSignpost(mapId) {
  if (signpostLocations[mapId] && !signpostLocations[mapId].unlocked) {
    signpostLocations[mapId].unlocked = true;
    showMessage(`Signpost discovered! You can now fast travel to ${signpostLocations[mapId].name}.`);
    return true;
  }
  return false;
}

// Check if player is adjacent to a signpost
function isNearSignpost() {
  const signpost = signpostLocations[currentMap];
  if (!signpost) return false;
  
  const dx = Math.abs(player.x - signpost.x);
  const dy = Math.abs(player.y - signpost.y);
  return (dx <= 1 && dy <= 1) && !(dx === 0 && dy === 0);
}

// Draw fast travel UI
function drawFastTravelUI() {
  if (!fastTravelOpen) return;
  
  const destinations = getAvailableFastTravelDestinations();
  
  // Semi-transparent background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Menu panel - increased height to fit instructions inside
  const panelWidth = 240;
  const panelHeight = 90 + destinations.length * 32;
  const panelX = (canvas.width - panelWidth) / 2;
  const panelY = (canvas.height - panelHeight) / 2;
  
  // Panel background
  ctx.fillStyle = '#5c4033';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 8);
  ctx.fill();
  ctx.strokeStyle = '#8b7355';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelWidth, panelHeight, 8);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#f5deb3';
  ctx.font = 'bold 16px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸš© Fast Travel', canvas.width / 2, panelY + 24);
  
  // Gold display
  ctx.font = '11px monospace';
  ctx.fillStyle = '#ffd700';
  ctx.fillText(`Cost: ${FAST_TRAVEL_FEE}g | Gold: ${inventory.gold || 0}g`, canvas.width / 2, panelY + 42);
  
  // Destination list
  ctx.textAlign = 'left';
  destinations.forEach((dest, i) => {
    const y = panelY + 62 + i * 32;
    
    // Selection highlight
    if (i === fastTravelSelection) {
      ctx.fillStyle = 'rgba(255, 255, 200, 0.25)';
      ctx.beginPath();
      ctx.roundRect(panelX + 8, y - 8, panelWidth - 16, 26, 4);
      ctx.fill();
      ctx.fillStyle = '#fffacd';
    } else {
      ctx.fillStyle = '#d2b48c';
    }
    
    ctx.font = '14px monospace';
    ctx.fillText(`â†’ ${dest.name}`, panelX + 18, y + 8);
  });
  
  // Instructions - now inside the panel
  ctx.fillStyle = '#a0a0a0';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('[W/S] Select  [E] Travel  [Esc] Back', canvas.width / 2, panelY + panelHeight - 12);
}

// =========================
// FESTIVAL OF THREADS MENU
// =========================

let festivalMenuOpen = false;
let festivalMenuSelection = 0;

function openFestivalMenu() {
  festivalMenuOpen = true;
  festivalMenuSelection = 0;
}

function closeFestivalMenu() {
  festivalMenuOpen = false;
  festivalMenuSelection = 0;
}

// Handle festival menu input
function handleFestivalMenuInput(key) {
  if (!festivalMenuOpen) return;
  
  if (key === 'Escape' || key === 'q') {
    closeFestivalMenu();
    return;
  }
  
  const step = festivalProgress.currentStep;
  
  // Menu options depend on current festival step
  if (step === 0) {
    // Not started - offer to start
    if (key === 'w') festivalMenuSelection = Math.max(0, festivalMenuSelection - 1);
    if (key === 's') festivalMenuSelection = Math.min(1, festivalMenuSelection + 1);
    if (key === 'e' || key === 'Enter') {
      if (festivalMenuSelection === 0) {
        // Start the festival
        startFestival();
        showMessage("ðŸŽª The Festival of Threads begins! Gather materials first.");
        closeFestivalMenu();
      } else {
        closeFestivalMenu();
      }
    }
  } else if (step === 1) {
    // Gathering phase - check progress
    if (key === 'e' || key === 'Enter') {
      if (checkGatheringComplete()) {
        advanceFestivalPhase();
        showMessage("âœ… Materials gathered! Time to decorate the village.");
      } else {
        showMessage("You still need more materials for the festival.");
      }
      closeFestivalMenu();
    }
  } else if (step === 2) {
    // Decorating phase - toggle decoration mode or check progress
    if (key === 'w') festivalMenuSelection = Math.max(0, festivalMenuSelection - 1);
    if (key === 's') festivalMenuSelection = Math.min(1, festivalMenuSelection + 1);
    if (key === 'e' || key === 'Enter') {
      if (festivalMenuSelection === 0) {
        // Place decoration
        placeNextDecoration();
        closeFestivalMenu();
      } else {
        // Check if can advance
        if (festivalProgress.decorationsPlaced >= FESTIVAL_REQUIREMENTS.decorations) {
          advanceFestivalPhase();
          showMessage("ðŸŽŠ Village is beautifully decorated! The ceremony can begin!");
        } else {
          showMessage(`Need ${FESTIVAL_REQUIREMENTS.decorations - festivalProgress.decorationsPlaced} more decorations.`);
        }
        closeFestivalMenu();
      }
    }
  } else if (step === 3) {
    // Ceremony ready - start ceremony
    if (key === 'e' || key === 'Enter') {
      completeFestival();
      closeFestivalMenu();
    }
  }
}

// Check if gathering requirements are met
function checkGatheringComplete() {
  const g = festivalProgress.materialsGathered;
  const r = FESTIVAL_REQUIREMENTS;
  return g.dyes >= r.dyes && g.feathers >= r.feathers && g.cloth >= r.cloth;
}

// Place a decoration in the village
function placeNextDecoration() {
  if (currentMap !== 'village') {
    showMessage("Decorations must be placed in the village!");
    return;
  }
  
  if (festivalProgress.decorationsPlaced >= FESTIVAL_REQUIREMENTS.decorations) {
    showMessage("All decorations are already placed!");
    return;
  }
  
  // Pre-defined decoration spots in village square
  const decorationSpots = [
    { x: 8, y: 5 }, { x: 10, y: 5 }, { x: 8, y: 7 }, { x: 10, y: 7 },
    { x: 7, y: 6 }, { x: 11, y: 6 }
  ];
  
  const spotIndex = festivalProgress.decorationsPlaced;
  if (spotIndex < decorationSpots.length) {
    festivalProgress.decorationsPlaced++;
    showMessage(`ðŸŽ€ Decoration placed! (${festivalProgress.decorationsPlaced}/${FESTIVAL_REQUIREMENTS.decorations})`);
  }
}

// Draw festival menu UI
function drawFestivalMenuUI() {
  if (!festivalMenuOpen) return;
  
  // Semi-transparent background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  
  // Panel dimensions
  const panelW = 260;
  const panelH = 200;
  const panelX = (CANVAS_WIDTH - panelW) / 2;
  const panelY = (CANVAS_HEIGHT - panelH) / 2;
  
  // Festive panel background
  ctx.fillStyle = '#4a3060';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 10);
  ctx.fill();
  
  // Gold border
  ctx.strokeStyle = '#ffd700';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 10);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸŽª Festival of Threads ðŸŽª', panelX + panelW/2, panelY + 24);
  
  const step = festivalProgress.currentStep;
  ctx.textAlign = 'left';
  ctx.font = '11px monospace';
  
  if (step === 0) {
    // Not started
    ctx.fillStyle = '#e0e0ff';
    ctx.fillText('Elder Mara greets you warmly.', panelX + 15, panelY + 50);
    ctx.fillText('"Would you help us prepare', panelX + 15, panelY + 68);
    ctx.fillText('the Festival of Threads?"', panelX + 15, panelY + 86);
    
    // Options
    const opts = ['Begin Festival', 'Maybe Later'];
    opts.forEach((opt, i) => {
      const y = panelY + 115 + i * 25;
      if (i === festivalMenuSelection) {
        ctx.fillStyle = '#ffd700';
        ctx.fillText('â†’ ' + opt, panelX + 30, y);
      } else {
        ctx.fillStyle = '#a0a0c0';
        ctx.fillText('  ' + opt, panelX + 30, y);
      }
    });
  } else if (step === 1) {
    // Gathering phase
    ctx.fillStyle = '#e0e0ff';
    ctx.fillText('Phase 1: Gather Materials', panelX + 15, panelY + 50);
    
    const g = festivalProgress.materialsGathered;
    const r = FESTIVAL_REQUIREMENTS;
    
    ctx.fillStyle = g.dyes >= r.dyes ? '#90ee90' : '#ffcccc';
    ctx.fillText(`Dyes: ${g.dyes}/${r.dyes}`, panelX + 25, panelY + 75);
    
    ctx.fillStyle = g.feathers >= r.feathers ? '#90ee90' : '#ffcccc';
    ctx.fillText(`Feathers: ${g.feathers}/${r.feathers}`, panelX + 25, panelY + 95);
    
    ctx.fillStyle = g.cloth >= r.cloth ? '#90ee90' : '#ffcccc';
    ctx.fillText(`Luxury Cloth: ${g.cloth}/${r.cloth}`, panelX + 25, panelY + 115);
    
    ctx.fillStyle = '#ffd700';
    ctx.fillText('â†’ Check Progress', panelX + 30, panelY + 145);
  } else if (step === 2) {
    // Decorating phase
    ctx.fillStyle = '#e0e0ff';
    ctx.fillText('Phase 2: Decorate Village', panelX + 15, panelY + 50);
    
    ctx.fillStyle = '#d0d0ff';
    ctx.fillText(`Decorations: ${festivalProgress.decorationsPlaced}/${FESTIVAL_REQUIREMENTS.decorations}`, panelX + 25, panelY + 75);
    
    const opts = ['Place Decoration', 'Check if Ready'];
    opts.forEach((opt, i) => {
      const y = panelY + 105 + i * 25;
      if (i === festivalMenuSelection) {
        ctx.fillStyle = '#ffd700';
        ctx.fillText('â†’ ' + opt, panelX + 30, y);
      } else {
        ctx.fillStyle = '#a0a0c0';
        ctx.fillText('  ' + opt, panelX + 30, y);
      }
    });
  } else if (step === 3) {
    // Ceremony ready
    ctx.fillStyle = '#90ee90';
    ctx.fillText('ðŸŽŠ All preparations complete!', panelX + 15, panelY + 50);
    ctx.fillStyle = '#e0e0ff';
    ctx.fillText('The village is ready for', panelX + 15, panelY + 75);
    ctx.fillText('the Festival Ceremony!', panelX + 15, panelY + 95);
    
    ctx.fillStyle = '#ffd700';
    ctx.fillText('â†’ Begin Ceremony', panelX + 30, panelY + 130);
  }
  
  // Instructions
  ctx.fillStyle = '#808090';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('[W/S] Select  [E] Confirm  [Esc] Close', panelX + panelW/2, panelY + panelH - 12);
}

// =========================
// LOOM ATTUNE MINI-GAME
// =========================

// Loom Attune State
let loomAttuneActive = false;
let loomAttunePhase = 'ready'; // 'ready', 'playing', 'result'
let loomAttuneCursor = 0; // Position of the moving cursor (0-100)
let loomAttuneCursorDir = 1; // 1 = moving right, -1 = moving left
let loomAttuneCursorSpeed = 2; // Speed of cursor movement
let loomAttuneTargetStart = 40; // Sweet spot start position
let loomAttuneTargetEnd = 60; // Sweet spot end position
let loomAttuneAttempts = 0; // Number of successful taps in current game
let loomAttuneRequired = 3; // Taps needed to win
let loomAttuneResult = ''; // 'success' or 'fail'
let loomAttuneResultTimer = 0;

// Loom Attune Buff - bonus crafts remaining
let loomAttuneBonusCrafts = 0;

// Loom spot in cottage (adjacent to spinning wheel area)
// Loom - separate from crafting table, near fireplace
const loomSpot = {
  map: 'cottage',
  x: 5,  // Top of room, opposite side from fireplace
  y: 1
};

// Check if player is near the loom
function isNearLoom() {
  if (currentMap !== loomSpot.map) return false;
  const dx = Math.abs(player.x - loomSpot.x);
  const dy = Math.abs(player.y - loomSpot.y);
  return dx + dy === 1;
}

// Check if player is near the crafting table
function isNearCraftingTable() {
  if (currentMap !== knittingSpot.map) return false;
  const dx = Math.abs(player.x - knittingSpot.x);
  const dy = Math.abs(player.y - knittingSpot.y);
  return dx + dy === 1;
}

// Start the loom attune mini-game
function startLoomAttune() {
  loomAttuneActive = true;
  loomAttunePhase = 'playing';
  loomAttuneCursor = 0;
  loomAttuneCursorDir = 1;
  loomAttuneAttempts = 0;
  loomAttuneResult = '';
  
  // Randomize target zone position
  randomizeLoomTarget();
  
  if (touchBackButton) touchBackButton.classList.add('visible');
  showMessage("Attune the Crystal Loom! Press E when the light is in the glow zone!");
}

// Randomize target zone (gets smaller/faster with each attempt)
function randomizeLoomTarget() {
  const difficulty = loomAttuneAttempts;
  const zoneSize = Math.max(12, 20 - difficulty * 2); // Zone shrinks each attempt
  loomAttuneTargetStart = 30 + Math.random() * (40 - zoneSize);
  loomAttuneTargetEnd = loomAttuneTargetStart + zoneSize;
  loomAttuneCursorSpeed = 1.5 + difficulty * 0.5; // Speed increases
}

// Close loom attune
function closeLoomAttune() {
  loomAttuneActive = false;
  loomAttunePhase = 'ready';
  if (touchBackButton) touchBackButton.classList.remove('visible');
}

// Handle input during loom attune
function handleLoomAttuneInput(action) {
  if (!loomAttuneActive) return;
  
  if (action === 'cancel') {
    closeLoomAttune();
    showMessage("Attunement cancelled.");
    return;
  }
  
  if (action === 'action' && loomAttunePhase === 'playing') {
    // Check if cursor is in the target zone
    if (loomAttuneCursor >= loomAttuneTargetStart && loomAttuneCursor <= loomAttuneTargetEnd) {
      // Success!
      loomAttuneAttempts++;
      if (sounds.knit) sounds.knit.play().catch(() => {});
      
      if (loomAttuneAttempts >= loomAttuneRequired) {
        // Won the mini-game!
        loomAttunePhase = 'result';
        loomAttuneResult = 'success';
        loomAttuneResultTimer = 120; // Show result for 2 seconds
        loomAttuneBonusCrafts = 3; // Award 3 bonus crafts
        showMessage("âœ¨ Perfect Attunement! Next 3 crafts will produce +1 bonus item!");
      } else {
        // Continue to next tap
        showMessage(`Good! ${loomAttuneRequired - loomAttuneAttempts} more to go!`);
        randomizeLoomTarget();
      }
    } else {
      // Missed!
      loomAttunePhase = 'result';
      loomAttuneResult = 'fail';
      loomAttuneResultTimer = 90;
      showMessage("The light slipped away... Try again next time!");
    }
  }
}

// Update loom attune game state
function updateLoomAttune() {
  if (!loomAttuneActive) return;
  
  if (loomAttunePhase === 'playing') {
    // Move cursor back and forth
    loomAttuneCursor += loomAttuneCursorDir * loomAttuneCursorSpeed;
    
    if (loomAttuneCursor >= 100) {
      loomAttuneCursor = 100;
      loomAttuneCursorDir = -1;
    } else if (loomAttuneCursor <= 0) {
      loomAttuneCursor = 0;
      loomAttuneCursorDir = 1;
    }
  }
  
  if (loomAttunePhase === 'result') {
    loomAttuneResultTimer--;
    if (loomAttuneResultTimer <= 0) {
      closeLoomAttune();
    }
  }
}

// Draw loom attune UI
function drawLoomAttuneUI() {
  if (!loomAttuneActive) return;
  
  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const panelW = 300;
  const panelH = 180;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Panel background - mystical purple
  ctx.fillStyle = 'rgba(60, 40, 80, 0.95)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 12);
  ctx.fill();
  
  // Border glow
  ctx.strokeStyle = '#a080c0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 12);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#e0d0f0';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('âœ¨ Crystal Loom Attunement âœ¨', panelX + panelW/2, panelY + 24);
  
  // Progress indicators
  ctx.fillStyle = '#c0b0d0';
  ctx.font = '11px system-ui';
  ctx.fillText(`Alignment: ${loomAttuneAttempts}/${loomAttuneRequired}`, panelX + panelW/2, panelY + 42);
  
  // Draw the timing bar
  const barX = panelX + 30;
  const barY = panelY + 60;
  const barW = panelW - 60;
  const barH = 28;
  
  // Bar background
  ctx.fillStyle = 'rgba(30, 20, 40, 0.8)';
  ctx.beginPath();
  ctx.roundRect(barX, barY, barW, barH, 6);
  ctx.fill();
  
  // Target zone (sweet spot) - glowing
  const targetX = barX + (loomAttuneTargetStart / 100) * barW;
  const targetW = ((loomAttuneTargetEnd - loomAttuneTargetStart) / 100) * barW;
  
  // Glow effect
  const glowGradient = ctx.createLinearGradient(targetX, barY, targetX + targetW, barY);
  glowGradient.addColorStop(0, 'rgba(150, 100, 255, 0.3)');
  glowGradient.addColorStop(0.5, 'rgba(180, 130, 255, 0.6)');
  glowGradient.addColorStop(1, 'rgba(150, 100, 255, 0.3)');
  ctx.fillStyle = glowGradient;
  ctx.fillRect(targetX, barY, targetW, barH);
  
  // Target zone border
  ctx.strokeStyle = '#b090e0';
  ctx.lineWidth = 2;
  ctx.strokeRect(targetX, barY, targetW, barH);
  
  // Moving cursor (light beam)
  const cursorX = barX + (loomAttuneCursor / 100) * barW;
  
  // Cursor glow
  const cursorGradient = ctx.createRadialGradient(cursorX, barY + barH/2, 0, cursorX, barY + barH/2, 20);
  cursorGradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
  cursorGradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
  ctx.fillStyle = cursorGradient;
  ctx.fillRect(cursorX - 20, barY - 5, 40, barH + 10);
  
  // Cursor line
  ctx.strokeStyle = '#ffffc0';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(cursorX, barY - 2);
  ctx.lineTo(cursorX, barY + barH + 2);
  ctx.stroke();
  
  // Result display
  if (loomAttunePhase === 'result') {
    ctx.font = 'bold 18px system-ui';
    if (loomAttuneResult === 'success') {
      ctx.fillStyle = '#90ff90';
      ctx.fillText('âœ¨ ATTUNED! âœ¨', panelX + panelW/2, panelY + 120);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#c0ffc0';
      ctx.fillText('+1 bonus item on next 3 crafts!', panelX + panelW/2, panelY + 140);
    } else {
      ctx.fillStyle = '#ff9090';
      ctx.fillText('Misaligned...', panelX + panelW/2, panelY + 120);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#ffc0c0';
      ctx.fillText('Try again later!', panelX + panelW/2, panelY + 140);
    }
  } else {
    // Instructions
    ctx.fillStyle = '#a090b0';
    ctx.font = '10px system-ui';
    ctx.fillText('Press [E] when the light enters the glow zone!', panelX + panelW/2, panelY + 115);
    ctx.font = '9px system-ui';
    ctx.fillText('[Esc] Cancel', panelX + panelW/2, panelY + 135);
  }
  
  // Show bonus indicator if active
  if (loomAttuneBonusCrafts > 0 && loomAttunePhase !== 'result') {
    ctx.fillStyle = '#ffd700';
    ctx.font = '9px system-ui';
    ctx.fillText(`Active Bonus: ${loomAttuneBonusCrafts} crafts remaining`, panelX + panelW/2, panelY + 165);
  }
}

// =========================
// KNITTING SPRINT MINI-GAME
// =========================

// Knitting Sprint State
let knittingSprintActive = false;
let knittingSprintPhase = 'ready'; // 'ready', 'countdown', 'playing', 'result'
let knittingSprintRecipe = null; // The recipe being crafted
let knittingSprintBeats = []; // Array of beat timings
let knittingSprintBeatIndex = 0; // Current beat to hit
let knittingSprintScore = 0; // How many beats hit successfully
let knittingSprintRequired = 5; // Beats needed for bonus
let knittingSprintTotalBeats = 6; // Total beats in the sprint
let knittingSprintTimer = 0; // Timer for beat spawning
let knittingSprintBeatSpeed = 2; // How fast beats move
let knittingSprintResult = '';
let knittingSprintResultTimer = 0;
let knittingSprintCountdown = 0;
let knittingSprintValueBonus = 0; // Accumulated value bonus from successful sprints

// Beat objects: { x, active, hit, missed }
let knittingSprintActiveBeat = null;

// Start Knitting Sprint mini-game
function startKnittingSprint(recipe) {
  knittingSprintActive = true;
  knittingSprintPhase = 'countdown';
  knittingSprintRecipe = recipe;
  knittingSprintBeatIndex = 0;
  knittingSprintScore = 0;
  knittingSprintResult = '';
  knittingSprintCountdown = 180; // 3 second countdown
  knittingSprintActiveBeat = null;
  knittingSprintTimer = 0;
  
  if (touchBackButton) touchBackButton.classList.add('visible');
  showMessage("Knitting Sprint! Tap [E] when the yarn reaches the needles!");
}

// Close Knitting Sprint
function closeKnittingSprint(cancelled = false) {
  knittingSprintActive = false;
  knittingSprintPhase = 'ready';
  if (touchBackButton) touchBackButton.classList.remove('visible');
  
  if (cancelled) {
    showMessage("Sprint cancelled - crafting normally.");
    // Still craft the item, just without bonus
    if (knittingSprintRecipe) {
      craftRecipeNormal(knittingSprintRecipe);
    }
  }
  knittingSprintRecipe = null;
}

// Handle input during Knitting Sprint
function handleKnittingSprintInput(action) {
  if (!knittingSprintActive) return;
  
  if (action === 'cancel') {
    closeKnittingSprint(true);
    return;
  }
  
  if (action === 'action' && knittingSprintPhase === 'playing') {
    // Check if there's an active beat in the hit zone
    if (knittingSprintActiveBeat && !knittingSprintActiveBeat.hit && !knittingSprintActiveBeat.missed) {
      const hitZoneStart = 75;
      const hitZoneEnd = 95;
      
      if (knittingSprintActiveBeat.x >= hitZoneStart && knittingSprintActiveBeat.x <= hitZoneEnd) {
        // Perfect hit!
        knittingSprintActiveBeat.hit = true;
        knittingSprintScore++;
        if (sounds.knit) sounds.knit.play().catch(() => {});
        showMessage(`Perfect! ${knittingSprintScore}/${knittingSprintRequired}`);
      } else if (knittingSprintActiveBeat.x >= hitZoneStart - 15 && knittingSprintActiveBeat.x <= hitZoneEnd + 5) {
        // Close enough - still counts
        knittingSprintActiveBeat.hit = true;
        knittingSprintScore++;
        showMessage(`Good! ${knittingSprintScore}/${knittingSprintRequired}`);
      } else {
        // Missed timing
        showMessage("Too early!");
      }
    }
  }
}

// Update Knitting Sprint game state
function updateKnittingSprint() {
  if (!knittingSprintActive) return;
  
  if (knittingSprintPhase === 'countdown') {
    knittingSprintCountdown--;
    if (knittingSprintCountdown <= 0) {
      knittingSprintPhase = 'playing';
      knittingSprintTimer = 0;
    }
    return;
  }
  
  if (knittingSprintPhase === 'playing') {
    knittingSprintTimer++;
    
    // Spawn new beat every ~60 frames (1 second)
    if (!knittingSprintActiveBeat && knittingSprintBeatIndex < knittingSprintTotalBeats) {
      if (knittingSprintTimer >= 60) {
        knittingSprintActiveBeat = { x: 0, hit: false, missed: false };
        knittingSprintBeatIndex++;
        knittingSprintTimer = 0;
      }
    }
    
    // Move active beat
    if (knittingSprintActiveBeat && !knittingSprintActiveBeat.hit) {
      knittingSprintActiveBeat.x += knittingSprintBeatSpeed;
      
      // Check if beat passed the hit zone
      if (knittingSprintActiveBeat.x > 100) {
        if (!knittingSprintActiveBeat.hit) {
          knittingSprintActiveBeat.missed = true;
          showMessage("Missed!");
        }
        // Clear beat and prepare for next
        knittingSprintActiveBeat = null;
        
        // Check if game is over
        if (knittingSprintBeatIndex >= knittingSprintTotalBeats) {
          knittingSprintPhase = 'result';
          knittingSprintResultTimer = 120;
          
          if (knittingSprintScore >= knittingSprintRequired) {
            knittingSprintResult = 'success';
            knittingSprintValueBonus++;
            showMessage("âš¡ Speed Bonus! Crafted item worth +1 gold!");
          } else {
            knittingSprintResult = 'fail';
            showMessage(`Finished ${knittingSprintScore}/${knittingSprintRequired} - crafting normally.`);
          }
        }
      }
    }
    
    // Clear hit beats after a moment
    if (knittingSprintActiveBeat && knittingSprintActiveBeat.hit) {
      knittingSprintActiveBeat.x += 5; // Fly off quickly
      if (knittingSprintActiveBeat.x > 110) {
        knittingSprintActiveBeat = null;
        
        // Check if game is over
        if (knittingSprintBeatIndex >= knittingSprintTotalBeats) {
          knittingSprintPhase = 'result';
          knittingSprintResultTimer = 120;
          
          if (knittingSprintScore >= knittingSprintRequired) {
            knittingSprintResult = 'success';
            knittingSprintValueBonus++;
            showMessage("âš¡ Speed Bonus! Crafted item worth +1 gold!");
          } else {
            knittingSprintResult = 'fail';
            showMessage(`Finished ${knittingSprintScore}/${knittingSprintRequired} - crafting normally.`);
          }
        }
      }
    }
  }
  
  if (knittingSprintPhase === 'result') {
    knittingSprintResultTimer--;
    if (knittingSprintResultTimer <= 0) {
      // Craft the item with or without bonus
      const wasSuccess = knittingSprintResult === 'success';
      craftRecipeWithBonus(knittingSprintRecipe, wasSuccess);
      closeKnittingSprint(false);
    }
  }
}

// Craft recipe normally (used when sprint is cancelled)
function craftRecipeNormal(recipe) {
  if (!canAffordRecipe(recipe)) return false;
  
  // Deduct inputs
  for (const [item, amount] of Object.entries(recipe.inputs)) {
    inventory[item] -= amount;
  }
  
  // Add outputs (with loom attune bonus if active)
  for (const [item, amount] of Object.entries(recipe.outputs)) {
    let finalAmount = amount;
    if (loomAttuneBonusCrafts > 0) {
      finalAmount += 1;
    }
    inventory[item] = (inventory[item] || 0) + finalAmount;
    
    // Track for festival
    trackFestivalMaterial(item, finalAmount);
  }
  
  // Consume loom attune bonus
  if (loomAttuneBonusCrafts > 0) {
    loomAttuneBonusCrafts--;
    if (loomAttuneBonusCrafts === 0) {
      showMessage("Loom attunement faded. Craft bonus ended.");
    }
  }
  
  onItemCrafted();
  return true;
}

// Craft recipe with potential sprint bonus
function craftRecipeWithBonus(recipe, hasSprintBonus) {
  if (!canAffordRecipe(recipe)) return false;
  
  // Deduct inputs
  for (const [item, amount] of Object.entries(recipe.inputs)) {
    inventory[item] -= amount;
  }
  
  // Add outputs (with loom attune bonus if active)
  for (const [item, amount] of Object.entries(recipe.outputs)) {
    let finalAmount = amount;
    if (loomAttuneBonusCrafts > 0) {
      finalAmount += 1;
    }
    inventory[item] = (inventory[item] || 0) + finalAmount;
    
    // Track for festival
    trackFestivalMaterial(item, finalAmount);
    
    // Track sprint bonus for this item type
    if (hasSprintBonus && recipe.sellPrice) {
      // Store sprint bonus in a special tracker
      if (!sprintBonusItems[item]) sprintBonusItems[item] = 0;
      sprintBonusItems[item] += finalAmount;
    }
  }
  
  // Consume loom attune bonus
  if (loomAttuneBonusCrafts > 0) {
    loomAttuneBonusCrafts--;
    if (loomAttuneBonusCrafts === 0) {
      showMessage("Loom attunement faded.");
    }
  }
  
  onItemCrafted();
  return true;
}

// Track items with sprint bonus (they sell for +1 gold each)
let sprintBonusItems = {};

// Draw Knitting Sprint UI
function drawKnittingSprintUI() {
  if (!knittingSprintActive) return;
  
  // Darken background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Panel
  const panelW = 280;
  const panelH = 180;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Panel background
  ctx.fillStyle = 'rgba(60, 40, 30, 0.95)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 12);
  ctx.fill();
  
  // Panel border
  ctx.strokeStyle = '#d4a574';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 12);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#f0d0a0';
  ctx.font = 'bold 16px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸ§¶ Knitting Sprint! ðŸ§¶', panelX + panelW/2, panelY + 28);
  
  // Progress
  ctx.fillStyle = '#d0c0a0';
  ctx.font = '11px system-ui';
  ctx.fillText(`Hits: ${knittingSprintScore}/${knittingSprintRequired}`, panelX + panelW/2, panelY + 48);
  
  // Countdown phase
  if (knittingSprintPhase === 'countdown') {
    const countNum = Math.ceil(knittingSprintCountdown / 60);
    ctx.fillStyle = '#ffd700';
    ctx.font = 'bold 48px system-ui';
    ctx.fillText(countNum.toString(), panelX + panelW/2, panelY + 110);
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#c0b090';
    ctx.fillText('Get ready...', panelX + panelW/2, panelY + 140);
    return;
  }
  
  // Draw the timing bar
  const barX = panelX + 20;
  const barY = panelY + 65;
  const barW = panelW - 40;
  const barH = 35;
  
  // Bar background (knitting needles track)
  ctx.fillStyle = 'rgba(40, 30, 20, 0.9)';
  ctx.beginPath();
  ctx.roundRect(barX, barY, barW, barH, 8);
  ctx.fill();
  
  // Hit zone (the needles)
  const hitZoneStart = 75;
  const hitZoneEnd = 95;
  const hitX = barX + (hitZoneStart / 100) * barW;
  const hitW = ((hitZoneEnd - hitZoneStart) / 100) * barW;
  
  // Hit zone glow
  ctx.fillStyle = `rgba(255, 200, 100, ${0.4 + 0.2 * Math.sin(Date.now() / 200)})`;
  ctx.fillRect(hitX - 5, barY - 5, hitW + 10, barH + 10);
  
  // Hit zone
  ctx.fillStyle = '#ffa040';
  ctx.fillRect(hitX, barY, hitW, barH);
  
  // Needles icon
  ctx.fillStyle = '#c0c0c0';
  ctx.font = '20px system-ui';
  ctx.fillText('ðŸª¡', hitX + hitW/2, barY + barH/2 + 7);
  
  // Draw active beat (yarn ball)
  if (knittingSprintActiveBeat && knittingSprintPhase === 'playing') {
    const beatX = barX + (knittingSprintActiveBeat.x / 100) * barW;
    const beatY = barY + barH/2;
    
    if (knittingSprintActiveBeat.hit) {
      // Hit effect - sparkle
      ctx.fillStyle = '#ffff00';
      ctx.font = '18px system-ui';
      ctx.fillText('âœ¨', beatX, beatY + 6);
    } else {
      // Yarn ball
      ctx.fillStyle = '#ff8090';
      ctx.beginPath();
      ctx.arc(beatX, beatY, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // Yarn texture
      ctx.strokeStyle = '#ff6070';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(beatX, beatY, 8, 0, Math.PI * 1.5);
      ctx.stroke();
      
      // Highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(beatX - 3, beatY - 3, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Result display
  if (knittingSprintPhase === 'result') {
    ctx.font = 'bold 18px system-ui';
    if (knittingSprintResult === 'success') {
      ctx.fillStyle = '#90ff90';
      ctx.fillText('âš¡ SPEED BONUS! âš¡', panelX + panelW/2, panelY + 130);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#c0ffc0';
      ctx.fillText('Item sells for +1 gold!', panelX + panelW/2, panelY + 150);
    } else {
      ctx.fillStyle = '#ffa0a0';
      ctx.fillText('Nice try!', panelX + panelW/2, panelY + 130);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#e0d0c0';
      ctx.fillText('Crafted normally.', panelX + panelW/2, panelY + 150);
    }
  } else {
    // Instructions
    ctx.fillStyle = '#b0a090';
    ctx.font = '10px system-ui';
    ctx.fillText('Press [E] when yarn reaches the needles!', panelX + panelW/2, panelY + 125);
    ctx.font = '9px system-ui';
    ctx.fillText('[Esc] Skip (craft normally)', panelX + panelW/2, panelY + 145);
    
    // Beat counter
    ctx.fillStyle = '#908070';
    ctx.fillText(`Beat ${knittingSprintBeatIndex}/${knittingSprintTotalBeats}`, panelX + panelW/2, panelY + 165);
  }
}

// =========================
// ORDERS BOARD SYSTEM
// =========================

// Orders Board State
let ordersBoardOpen = false;
let ordersBoardSelection = 0;
let ordersBoardTab = 'daily'; // 'daily' or 'weekly'

// Time tracking for order refresh
let lastDailyRefresh = 0;
let lastWeeklyRefresh = 0;
const DAY_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
const WEEK_MS = 7 * DAY_MS;

// Current active orders
let dailyOrders = [];
let weeklyOrder = null;

// Order templates - what items can be requested
const orderTemplates = {
  // Basic materials
  wool: { name: 'Wool', icon: 'ðŸ§¶', baseReward: 15, friendship: 5 },
  goatFur: { name: 'Goat Fur', icon: 'ðŸ¦™', baseReward: 20, friendship: 5 },
  yarn: { name: 'Yarn', icon: 'ðŸ§µ', baseReward: 25, friendship: 8 },
  softFur: { name: 'Soft Fur', icon: 'ðŸ°', baseReward: 18, friendship: 5 },
  feather: { name: 'Feather', icon: 'ðŸª¶', baseReward: 30, friendship: 10 },
  // Crafted items
  socks: { name: 'Socks', icon: 'ðŸ§¦', baseReward: 40, friendship: 12 },
  scarf: { name: 'Scarf', icon: 'ðŸ§£', baseReward: 50, friendship: 15 },
  hat: { name: 'Hat', icon: 'ðŸŽ©', baseReward: 55, friendship: 15 },
  mittens: { name: 'Mittens', icon: 'ðŸ§¤', baseReward: 45, friendship: 12 },
  sweater: { name: 'Sweater', icon: 'ðŸ‘•', baseReward: 80, friendship: 20 },
  // Dyed items
  dyedYarn: { name: 'Dyed Yarn', icon: 'ðŸŽ¨', baseReward: 35, friendship: 10 },
  amberDye: { name: 'Amber Dye', icon: 'ðŸŸ ', baseReward: 25, friendship: 8 },
  tealDye: { name: 'Teal Dye', icon: 'ðŸ”µ', baseReward: 25, friendship: 8 },
  // Foraged
  berries: { name: 'Berries', icon: 'ðŸ«', baseReward: 12, friendship: 4 },
  herbs: { name: 'Herbs', icon: 'ðŸŒ¿', baseReward: 12, friendship: 4 },
  shells: { name: 'Shells', icon: 'ðŸš', baseReward: 15, friendship: 5 },
  flowers: { name: 'Flowers', icon: 'ðŸŒ¸', baseReward: 10, friendship: 3 }
};

// NPCs who can give orders
const orderGivers = ['granny', 'felix', 'theo', 'iris', 'mosswort'];

// Generate a random order
function generateOrder(isWeekly = false) {
  const itemKeys = Object.keys(orderTemplates);
  const itemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
  const template = orderTemplates[itemKey];
  const giverIndex = Math.floor(Math.random() * orderGivers.length);
  const giver = orderGivers[giverIndex];
  
  // Daily: 1-3 items, Weekly: 3-6 items
  const minQty = isWeekly ? 3 : 1;
  const maxQty = isWeekly ? 6 : 3;
  const quantity = minQty + Math.floor(Math.random() * (maxQty - minQty + 1));
  
  // Weekly orders give 2.5x rewards
  const multiplier = isWeekly ? 2.5 : 1;
  
  return {
    id: Date.now() + Math.random(),
    itemKey: itemKey,
    itemName: template.name,
    icon: template.icon,
    quantity: quantity,
    goldReward: Math.floor(template.baseReward * quantity * multiplier),
    friendshipReward: Math.floor(template.friendship * multiplier),
    giver: giver,
    isWeekly: isWeekly,
    completed: false
  };
}

// Refresh daily orders (called when needed)
function refreshDailyOrders() {
  const now = Date.now();
  // Check if a day has passed since last refresh
  if (now - lastDailyRefresh >= DAY_MS || dailyOrders.length === 0) {
    dailyOrders = [generateOrder(false), generateOrder(false)];
    lastDailyRefresh = now;
  }
}

// Refresh weekly order (called when needed)
function refreshWeeklyOrder() {
  const now = Date.now();
  // Check if a week has passed since last refresh
  if (now - lastWeeklyRefresh >= WEEK_MS || !weeklyOrder) {
    weeklyOrder = generateOrder(true);
    lastWeeklyRefresh = now;
  }
}

// Check and refresh orders on game start/load
function checkAndRefreshOrders() {
  refreshDailyOrders();
  refreshWeeklyOrder();
}

// Get time remaining for order refresh
function getTimeUntilRefresh(lastRefresh, interval) {
  const now = Date.now();
  const elapsed = now - lastRefresh;
  const remaining = interval - elapsed;
  if (remaining <= 0) return 'Ready!';
  
  const hours = Math.floor(remaining / (60 * 60 * 1000));
  const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
  
  if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}

// Open the orders board
function openOrdersBoard() {
  checkAndRefreshOrders();
  ordersBoardOpen = true;
  ordersBoardSelection = 0;
  ordersBoardTab = 'daily';
  if (touchBackButton) touchBackButton.classList.add('visible');
}

// Close the orders board
function closeOrdersBoard() {
  ordersBoardOpen = false;
  if (touchBackButton) touchBackButton.classList.remove('visible');
}

// Get display name for NPC
function getOrderGiverName(giverId) {
  const names = {
    granny: 'Granny Maple',
    felix: 'Felix',
    theo: 'Theo',
    iris: 'Iris',
    mosswort: 'Old Mosswort'
  };
  return names[giverId] || giverId;
}

// Complete an order if player has the items
function completeOrder(order) {
  if (!order || order.completed) return false;
  
  // Check if player has enough of the item
  const currentAmount = inventory[order.itemKey] || 0;
  if (currentAmount < order.quantity) {
    showMessage(`Need ${order.quantity - currentAmount} more ${order.itemName}!`);
    return false;
  }
  
  // Deduct items and give rewards
  inventory[order.itemKey] -= order.quantity;
  inventory.gold = (inventory.gold || 0) + order.goldReward;
  
  // Add friendship with the order giver
  if (friendship[order.giver] !== undefined) {
    friendship[order.giver] = Math.min(100, friendship[order.giver] + order.friendshipReward);
    checkFriendshipPerks(order.giver);
  }
  
  order.completed = true;
  showMessage(`Order complete! +${order.goldReward}g, +${order.friendshipReward} friendship with ${getOrderGiverName(order.giver)}!`);
  return true;
}

// Try to complete selected order
function tryCompleteSelectedOrder() {
  if (ordersBoardTab === 'daily') {
    const order = dailyOrders[ordersBoardSelection];
    if (order) completeOrder(order);
  } else {
    if (weeklyOrder) completeOrder(weeklyOrder);
  }
}

// Draw orders board UI
function drawOrdersBoardUI() {
  if (!ordersBoardOpen) return;
  
  // Semi-transparent background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  
  // Main panel
  const panelWidth = 280;
  const panelHeight = 220;
  const panelX = (CANVAS_WIDTH - panelWidth) / 2;
  const panelY = (CANVAS_HEIGHT - panelHeight) / 2;
  
  // Panel background (cork board style)
  ctx.fillStyle = '#8b6914';
  ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
  ctx.strokeStyle = '#5c4033';
  ctx.lineWidth = 4;
  ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
  
  // Inner cork texture
  ctx.fillStyle = '#a67c00';
  ctx.fillRect(panelX + 8, panelY + 8, panelWidth - 16, panelHeight - 16);
  
  // Title
  ctx.fillStyle = '#fff8dc';
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸ“‹ Orders Board', CANVAS_WIDTH / 2, panelY + 28);
  
  // Tab buttons
  const tabY = panelY + 40;
  const tabWidth = 80;
  
  // Daily tab
  ctx.fillStyle = ordersBoardTab === 'daily' ? '#f5deb3' : '#c4a060';
  ctx.fillRect(panelX + 30, tabY, tabWidth, 22);
  ctx.fillStyle = ordersBoardTab === 'daily' ? '#5c4033' : '#8b7355';
  ctx.font = '11px monospace';
  ctx.fillText('Daily', panelX + 70, tabY + 15);
  
  // Weekly tab
  ctx.fillStyle = ordersBoardTab === 'weekly' ? '#f5deb3' : '#c4a060';
  ctx.fillRect(panelX + 170, tabY, tabWidth, 22);
  ctx.fillStyle = ordersBoardTab === 'weekly' ? '#5c4033' : '#8b7355';
  ctx.fillText('Weekly', panelX + 210, tabY + 15);
  
  // Time until refresh
  ctx.font = '9px monospace';
  ctx.fillStyle = '#d2b48c';
  if (ordersBoardTab === 'daily') {
    ctx.fillText(`Refresh: ${getTimeUntilRefresh(lastDailyRefresh, DAY_MS)}`, CANVAS_WIDTH / 2, tabY + 35);
  } else {
    ctx.fillText(`Refresh: ${getTimeUntilRefresh(lastWeeklyRefresh, WEEK_MS)}`, CANVAS_WIDTH / 2, tabY + 35);
  }
  
  // Draw orders
  const ordersStartY = tabY + 50;
  ctx.textAlign = 'left';
  
  if (ordersBoardTab === 'daily') {
    dailyOrders.forEach((order, i) => {
      drawOrderCard(order, panelX + 15, ordersStartY + i * 55, panelWidth - 30, i === ordersBoardSelection);
    });
  } else {
    if (weeklyOrder) {
      drawOrderCard(weeklyOrder, panelX + 15, ordersStartY, panelWidth - 30, true);
    }
  }
  
  // Instructions
  ctx.fillStyle = '#d2b48c';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('[A/D] Tab  [W/S] Select  [E] Complete  [Esc] Close', CANVAS_WIDTH / 2, panelY + panelHeight - 12);
}

// Draw a single order card
function drawOrderCard(order, x, y, width, selected) {
  // Card background
  ctx.fillStyle = selected ? '#fffacd' : '#f5deb3';
  if (order.completed) ctx.fillStyle = '#90ee90';
  ctx.fillRect(x, y, width, 48);
  ctx.strokeStyle = selected ? '#8b4513' : '#a0522d';
  ctx.lineWidth = selected ? 2 : 1;
  ctx.strokeRect(x, y, width, 48);
  
  // Pin decoration
  ctx.fillStyle = '#dc143c';
  ctx.beginPath();
  ctx.arc(x + width - 12, y + 8, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Item icon and name
  ctx.fillStyle = '#5c4033';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(`${order.icon} ${order.itemName} x${order.quantity}`, x + 8, y + 18);
  
  // From who
  ctx.font = '9px monospace';
  ctx.fillStyle = '#8b7355';
  ctx.fillText(`From: ${getOrderGiverName(order.giver)}`, x + 8, y + 32);
  
  // Rewards
  ctx.fillStyle = '#228b22';
  ctx.fillText(`ðŸ’°${order.goldReward}g  â¤ï¸+${order.friendshipReward}`, x + 8, y + 44);
  
  // Status
  ctx.textAlign = 'right';
  if (order.completed) {
    ctx.fillStyle = '#228b22';
    ctx.font = 'bold 10px monospace';
    ctx.fillText('âœ“ DONE', x + width - 8, y + 44);
  } else {
    const have = inventory[order.itemKey] || 0;
    ctx.fillStyle = have >= order.quantity ? '#228b22' : '#dc143c';
    ctx.font = '10px monospace';
    ctx.fillText(`Have: ${have}/${order.quantity}`, x + width - 8, y + 44);
  }
}

// Orders board location in village (the existing task board area)
const ordersBoardLocation = { map: 'village', x: 9, y: 4 };

// Check if player is near orders board
function isNearOrdersBoard() {
  if (currentMap !== ordersBoardLocation.map) return false;
  const dx = Math.abs(player.x - ordersBoardLocation.x);
  const dy = Math.abs(player.y - ordersBoardLocation.y);
  return dx + dy <= 1;
}

// Farm shop items
const farmShopItems = [
  // Building materials
  { id: 'fencing', name: 'Fencing', price: 10, category: 'building', description: 'Sturdy wooden fence post' },
  { id: 'gate', name: 'Gate', price: 25, category: 'building', description: 'Walk-through fence gate' },
  // Animals
  { id: 'sheep', name: 'Extra Sheep', price: 50, category: 'animal', description: 'A fluffy wool-producing sheep' },
  { id: 'llama', name: 'Llama', price: 100, category: 'animal', description: 'Produces fine luxury wool' },
  { id: 'rabbit', name: 'Rabbit', price: 40, category: 'animal', description: 'Quick soft fur producer' },
  { id: 'extraGoat', name: 'Extra Goat', price: 75, category: 'animal', description: 'Another goat for more fur' }
];

// Dynamic animals array for purchased animals
const purchasedAnimals = [];

// Open/Close Farm Shop
function openFarmShop() {
  farmShopOpen = true;
  farmShopSelection = 0;
  if (touchBackButton) touchBackButton.classList.add('visible');
}

function closeFarmShop() {
  farmShopOpen = false;
  farmShopSelection = 0;
  if (touchBackButton) touchBackButton.classList.remove('visible');
  showMessage("Barnaby: \"Come back when ye need more supplies!\"");
}

// Buy from farm shop
function buyFromFarmShop() {
  if (!farmShopOpen) return;
  
  const item = farmShopItems[farmShopSelection];
  if (!item) return;
  
  // Apply friendship discount
  const discountedPrice = applyDiscount(item.price, 'farm');
  
  if ((inventory.gold || 0) < discountedPrice) {
    showMessage(`Not enough gold! You need ${discountedPrice}g.`);
    return;
  }
  
  if (item.category === 'building') {
    // Buy building material - add to inventory
    inventory.gold -= discountedPrice;
    inventory[item.id] = (inventory[item.id] || 0) + 1;
    const savings = item.price - discountedPrice;
    const savingsMsg = savings > 0 ? ` (Saved ${savings}g!)` : '';
    showMessage(`Purchased ${item.name}!${savingsMsg} Barnaby: "Fine choice! Press B to build."`);
  } else if (item.category === 'animal') {
    // Buy animal - spawn new animal
    inventory.gold -= discountedPrice;
    spawnPurchasedAnimal(item.id);
    const savings = item.price - discountedPrice;
    const savingsMsg = savings > 0 ? ` (Saved ${savings}g!)` : '';
    showMessage(`Purchased ${item.name}!${savingsMsg} Barnaby: "Treat 'em well now!"`);
  }
}

// Spawn a purchased animal
function spawnPurchasedAnimal(animalType) {
  // Find a valid spawn location near existing animals
  const baseX = 12 + Math.floor(Math.random() * 4);
  const baseY = 6 + Math.floor(Math.random() * 3);
  
  const newAnimal = {
    type: animalType,
    map: 'overworld',
    x: baseX,
    y: baseY,
    homeX: baseX,
    homeY: baseY,
    wanderRadius: 3,
    moveTimer: 0,
    moveDelay: 150 + Math.floor(Math.random() * 100),
    isMoving: false,
    targetX: baseX,
    targetY: baseY,
    px: baseX * TILE_SIZE,
    py: baseY * TILE_SIZE,
    moveProgress: 0,
    facing: 'down',
    // Animal-specific properties
    hasResource: true,
    resourceTimer: 0
  };
  
  // Set resource properties based on type
  if (animalType === 'sheep') {
    newAnimal.resourceType = 'wool';
    newAnimal.resourceAmount = 1;
    newAnimal.regrowTime = 600;
  } else if (animalType === 'llama') {
    newAnimal.resourceType = 'luxuryWool';
    newAnimal.resourceAmount = 1;
    newAnimal.regrowTime = 900; // Takes longer but better wool
  } else if (animalType === 'rabbit') {
    newAnimal.resourceType = 'softFur';
    newAnimal.resourceAmount = 1;
    newAnimal.regrowTime = 400; // Faster cycle
  } else if (animalType === 'extraGoat') {
    newAnimal.resourceType = 'goatFur';
    newAnimal.resourceAmount = 1;
    newAnimal.regrowTime = 600;
  }
  
  purchasedAnimals.push(newAnimal);
}

// Toggle Build Mode
function toggleBuildMode() {
  if (buildModeActive) {
    exitBuildMode();
  } else {
    enterBuildMode();
  }
}

function enterBuildMode() {
  // Check if player has any building materials
  if ((inventory.fencing || 0) === 0 && (inventory.gate || 0) === 0) {
    showMessage("You don't have any building materials! Visit Barnaby's Farm Shop.");
    return;
  }
  
  buildModeActive = true;
  buildCursorX = player.x;
  buildCursorY = player.y;
  
  // Default to fencing if available, else gate
  if ((inventory.fencing || 0) > 0) {
    selectedBuildItem = 'fencing';
  } else {
    selectedBuildItem = 'gate';
  }
  
  showMessage("Build Mode: WASD to move cursor, E to place, Q to switch item, ESC to exit");
}

function exitBuildMode() {
  buildModeActive = false;
  selectedBuildItem = null;
  showMessage("Exited Build Mode");
}

function switchBuildItem() {
  if (!buildModeActive) return;
  
  if (selectedBuildItem === 'fencing' && (inventory.gate || 0) > 0) {
    selectedBuildItem = 'gate';
    showMessage(`Selected: Gate (${inventory.gate} available)`);
  } else if (selectedBuildItem === 'gate' && (inventory.fencing || 0) > 0) {
    selectedBuildItem = 'fencing';
    showMessage(`Selected: Fencing (${inventory.fencing} available)`);
  } else {
    showMessage("No other building materials available!");
  }
}

function moveBuildCursor(dx, dy) {
  if (!buildModeActive) return;
  
  const newX = buildCursorX + dx;
  const newY = buildCursorY + dy;
  
  // Keep within map bounds
  if (newX >= 0 && newX < MAP_COLS && newY >= 0 && newY < MAP_ROWS) {
    buildCursorX = newX;
    buildCursorY = newY;
  }
}

function placeBuildItem() {
  if (!buildModeActive || !selectedBuildItem) return;
  
  // Check if we have the item
  if ((inventory[selectedBuildItem] || 0) <= 0) {
    showMessage(`No ${selectedBuildItem} left!`);
    return;
  }
  
  // Check if tile is valid for building
  const tile = mapData[buildCursorY][buildCursorX];
  
  // Can only build on grass (0) or path (1)
  if (tile !== 0 && tile !== 1) {
    showMessage("Can't build here! Choose an open grass or path tile.");
    return;
  }
  
  // Check if player is standing there
  if (buildCursorX === player.x && buildCursorY === player.y) {
    showMessage("Can't build where you're standing!");
    return;
  }
  
  // Check if any animal is there
  if (isAnimalAt(buildCursorX, buildCursorY)) {
    showMessage("Can't build on an animal!");
    return;
  }
  
  // Place the structure
  inventory[selectedBuildItem]--;
  
  if (selectedBuildItem === 'fencing') {
    // Fencing becomes solid (tile 4)
    mapData[buildCursorY][buildCursorX] = 4;
    showMessage("Fence placed!");
  } else if (selectedBuildItem === 'gate') {
    // Gate becomes a special walkable tile (we'll use tile 28)
    mapData[buildCursorY][buildCursorX] = 28;
    showMessage("Gate placed!");
  }
  
  // Track placed structure
  placedStructures.push({
    type: selectedBuildItem,
    x: buildCursorX,
    y: buildCursorY,
    map: currentMap
  });
  
  // Invalidate map cache to redraw
  invalidateBaseMaps();
  
  // Check if we ran out
  if ((inventory[selectedBuildItem] || 0) <= 0) {
    // Try to switch to other item
    if (selectedBuildItem === 'fencing' && (inventory.gate || 0) > 0) {
      selectedBuildItem = 'gate';
      showMessage(`Switched to Gate (${inventory.gate} available)`);
    } else if (selectedBuildItem === 'gate' && (inventory.fencing || 0) > 0) {
      selectedBuildItem = 'fencing';
      showMessage(`Switched to Fencing (${inventory.fencing} available)`);
    } else {
      exitBuildMode();
      showMessage("Out of building materials!");
    }
  }
}

// Check if any animal is at position
function isAnimalAt(x, y) {
  if (sheep.map === currentMap && sheep.x === x && sheep.y === y) return true;
  if (sheep2.map === currentMap && sheep2.x === x && sheep2.y === y) return true;
  if (goat.map === currentMap && goat.x === x && goat.y === y) return true;
  if (peacock.map === currentMap && peacock.x === x && peacock.y === y) return true;
  
  // Check purchased animals
  for (const animal of purchasedAnimals) {
    if (animal.map === currentMap && animal.x === x && animal.y === y) return true;
  }
  
  return false;
}

// Draw Farm Shop UI
function drawFarmShopUI() {
  if (!farmShopOpen) return;
  
  const panelW = 340;
  const panelH = 280;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Panel background - rustic brown
  ctx.fillStyle = 'rgba(90, 65, 40, 0.98)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 8);
  ctx.fill();
  
  // Border
  ctx.strokeStyle = '#c9a066';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 8);
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#ffeedd';
  ctx.font = 'bold 16px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText("ðŸ  Barnaby's Farm Shop ðŸ‘", panelX + panelW/2, panelY + 24);
  
  // Gold display
  ctx.fillStyle = '#ffd700';
  ctx.font = '12px system-ui';
  ctx.fillText(`Your Gold: ${inventory.gold || 0}g`, panelX + panelW/2, panelY + 42);
  
  // Section headers
  ctx.fillStyle = '#c9a066';
  ctx.font = 'bold 10px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('â€” BUILDING SUPPLIES â€”', panelX + 16, panelY + 60);
  
  // Items list
  const startY = panelY + 75;
  let itemY = startY;
  let lastCategory = '';
  
  farmShopItems.forEach((item, i) => {
    // Add category header for animals
    if (item.category === 'animal' && lastCategory !== 'animal') {
      itemY += 8;
      ctx.fillStyle = '#c9a066';
      ctx.font = 'bold 10px system-ui';
      ctx.fillText('â€” ANIMALS â€”', panelX + 16, itemY);
      itemY += 16;
    }
    lastCategory = item.category;
    
    const isSelected = i === farmShopSelection;
    const canAfford = (inventory.gold || 0) >= item.price;
    
    // Selection highlight
    if (isSelected) {
      ctx.fillStyle = 'rgba(255, 220, 150, 0.25)';
      ctx.beginPath();
      ctx.roundRect(panelX + 8, itemY - 10, panelW - 16, 24, 4);
      ctx.fill();
    }
    
    // Item icon
    let icon = 'ðŸ“¦';
    if (item.id === 'fencing') icon = 'ðŸªµ';
    else if (item.id === 'gate') icon = 'ðŸšª';
    else if (item.id === 'sheep') icon = 'ðŸ‘';
    else if (item.id === 'llama') icon = 'ðŸ¦™';
    else if (item.id === 'rabbit') icon = 'ðŸ°';
    else if (item.id === 'extraGoat') icon = 'ðŸ';
    
    ctx.font = '14px system-ui';
    ctx.fillText(icon, panelX + 16, itemY + 4);
    
    // Item name
    ctx.fillStyle = canAfford ? '#ffeedd' : '#888888';
    ctx.font = isSelected ? 'bold 12px system-ui' : '12px system-ui';
    ctx.fillText(item.name, panelX + 38, itemY + 2);
    
    // Price
    ctx.fillStyle = canAfford ? '#ffd700' : '#aa6600';
    ctx.textAlign = 'right';
    ctx.fillText(`${item.price}g`, panelX + panelW - 16, itemY + 2);
    ctx.textAlign = 'left';
    
    // Show inventory count for building materials
    if (item.category === 'building') {
      const owned = inventory[item.id] || 0;
      if (owned > 0) {
        ctx.fillStyle = '#90EE90';
        ctx.font = '10px system-ui';
        ctx.fillText(`(Own: ${owned})`, panelX + 140, itemY + 2);
      }
    }
    
    itemY += 26;
  });
  
  // Selected item description
  const selectedItem = farmShopItems[farmShopSelection];
  if (selectedItem) {
    ctx.fillStyle = '#c9a066';
    ctx.font = 'italic 10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(selectedItem.description, panelX + panelW/2, panelY + panelH - 35);
  }
  
  // Instructions
  ctx.fillStyle = '#c9a066';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('â†‘â†“ Select | E to Buy | ESC to close', panelX + panelW/2, panelY + panelH - 12);
  ctx.textAlign = 'left';
}

// Draw Build Mode UI
function drawBuildModeUI() {
  if (!buildModeActive) return;
  
  // Draw cursor at build position
  const cursorX = buildCursorX * TILE_SIZE;
  const cursorY = buildCursorY * TILE_SIZE;
  
  // Check if can build here
  const tile = mapData[buildCursorY][buildCursorX];
  const canBuild = (tile === 0 || tile === 1) && 
                   !(buildCursorX === player.x && buildCursorY === player.y) &&
                   !isAnimalAt(buildCursorX, buildCursorY);
  
  // Pulsing effect
  const pulse = 0.5 + 0.3 * Math.sin(animationTime * 4);
  
  // Draw cursor box
  ctx.strokeStyle = canBuild ? `rgba(100, 255, 100, ${pulse})` : `rgba(255, 100, 100, ${pulse})`;
  ctx.lineWidth = 3;
  ctx.strokeRect(cursorX + 2, cursorY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
  
  // Draw preview of item
  if (selectedBuildItem === 'fencing') {
    ctx.fillStyle = canBuild ? 'rgba(139, 90, 43, 0.6)' : 'rgba(139, 90, 43, 0.3)';
    ctx.fillRect(cursorX + 4, cursorY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
  } else if (selectedBuildItem === 'gate') {
    ctx.fillStyle = canBuild ? 'rgba(100, 80, 60, 0.6)' : 'rgba(100, 80, 60, 0.3)';
    ctx.fillRect(cursorX + 4, cursorY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
    // Gate bars
    ctx.strokeStyle = canBuild ? 'rgba(70, 50, 30, 0.8)' : 'rgba(70, 50, 30, 0.4)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(cursorX + 8 + i * 8, cursorY + 6);
      ctx.lineTo(cursorX + 8 + i * 8, cursorY + TILE_SIZE - 6);
      ctx.stroke();
    }
  }
  
  // Build mode HUD
  const hudX = 10;
  const hudY = canvas.height - 60;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.beginPath();
  ctx.roundRect(hudX, hudY, 200, 50, 8);
  ctx.fill();
  
  ctx.fillStyle = '#ffd700';
  ctx.font = 'bold 12px system-ui';
  ctx.fillText('ðŸ”¨ BUILD MODE', hudX + 10, hudY + 18);
  
  ctx.fillStyle = '#ffffff';
  ctx.font = '10px system-ui';
  const itemName = selectedBuildItem === 'fencing' ? 'Fencing' : 'Gate';
  const itemCount = inventory[selectedBuildItem] || 0;
  ctx.fillText(`${itemName}: ${itemCount} | Q: Switch | E: Place | ESC: Exit`, hudX + 10, hudY + 36);
}

// Draw purchased animals
function drawPurchasedAnimals() {
  if (currentMap !== 'overworld') return;
  
  purchasedAnimals.forEach(animal => {
    if (animal.map !== currentMap) return;
    
    const px = animal.px;
    const py = animal.py;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 28, 10, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw based on animal type
    if (animal.type === 'sheep') {
      // Body (fluffy)
      ctx.fillStyle = animal.hasResource ? '#f8f8f0' : '#d0d0c8';
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 18, 10, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      // Head
      ctx.fillStyle = '#e0e0d8';
      ctx.beginPath();
      ctx.arc(px + 16, py + 10, 5, 0, Math.PI * 2);
      ctx.fill();
      // Legs
      ctx.fillStyle = '#8a7a6a';
      ctx.fillRect(px + 10, py + 24, 3, 6);
      ctx.fillRect(px + 19, py + 24, 3, 6);
    } else if (animal.type === 'llama') {
      // Body
      ctx.fillStyle = animal.hasResource ? '#e8d8c0' : '#c8b8a0';
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 18, 9, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      // Neck
      ctx.fillRect(px + 13, py + 4, 6, 12);
      // Head
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 3, 5, 4, 0, 0, Math.PI * 2);
      ctx.fill();
      // Legs
      ctx.fillStyle = '#a89880';
      ctx.fillRect(px + 10, py + 24, 3, 6);
      ctx.fillRect(px + 19, py + 24, 3, 6);
    } else if (animal.type === 'rabbit') {
      // Body
      ctx.fillStyle = animal.hasResource ? '#d0c0b0' : '#b0a090';
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 20, 7, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      // Head
      ctx.beginPath();
      ctx.arc(px + 16, py + 12, 5, 0, Math.PI * 2);
      ctx.fill();
      // Ears
      ctx.beginPath();
      ctx.ellipse(px + 13, py + 5, 2, 5, -0.2, 0, Math.PI * 2);
      ctx.ellipse(px + 19, py + 5, 2, 5, 0.2, 0, Math.PI * 2);
      ctx.fill();
    } else if (animal.type === 'extraGoat') {
      // Body
      ctx.fillStyle = animal.hasResource ? '#c8b8a8' : '#a89888';
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 18, 9, 7, 0, 0, Math.PI * 2);
      ctx.fill();
      // Head
      ctx.beginPath();
      ctx.arc(px + 16, py + 8, 5, 0, Math.PI * 2);
      ctx.fill();
      // Horns
      ctx.strokeStyle = '#706050';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px + 12, py + 6);
      ctx.lineTo(px + 9, py + 2);
      ctx.moveTo(px + 20, py + 6);
      ctx.lineTo(px + 23, py + 2);
      ctx.stroke();
      // Legs
      ctx.fillStyle = '#8a7a6a';
      ctx.fillRect(px + 10, py + 24, 3, 6);
      ctx.fillRect(px + 19, py + 24, 3, 6);
    }
    
    // Resource indicator (star if ready)
    if (animal.hasResource) {
      ctx.fillStyle = '#ffd700';
      ctx.font = '10px system-ui';
      ctx.fillText('âœ¨', px + 22, py + 6);
    }
  });
}

// Update purchased animals (wandering and resource regrowth)
function updatePurchasedAnimals() {
  purchasedAnimals.forEach(animal => {
    // Resource regrowth
    if (!animal.hasResource) {
      animal.resourceTimer++;
      if (animal.resourceTimer >= animal.regrowTime) {
        animal.hasResource = true;
        animal.resourceTimer = 0;
      }
    }
    
    // Simple wandering (similar to base animals)
    if (animal.map !== currentMap) return;
    
    if (animal.isMoving) {
      animal.moveProgress++;
      const t = animal.moveProgress / ANIMAL_MOVE_FRAMES;
      const startX = animal.x * TILE_SIZE;
      const startY = animal.y * TILE_SIZE;
      const endX = animal.targetX * TILE_SIZE;
      const endY = animal.targetY * TILE_SIZE;
      animal.px = startX + (endX - startX) * t;
      animal.py = startY + (endY - startY) * t;
      
      if (animal.moveProgress >= ANIMAL_MOVE_FRAMES) {
        animal.x = animal.targetX;
        animal.y = animal.targetY;
        animal.px = animal.x * TILE_SIZE;
        animal.py = animal.y * TILE_SIZE;
        animal.isMoving = false;
        animal.moveProgress = 0;
        animal.moveDelay = 120 + Math.floor(Math.random() * 180);
        animal.moveTimer = 0;
      }
      return;
    }
    
    animal.moveTimer++;
    if (animal.moveTimer < animal.moveDelay) return;
    
    if (Math.random() < 0.4) {
      animal.moveTimer = 0;
      return;
    }
    
    const directions = [
      { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
      { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
    ];
    
    for (let i = directions.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [directions[i], directions[j]] = [directions[j], directions[i]];
    }
    
    for (const dir of directions) {
      const newX = animal.x + dir.dx;
      const newY = animal.y + dir.dy;
      
      // Check bounds and wander radius
      if (newX < 0 || newY < 0 || newX >= MAP_COLS || newY >= MAP_ROWS) continue;
      if (Math.abs(newX - animal.homeX) > animal.wanderRadius) continue;
      if (Math.abs(newY - animal.homeY) > animal.wanderRadius) continue;
      
      // Check tile walkability
      const tile = mapData[newY][newX];
      if (tile !== 0 && tile !== 1 && tile !== 8 && tile !== 12) continue;
      
      // Check collisions
      if (newX === player.x && newY === player.y) continue;
      if (isAnimalAt(newX, newY)) continue;
      
      animal.targetX = newX;
      animal.targetY = newY;
      animal.isMoving = true;
      animal.moveProgress = 0;
      break;
    }
    
    animal.moveTimer = 0;
  });
}

// Update traveling merchant spawn/despawn
function updateTravelingMerchant() {
  if (!travelingMerchant.isPresent) {
    // Waiting to spawn
    travelingMerchant.spawnTimer++;
    if (travelingMerchant.spawnTimer >= travelingMerchant.spawnDelay) {
      // Spawn the merchant!
      travelingMerchant.isPresent = true;
      travelingMerchant.stayTimer = 0;
      travelingMerchant.spawnTimer = 0;
      showMessage("A traveling merchant has arrived! Look for Willa on the west side.");
    }
  } else {
    // Don't count down if player is shopping with her
    if (merchantShopOpen) return;
    
    // Merchant is present, count down stay time
    travelingMerchant.stayTimer++;
    if (travelingMerchant.stayTimer >= travelingMerchant.stayDuration) {
      // Merchant leaves
      travelingMerchant.isPresent = false;
      travelingMerchant.spawnDelay = 2400 + Math.floor(Math.random() * 1200); // 40-60 sec until next visit
      if (merchantShopOpen) {
        merchantShopOpen = false;
        showMessage("Willa: \"Time for me to go! See you next time!\"");
      } else {
        showMessage("The traveling merchant has left...");
      }
    }
  }
}

// Draw the traveling merchant
function drawTravelingMerchant() {
  if (!travelingMerchant.isPresent || currentMap !== travelingMerchant.map) return;
  
  const px = travelingMerchant.x * TILE_SIZE;
  const py = travelingMerchant.y * TILE_SIZE;
  
  // Cart/wagon behind merchant
  ctx.fillStyle = '#8b4513';
  ctx.fillRect(px - 8, py + 8, 28, 20);
  ctx.fillStyle = '#d2691e';
  ctx.fillRect(px - 6, py + 2, 24, 8);
  
  // Wheels
  ctx.fillStyle = '#4a3728';
  ctx.beginPath();
  ctx.arc(px - 2, py + 28, 5, 0, Math.PI * 2);
  ctx.arc(px + 18, py + 28, 5, 0, Math.PI * 2);
  ctx.fill();
  
  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(px + 16, py + 26, 8, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Body (purple cloak)
  ctx.fillStyle = travelingMerchant.color;
  ctx.fillRect(px + 10, py + 12, 12, 14);
  
  // Legs
  ctx.fillStyle = '#2b3145';
  ctx.fillRect(px + 11, py + 24, 4, 6);
  ctx.fillRect(px + 17, py + 24, 4, 6);
  
  // Head
  ctx.beginPath();
  ctx.arc(px + 16, py + 8, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#deb887';
  ctx.fill();
  
  // Hat (witch/merchant style)
  ctx.fillStyle = '#4a0080';
  ctx.beginPath();
  ctx.moveTo(px + 8, py + 4);
  ctx.lineTo(px + 16, py - 8);
  ctx.lineTo(px + 24, py + 4);
  ctx.closePath();
  ctx.fill();
  
  // Eyes
  ctx.fillStyle = '#3a2a24';
  ctx.fillRect(px + 13, py + 7, 1, 2);
  ctx.fillRect(px + 18, py + 7, 1, 2);
  
  // Exclamation mark (always has something to sell!)
  const bob = Math.sin(Date.now() / 200) * 2;
  ctx.fillStyle = '#ffdd44';
  ctx.beginPath();
  ctx.arc(px + 16, py - 16 + bob, 8, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#222222';
  ctx.font = 'bold 12px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('$', px + 16, py - 16 + bob);
  ctx.textBaseline = 'alphabetic';
  
  // Show name when player is close
  const dist = Math.abs(player.x - travelingMerchant.x) + Math.abs(player.y - travelingMerchant.y);
  if (dist <= 2) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const nameWidth = ctx.measureText(travelingMerchant.name).width;
    ctx.fillRect(px + 16 - nameWidth/2 - 4, py - 28, nameWidth + 8, 14);
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(travelingMerchant.name, px + 16, py - 18);
    ctx.textAlign = 'left';
  }
}

// Open merchant shop
function openMerchantShop() {
  merchantShopOpen = true;
  merchantShopSelection = 0;
  taskProgress.metMerchant = true; // Track for task board
  if (touchBackButton) touchBackButton.classList.add('visible');
}

// Close merchant shop
function closeMerchantShop() {
  merchantShopOpen = false;
  merchantShopSelection = 0;
  if (touchBackButton) touchBackButton.classList.remove('visible');
  showMessage("Willa: \"Safe travels! Come back soon!\"");
}

// Purchase from merchant
function purchaseFromMerchant() {
  if (!merchantShopOpen) return;
  
  const item = merchantStock[merchantShopSelection];
  if (!item) return;
  
  if ((inventory.gold || 0) < item.price) {
    showMessage(`Not enough gold! You need ${item.price}g.`);
    return;
  }
  
  inventory.gold -= item.price;
  inventory[item.id] = (inventory[item.id] || 0) + 1;
  showMessage(`Purchased ${item.name}! Willa: "Excellent choice!"`);
}

// Draw merchant shop UI
function drawMerchantShopUI() {
  if (!merchantShopOpen) return;
  
  const panelW = 300;
  const panelH = 220;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;
  
  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Panel background
  ctx.fillStyle = 'rgba(75, 0, 130, 0.95)';
  ctx.fillRect(panelX, panelY, panelW, panelH);
  
  // Border
  ctx.strokeStyle = '#ffdd44';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX + 1, panelY + 1, panelW - 2, panelH - 2);
  
  // Title
  ctx.fillStyle = '#ffdd44';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText("Wandering Willa's Wares", panelX + panelW/2, panelY + 20);
  
  // Gold display
  ctx.fillStyle = '#ffd700';
  ctx.font = '12px system-ui';
  ctx.fillText(`Your Gold: ${inventory.gold || 0}g`, panelX + panelW/2, panelY + 38);
  ctx.textAlign = 'left';
  
  // Items list
  const startY = panelY + 55;
  merchantStock.forEach((item, i) => {
    const y = startY + i * 24;
    const isSelected = i === merchantShopSelection;
    
    // Selection highlight
    if (isSelected) {
      ctx.fillStyle = 'rgba(255, 221, 68, 0.3)';
      ctx.fillRect(panelX + 8, y - 12, panelW - 16, 22);
    }
    
    // Item name and price
    ctx.fillStyle = isSelected ? '#ffdd44' : '#ffffff';
    ctx.font = isSelected ? 'bold 12px system-ui' : '12px system-ui';
    ctx.fillText(`${item.name}`, panelX + 16, y);
    
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'right';
    ctx.fillText(`${item.price}g`, panelX + panelW - 16, y);
    ctx.textAlign = 'left';
  });
  
  // Selected item description
  const selectedItem = merchantStock[merchantShopSelection];
  if (selectedItem) {
    ctx.fillStyle = '#a9b3cd';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(selectedItem.description, panelX + panelW/2, panelY + panelH - 30);
    ctx.textAlign = 'left';
  }
  
  // Controls hint
  ctx.fillStyle = '#a9b3cd';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('[W/S] Select  [E] Buy  [Esc] Close', panelX + panelW/2, panelY + panelH - 12);
  ctx.textAlign = 'left';
}

// =========================
// FISHING MINI-GAME
// =========================

// Fishing state
let fishingActive = false;
let fishingPhase = 'waiting'; // 'waiting', 'biting', 'reeling', 'success', 'failed'
let fishingTimer = 0;
let fishingReelPosition = 50; // 0-100, target is center (50)
let fishingReelSpeed = 0;
let fishingTargetZone = { min: 35, max: 65 }; // Success zone
let fishingFishPull = 0; // How hard the fish is pulling
let fishingDifficulty = 1; // 1-3, increases with better catches
let fishingCatch = null; // What fish/item is being caught
let fishingBiteDelay = 0;

// Possible catches from fishing
const fishingLoot = [
  // Common (60%)
  { id: 'shells', name: 'Shells', icon: 'ðŸš', weight: 25, difficulty: 1 },
  { id: 'seaweed', name: 'Seaweed', icon: 'ðŸŒ¿', weight: 20, difficulty: 1 },
  { id: 'smallFish', name: 'Small Fish', icon: 'ðŸŸ', weight: 15, difficulty: 1 },
  // Uncommon (30%)
  { id: 'starfish', name: 'Starfish', icon: 'â­', weight: 10, difficulty: 2 },
  { id: 'crab', name: 'Crab', icon: 'ðŸ¦€', weight: 10, difficulty: 2 },
  { id: 'pearlOyster', name: 'Pearl Oyster', icon: 'ðŸ¦ª', weight: 5, difficulty: 2 },
  { id: 'bigFish', name: 'Big Fish', icon: 'ðŸ ', weight: 5, difficulty: 2 },
  // Rare (10%)
  { id: 'rareShell', name: 'Rare Shell', icon: 'ðŸšâœ¨', weight: 4, difficulty: 3 },
  { id: 'seaGlass', name: 'Sea Glass', icon: 'ðŸ’Ž', weight: 3, difficulty: 3 },
  { id: 'treasure', name: 'Treasure', icon: 'ðŸ“¿', weight: 2, difficulty: 3 },
  { id: 'goldenFish', name: 'Golden Fish', icon: 'ðŸ¡', weight: 1, difficulty: 3 }
];

// Check if player can fish (next to water on beach)
function canStartFishing() {
  if (currentMap !== 'beach') return false;
  
  const mapData = maps[currentMap].data;
  const directions = [
    { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
  ];
  
  // Check if adjacent to water (tile 17)
  for (const dir of directions) {
    const checkX = player.x + dir.dx;
    const checkY = player.y + dir.dy;
    if (checkX >= 0 && checkY >= 0 && checkX < maps[currentMap].cols && checkY < maps[currentMap].rows) {
      if (mapData[checkY][checkX] === 17) {
        return true;
      }
    }
  }
  return false;
}

// Start fishing
function startFishing() {
  if (!canStartFishing()) {
    showMessage("You need to be next to water to fish!");
    return;
  }
  
  fishingActive = true;
  fishingPhase = 'waiting';
  fishingTimer = 0;
  fishingReelPosition = 50;
  fishingReelSpeed = 0;
  fishingBiteDelay = 60 + Math.floor(Math.random() * 180); // 1-4 seconds
  
  // Randomly select what will be caught based on weights
  const totalWeight = fishingLoot.reduce((sum, item) => sum + item.weight, 0);
  let roll = Math.random() * totalWeight;
  for (const item of fishingLoot) {
    roll -= item.weight;
    if (roll <= 0) {
      fishingCatch = item;
      fishingDifficulty = item.difficulty;
      break;
    }
  }
  
  showMessage("ðŸŽ£ Cast your line... wait for a bite!");
  if (touchBackButton) touchBackButton.classList.add('visible');
}

// Stop fishing
function stopFishing() {
  fishingActive = false;
  fishingPhase = 'waiting';
  fishingCatch = null;
  if (touchBackButton) touchBackButton.classList.remove('visible');
}

// Update fishing mini-game
function updateFishing() {
  if (!fishingActive) return;
  
  fishingTimer++;
  
  if (fishingPhase === 'waiting') {
    // Waiting for fish to bite
    if (fishingTimer >= fishingBiteDelay) {
      fishingPhase = 'biting';
      fishingTimer = 0;
      showMessage("ðŸŸ Something's biting! Press E quickly!");
    }
  } else if (fishingPhase === 'biting') {
    // Player has ~0.8 seconds to react
    if (fishingTimer > 50) {
      fishingPhase = 'failed';
      showMessage("The fish got away! Too slow.");
      setTimeout(() => stopFishing(), 1000);
    }
  } else if (fishingPhase === 'reeling') {
    // Active reeling phase - keep the bar in the target zone
    
    // Fish pulls with varying intensity - stronger and more erratic
    const pullVariance = Math.sin(fishingTimer * 0.15) * fishingDifficulty * 1.5;
    const randomJerk = (Math.random() - 0.5) * fishingDifficulty * 2;
    fishingFishPull = (fishingDifficulty * 1.5 + pullVariance + randomJerk) * (Math.random() > 0.5 ? 1 : -1);
    
    // Apply fish pull to reel position - stronger effect
    fishingReelPosition += fishingFishPull * 0.8;
    
    // Apply friction/decay to reel speed - less friction means more drift
    fishingReelSpeed *= 0.75;
    fishingReelPosition += fishingReelSpeed;
    
    // Clamp position
    fishingReelPosition = Math.max(0, Math.min(100, fishingReelPosition));
    
    // Check if in success zone
    const inZone = fishingReelPosition >= fishingTargetZone.min && fishingReelPosition <= fishingTargetZone.max;
    
    if (inZone) {
      fishingTimer++;
      // Need to stay in zone for ~3 seconds total (180 frames at 60fps)
      if (fishingTimer >= 180) {
        fishingPhase = 'success';
        fishingTimer = 0;
      }
    } else {
      // Lose progress faster if outside zone
      fishingTimer = Math.max(0, fishingTimer - 1.5);
    }
    
    // Fail if position goes too extreme for too long
    if (fishingReelPosition <= 5 || fishingReelPosition >= 95) {
      if (fishingTimer < -30) { // Built up negative progress
        fishingPhase = 'failed';
        showMessage("The fish escaped! Keep the bar in the zone!");
        setTimeout(() => stopFishing(), 1000);
      }
    }
  } else if (fishingPhase === 'success') {
    // Caught something!
    if (fishingTimer === 0) {
      inventory[fishingCatch.id] = (inventory[fishingCatch.id] || 0) + 1;
      const rarity = fishingDifficulty === 3 ? 'âœ¨ RARE! ' : (fishingDifficulty === 2 ? 'ðŸŒŸ Nice! ' : '');
      showMessage(`${rarity}You caught: ${fishingCatch.icon} ${fishingCatch.name}!`);
    }
    fishingTimer++;
    if (fishingTimer > 90) {
      stopFishing();
    }
  }
}

// Handle fishing input (called from keyboard/touch handlers)
function handleFishingInput(action) {
  if (!fishingActive) return false;
  
  if (action === 'action') {
    if (fishingPhase === 'biting') {
      // Start reeling!
      fishingPhase = 'reeling';
      fishingTimer = 0;
      // Smaller zones: easy=38-62, medium=35-65 moves more, hard=32-68 moves a lot
      fishingTargetZone = {
        min: 45 - (fishingDifficulty - 1) * 3, // Harder fish = zone moves more but similar size
        max: 55 + (fishingDifficulty - 1) * 3
      };
      showMessage("Keep the bar in the green zone!");
      return true;
    } else if (fishingPhase === 'reeling') {
      // Reel in - push toward center (weaker push = need more taps)
      fishingReelSpeed += (50 - fishingReelPosition) > 0 ? 2 : -2;
      return true;
    }
  } else if (action === 'cancel') {
    stopFishing();
    showMessage("Stopped fishing.");
    return true;
  }
  
  return false;
}

// Draw fishing UI
function drawFishingUI() {
  if (!fishingActive) return;
  
  const panelW = 280;
  const panelH = 140;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = canvas.height - panelH - 40;
  
  // Panel background
  ctx.fillStyle = 'rgba(20, 40, 80, 0.9)';
  ctx.beginPath();
  ctx.roundRect(panelX, panelY, panelW, panelH, 12);
  ctx.fill();
  ctx.strokeStyle = '#64b4ff';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Title
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 14px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('ðŸŽ£ FISHING', canvas.width / 2, panelY + 22);
  
  if (fishingPhase === 'waiting') {
    // Show waiting animation
    const dots = '.'.repeat((Math.floor(fishingTimer / 20) % 4));
    ctx.fillStyle = '#88ccff';
    ctx.font = '12px system-ui';
    ctx.fillText(`Waiting for a bite${dots}`, canvas.width / 2, panelY + 50);
    
    // Bobber animation
    const bob = Math.sin(fishingTimer * 0.15) * 3;
    ctx.font = '28px system-ui';
    ctx.fillText('ðŸŽ£', canvas.width / 2, panelY + 90 + bob);
    
  } else if (fishingPhase === 'biting') {
    // Alert! Fish biting!
    const flash = Math.sin(fishingTimer * 0.5) > 0;
    ctx.fillStyle = flash ? '#ffff00' : '#ff8800';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('! FISH BITING !', canvas.width / 2, panelY + 50);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px system-ui';
    ctx.fillText('Press E / Tap to reel in!', canvas.width / 2, panelY + 75);
    
    // Splashing bobber
    ctx.font = '28px system-ui';
    const shake = (Math.random() - 0.5) * 6;
    ctx.fillText('ðŸŽ£ðŸ’¦', canvas.width / 2 + shake, panelY + 105);
    
  } else if (fishingPhase === 'reeling') {
    // Reeling mini-game bar
    const barW = 200;
    const barH = 24;
    const barX = panelX + (panelW - barW) / 2;
    const barY = panelY + 45;
    
    // Progress toward catch
    const progressW = 160;
    const progressX = panelX + (panelW - progressW) / 2;
    const progressY = panelY + 80;
    
    // Status text
    ctx.fillStyle = '#88ccff';
    ctx.font = '11px system-ui';
    ctx.fillText(`Catching: ${fishingCatch.icon} ${fishingCatch.name}`, canvas.width / 2, panelY + 38);
    
    // Reel bar background
    ctx.fillStyle = '#1a3366';
    ctx.beginPath();
    ctx.roundRect(barX, barY, barW, barH, 4);
    ctx.fill();
    
    // Target zone (green)
    const zoneStartX = barX + (fishingTargetZone.min / 100) * barW;
    const zoneEndX = barX + (fishingTargetZone.max / 100) * barW;
    ctx.fillStyle = 'rgba(80, 200, 80, 0.6)';
    ctx.fillRect(zoneStartX, barY + 2, zoneEndX - zoneStartX, barH - 4);
    
    // Reel position indicator
    const indicatorX = barX + (fishingReelPosition / 100) * barW;
    const inZone = fishingReelPosition >= fishingTargetZone.min && fishingReelPosition <= fishingTargetZone.max;
    
    ctx.fillStyle = inZone ? '#00ff88' : '#ff4444';
    ctx.beginPath();
    ctx.roundRect(indicatorX - 6, barY - 2, 12, barH + 4, 3);
    ctx.fill();
    
    // Fish icon on indicator
    ctx.font = '14px system-ui';
    ctx.fillText('ðŸŸ', indicatorX - 7, barY + barH + 18);
    
    // Progress bar
    ctx.fillStyle = '#333366';
    ctx.beginPath();
    ctx.roundRect(progressX, progressY, progressW, 12, 3);
    ctx.fill();
    
    const progressPercent = Math.min(1, fishingTimer / 120);
    ctx.fillStyle = progressPercent >= 1 ? '#00ff88' : '#4488ff';
    ctx.beginPath();
    ctx.roundRect(progressX, progressY, progressW * progressPercent, 12, 3);
    ctx.fill();
    
    ctx.fillStyle = '#aaccff';
    ctx.font = '10px system-ui';
    ctx.fillText('Catch Progress', canvas.width / 2, progressY + 24);
    
    // Instructions
    ctx.fillStyle = '#88aacc';
    ctx.font = '10px system-ui';
    ctx.fillText('[E/Tap] Reel | [Esc] Cancel', canvas.width / 2, panelY + panelH - 12);
    
  } else if (fishingPhase === 'success') {
    // Success celebration!
    const bounce = Math.abs(Math.sin(fishingTimer * 0.2)) * 10;
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 16px system-ui';
    ctx.fillText('CAUGHT!', canvas.width / 2, panelY + 45 - bounce);
    
    ctx.font = '36px system-ui';
    ctx.fillText(fishingCatch.icon, canvas.width / 2, panelY + 85);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px system-ui';
    ctx.fillText(fishingCatch.name, canvas.width / 2, panelY + 110);
    
  } else if (fishingPhase === 'failed') {
    // Failed :(
    ctx.fillStyle = '#ff6666';
    ctx.font = 'bold 14px system-ui';
    ctx.fillText('Got away...', canvas.width / 2, panelY + 60);
    
    ctx.font = '28px system-ui';
    ctx.fillText('ðŸ’¨ðŸŸ', canvas.width / 2, panelY + 95);
  }
  
  ctx.textAlign = 'left';
}

const cottageFurniture = [
  { map: 'cottage', x: 1, y: 3, type: 'armchair' },
  { map: 'cottage', x: 6, y: 2, type: 'bookshelf' },
  { map: 'cottage', x: 6, y: 4, type: 'chest' }
  // Spinning wheel drawn separately at knittingSpot (5, 1)
];

// ===== NPC SYSTEM =====

// Dialogue state
let dialogueOpen = false;
let currentNPC = null;
let dialogueIndex = 0;

// Gift menu state
let giftMenuOpen = false;
let giftMenuSelection = 0;

// Friendship system
const FRIENDSHIP_MAX = 100;
const friendship = {
  granny: 0,
  merchant: 0,
  shepherd: 0,
  gardener: 0,
  hermit: 0,
  barnaby: 0,
  felix: 0,
  theo: 0,
  iris: 0,
  mosswort: 0
};

// Friendship Perks - rewards at certain thresholds
const friendshipPerks = {
  granny: {
    name: 'Granny Willow',
    thresholds: {
      25: { type: 'discount', target: 'tailor', amount: 10, description: '10% discount at Tailor Shop' },
      50: { type: 'recipe', recipe: 'luxurySocks', description: 'Unlocks Luxury Socks recipe' },
      75: { type: 'discount', target: 'tailor', amount: 20, description: '20% discount at Tailor Shop' },
      100: { type: 'bonus', target: 'knitting', amount: 10, description: '+10% gold from selling knitted items' }
    }
  },
  felix: {
    name: 'Felix',
    thresholds: {
      25: { type: 'discount', target: 'dye', amount: 10, description: '10% discount on dyes' },
      50: { type: 'recipe', recipe: 'dyeBundle', description: 'Unlocks Dye Bundle recipe' },
      75: { type: 'bonus', target: 'dyeYield', amount: 1, description: '+1 extra dye per craft' },
      100: { type: 'recipe', recipe: 'rainbowYarn', description: 'Unlocks Rainbow Yarn recipe' }
    }
  },
  theo: {
    name: 'Theo',
    thresholds: {
      25: { type: 'discount', target: 'merchant', amount: 10, description: '10% discount at Merchant' },
      50: { type: 'recipe', recipe: 'fancyScarf', description: 'Unlocks Fancy Scarf recipe' },
      75: { type: 'bonus', target: 'sellPrice', amount: 10, description: '+10% gold from all sales' },
      100: { type: 'recipe', recipe: 'royalCloak', description: 'Unlocks Royal Cloak recipe' }
    }
  },
  iris: {
    name: 'Iris',
    thresholds: {
      25: { type: 'bonus', target: 'forage', amount: 1, description: '+1 item when foraging' },
      50: { type: 'recipe', recipe: 'flowerCrown', description: 'Unlocks Flower Crown recipe' },
      75: { type: 'bonus', target: 'forage', amount: 2, description: '+2 items when foraging' },
      100: { type: 'recipe', recipe: 'herbalDye', description: 'Unlocks Herbal Dye recipe' }
    }
  },
  mosswort: {
    name: 'Old Mosswort',
    thresholds: {
      25: { type: 'hint', target: 'crystals', description: 'Hints about crystal shard locations' },
      50: { type: 'recipe', recipe: 'enchantedYarn', description: 'Unlocks Enchanted Yarn recipe' },
      75: { type: 'discount', target: 'fastTravel', amount: 50, description: '50% off fast travel' },
      100: { type: 'bonus', target: 'crystalPower', amount: 1, description: 'Crystal effects last longer' }
    }
  },
  barnaby: {
    name: 'Barnaby',
    thresholds: {
      25: { type: 'discount', target: 'farm', amount: 10, description: '10% discount at Farm Shop' },
      50: { type: 'bonus', target: 'animalYield', amount: 10, description: '+10% wool/fur yield' },
      75: { type: 'discount', target: 'farm', amount: 25, description: '25% discount at Farm Shop' },
      100: { type: 'bonus', target: 'animalYield', amount: 25, description: '+25% wool/fur yield' }
    }
  }
};

// Track which perks have been unlocked
const unlockedPerks = {};

// Check if a perk is unlocked
function isPerkUnlocked(npcId, threshold) {
  return unlockedPerks[npcId] && unlockedPerks[npcId][threshold];
}

// Check for newly unlocked perks when friendship changes
function checkFriendshipPerks(npcId) {
  const currentFriendship = friendship[npcId] || 0;
  const perks = friendshipPerks[npcId];
  if (!perks) return;
  
  if (!unlockedPerks[npcId]) unlockedPerks[npcId] = {};
  
  for (const [threshold, perk] of Object.entries(perks.thresholds)) {
    const thresholdNum = parseInt(threshold);
    if (currentFriendship >= thresholdNum && !unlockedPerks[npcId][threshold]) {
      // Unlock this perk!
      unlockedPerks[npcId][threshold] = true;
      showMessage(`ðŸŽ‰ ${perks.name} Perk Unlocked: ${perk.description}`);
    }
  }
}

// Get total discount for a shop type
function getShopDiscount(shopType) {
  let discount = 0;
  for (const [npcId, perks] of Object.entries(friendshipPerks)) {
    for (const [threshold, perk] of Object.entries(perks.thresholds)) {
      if (isPerkUnlocked(npcId, threshold) && perk.type === 'discount' && perk.target === shopType) {
        discount = Math.max(discount, perk.amount); // Use highest discount, don't stack
      }
    }
  }
  return discount;
}

// Get bonus percentage for a bonus type
function getPerkBonus(bonusType) {
  let bonus = 0;
  for (const [npcId, perks] of Object.entries(friendshipPerks)) {
    for (const [threshold, perk] of Object.entries(perks.thresholds)) {
      if (isPerkUnlocked(npcId, threshold) && perk.type === 'bonus' && perk.target === bonusType) {
        bonus += perk.amount; // Bonuses can stack
      }
    }
  }
  return bonus;
}

// Check if a recipe is unlocked through friendship
function isRecipeUnlockedByFriendship(recipeId) {
  for (const [npcId, perks] of Object.entries(friendshipPerks)) {
    for (const [threshold, perk] of Object.entries(perks.thresholds)) {
      if (perk.type === 'recipe' && perk.recipe === recipeId && isPerkUnlocked(npcId, threshold)) {
        return true;
      }
    }
  }
  return false;
}

// Apply discount to a price
function applyDiscount(basePrice, shopType) {
  const discount = getShopDiscount(shopType);
  if (discount > 0) {
    return Math.floor(basePrice * (100 - discount) / 100);
  }
  return basePrice;
}

// Villager NPCs
const villagers = [
  {
    id: 'granny',
    name: 'Granny Willow',
    map: 'village',
    x: 3,
    y: 3,
    homeX: 3,
    homeY: 3,
    wanderRadius: 2,
    moveTimer: 0,
    moveDelay: 180,
    color: '#e8b8d8',
    dialogue: [
      "Oh hello, dear! The yarn you make is simply wonderful.",
      "Back in my day, we knit everything by hand!",
      "Have you tried making a nice warm blanket?",
      "My joints ache when rain is coming."
    ],
    lovedGifts: ['blanket', 'socks'],
    likedGifts: ['scarf', 'mittens', 'yarn'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  {
    id: 'merchant',
    name: 'Felix the Trader',
    map: 'village',
    x: 9,
    y: 4,
    homeX: 9,
    homeY: 4,
    wanderRadius: 1,
    moveTimer: 0,
    moveDelay: 150,
    color: '#d4a574',
    dialogue: [
      "Business is good today! Your scarves sell well.",
      "I hear there's demand for luxury goods!",
      "Keep up the good work!",
      "Quality craftsmanship never goes out of style."
    ],
    lovedGifts: ['luxuryScarf', 'hat'],
    likedGifts: ['scarf', 'luxuryYarn'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  {
    id: 'shepherd',
    name: 'Young Tom',
    map: 'village',
    x: 15,
    y: 3,
    homeX: 15,
    homeY: 3,
    wanderRadius: 2,
    moveTimer: 0,
    moveDelay: 120,
    color: '#7eb87e',
    dialogue: [
      "Heya! I love watching the sheep!",
      "Did you know goats are smarter than sheep?",
      "I want to have my own farm someday!",
      "The animals seem happy here."
    ],
    lovedGifts: ['mittens', 'socks'],
    likedGifts: ['scarf', 'yarn', 'wool'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  {
    id: 'gardener',
    name: 'Mira the Gardener',
    map: 'village',
    x: 5,
    y: 4,
    homeX: 5,
    homeY: 4,
    wanderRadius: 2,
    moveTimer: 0,
    moveDelay: 160,
    color: '#6db7d6',
    dialogue: [
      "The flowers bloom brightest after rain.",
      "Every plant has a story!",
      "If you ever need a bouquet, just ask!",
      "Nature provides everything we need."
    ],
    lovedGifts: ['hat', 'scarf'],
    likedGifts: ['yarn', 'mittens'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  // === ELDER MARA - Festival Coordinator ===
  {
    id: 'elder',
    name: 'Elder Mara',
    map: 'village',
    x: 9,
    y: 6,
    homeX: 9,
    homeY: 6,
    wanderRadius: 1,
    moveTimer: 0,
    moveDelay: 300,
    color: '#9c7c9c',
    isFestivalNPC: true,
    dialogue: [
      "Welcome, young crafter. I am Elder Mara, keeper of village traditions.",
      "The Festival of Threads celebrates our weaving heritage.",
      "Each year we decorate the village with fine textiles.",
      "In my grandmother's time, the festival lasted three days!"
    ],
    festivalDialogue: [
      "The festival is underway! How wonderful!",
      "Your contribution honors our ancestors.",
      "The village looks so festive with all these decorations!",
      "Soon we'll light the ceremonial lanterns."
    ],
    lovedGifts: ['blanket', 'luxuryScarf', 'hat'],
    likedGifts: ['scarf', 'yarn', 'luxuryYarn'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  // === SOUTH VILLAGE VENDORS ===
  {
    id: 'dyer',
    name: 'Iris the Dyer',
    map: 'village',
    x: 3,
    y: 9,
    homeX: 3,
    homeY: 9,
    wanderRadius: 1,
    moveTimer: 0,
    moveDelay: 200,
    color: '#c9a0dc',
    isVendor: true,
    vendorType: 'dyeShop',
    dialogue: [
      "Welcome to my dye shop! I specialize in natural colors.",
      "Forest berries and flowers make the best dyes!",
      "Bring me foraged items and I'll trade you dyes.",
      "Each color tells a story from nature."
    ],
    lovedGifts: ['berries', 'wildFlower', 'resin'],
    likedGifts: ['mushroom', 'yarn'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  {
    id: 'tailor',
    name: 'Master Theo',
    map: 'village',
    x: 15,
    y: 9,
    homeX: 15,
    homeY: 9,
    wanderRadius: 1,
    moveTimer: 0,
    moveDelay: 180,
    color: '#8b4513',
    isVendor: true,
    vendorType: 'tailorShop',
    dialogue: [
      "Ah, a fellow craftsperson! I am Theo, master tailor.",
      "I buy premium cloth and luxury items at fair prices.",
      "Your work is impeccable! Keep crafting quality goods.",
      "The Crystal Loom... I've heard legends of its power."
    ],
    lovedGifts: ['luxuryScarf', 'luxuryMittens', 'luxurySocks'],
    likedGifts: ['scarf', 'hat', 'blanket'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  // === FOREST HERMIT ===
  {
    id: 'hermit',
    name: 'Old Mosswort',
    map: 'forest',
    x: 10,
    y: 6,
    homeX: 10,
    homeY: 6,
    wanderRadius: 2,
    moveTimer: 0,
    moveDelay: 240,
    color: '#5a7a5a',
    dialogue: [
      "Ah, a visitor... The forest speaks of you.",
      "These woods hold many secrets. Listen to the wind.",
      "I've lived here since before The Village had a name.",
      "The crystal caves... I've seen their glow on moonless nights.",
      "Nature provides all we need, if we're patient."
    ],
    lovedGifts: ['mushroom', 'berries', 'wildFlower'],
    likedGifts: ['resin', 'yarn', 'socks'],
    request: null,
    requestItem: null,
    requestReward: 0
  },
  // === FARM SHOP NPC (Overworld) ===
  {
    id: 'barnaby',
    name: 'Farmer Barnaby',
    map: 'overworld',
    x: 16,
    y: 5,
    homeX: 16,
    homeY: 5,
    wanderRadius: 2,
    moveTimer: 0,
    moveDelay: 200,
    color: '#8b7355',
    isVendor: true,
    vendorType: 'farmShop',
    dialogue: [
      "Howdy there! I'm Barnaby, purveyor of fine farm supplies!",
      "Need fencing for your animals? I've got the best in Yarnvale!",
      "A proper pen keeps your critters happy and healthy.",
      "I also sell some fine animals if you're looking to expand!"
    ],
    lovedGifts: ['wool', 'goatFur', 'hay'],
    likedGifts: ['yarn', 'socks', 'mittens'],
    request: null,
    requestItem: null,
    requestReward: 0
  }
];

// NPC Functions
function openDialogue(npc) {
  // Check if this is a vendor NPC - open their shop instead of dialogue
  if (npc.isVendor) {
    if (npc.vendorType === 'dyeShop') {
      openDyeShop();
      return;
    } else if (npc.vendorType === 'tailorShop') {
      openTailorShop();
      return;
    } else if (npc.vendorType === 'farmShop') {
      openFarmShop();
      return;
    }
  }
  
  // Check if this is Elder Mara and festival is available
  if (npc.isFestivalNPC && isFestivalAvailable()) {
    openFestivalMenu();
    return;
  }
  
  dialogueOpen = true;
  currentNPC = npc;
  dialogueIndex = 0;
  // Show back and gift buttons on mobile
  if (touchBackButton) touchBackButton.classList.add('visible');
  if (touchGiftButton) touchGiftButton.classList.add('visible');
}

function closeDialogue() {
  dialogueOpen = false;
  currentNPC = null;
  dialogueIndex = 0;
  giftMenuOpen = false;
  // Hide back and gift buttons on mobile
  if (touchBackButton) touchBackButton.classList.remove('visible');
  if (touchGiftButton) touchGiftButton.classList.remove('visible');
}

function advanceDialogue() {
  if (!currentNPC) return;
  dialogueIndex = (dialogueIndex + 1) % currentNPC.dialogue.length;
}

function openGiftMenu() {
  giftMenuOpen = true;
  giftMenuSelection = 0;
}

function closeGiftMenu() {
  giftMenuOpen = false;
  giftMenuSelection = 0;
}

// ===== NPC MOVEMENT & REQUESTS =====

// Request item pools per NPC
const npcRequestItems = {
  granny: ['blanket', 'socks', 'scarf', 'mittens'],
  merchant: ['luxuryScarf', 'luxuryMittens', 'hat', 'scarf'],
  shepherd: ['mittens', 'socks', 'scarf', 'yarn'],
  gardener: ['hat', 'scarf', 'mittens', 'yarn'],
  hermit: ['mushroom', 'berries', 'wildFlower', 'resin']
};

// Request rewards (gold)
const requestRewards = {
  yarn: 5,
  wool: 4,
  scarf: 15,
  socks: 12,
  mittens: 20,
  hat: 18,
  blanket: 40,
  luxuryScarf: 35,
  luxuryMittens: 30,
  luxuryYarn: 10,
  mushroom: 8,
  berries: 6,
  wildFlower: 7,
  resin: 12
};

// Generate a random request for an NPC
function generateNPCRequest(npc) {
  // Don't generate requests for vendors
  if (npc.isVendor) return;
  
  const items = npcRequestItems[npc.id];
  if (!items || items.length === 0) return;
  
  const item = items[Math.floor(Math.random() * items.length)];
  const baseReward = requestRewards[item] || 10;
  // Bonus reward for requests (1.5x normal)
  const reward = Math.floor(baseReward * 1.5);
  
  npc.request = `Could you bring me a ${item}? I'll pay ${reward} gold!`;
  npc.requestItem = item;
  npc.requestReward = reward;
  npc.questState = 'available'; // available | active | completed
}

// Check if any villager has an available quest/request
function hasAvailableVillagerQuest() {
  return villagers.some(v => v.request && v.requestItem && !v.isVendor);
}

// Get the count of villagers with available requests
function getAvailableQuestCount() {
  return villagers.filter(v => v.request && v.requestItem && !v.isVendor).length;
}

// Check if player fulfills an NPC's request when giving a gift
function checkRequestFulfillment(npc, item) {
  if (npc.requestItem && npc.requestItem === item) {
    inventory.gold = (inventory.gold || 0) + npc.requestReward;
    showMessage(`${npc.name}: "Perfect! Here's ${npc.requestReward} gold as promised!"`);
    // Clear the request
    npc.request = null;
    npc.requestItem = null;
    npc.requestReward = 0;
    // Chance to generate new request later
    npc.requestCooldown = 600; // 10 seconds at 60fps
    // Track story progress - villager helped!
    onVillagerHelped();
    return true;
  }
  return false;
}

// Update NPC movement (called each frame)
function updateNPCMovement() {
  const currentMapData = maps[currentMap];
  if (!currentMapData) return;
  
  villagers.forEach(v => {
    if (v.map !== currentMap) return;
    
    // Cooldown for new requests
    if (v.requestCooldown && v.requestCooldown > 0) {
      v.requestCooldown--;
      if (v.requestCooldown === 0 && !v.request && Math.random() < 0.3) {
        generateNPCRequest(v);
      }
    }
    
    // Movement timer
    v.moveTimer = (v.moveTimer || 0) + 1;
    if (v.moveTimer < (v.moveDelay || 120)) return;
    v.moveTimer = 0;
    
    // Random chance to move (50%)
    if (Math.random() > 0.5) return;
    
    // Pick a random direction
    const directions = [
      { dx: 0, dy: -1 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
      { dx: 1, dy: 0 }
    ];
    const dir = directions[Math.floor(Math.random() * directions.length)];
    const newX = v.x + dir.dx;
    const newY = v.y + dir.dy;
    
    // Check if within wander radius
    const distFromHome = Math.abs(newX - v.homeX) + Math.abs(newY - v.homeY);
    if (distFromHome > (v.wanderRadius || 2)) return;
    
    // Check map bounds
    if (newX < 0 || newX >= currentMapData.cols || newY < 0 || newY >= currentMapData.rows) return;
    
    // Check collision with tiles (use 2D array format)
    const tile = currentMapData.data[newY][newX];
    // Solid tiles: 2=tree, 3=water, 4=fence, 7=interior wall, 10=market, 11=well,
    // 17=ocean, 19=rock, 21=palm, 22=tide pool, 23=cliff
    if (tile === 2 || tile === 3 || tile === 4 || tile === 7 || tile === 10 || tile === 11 ||
        tile === 17 || tile === 19 || tile === 21 || tile === 22 || tile === 23) return;
    
    // Check collision with player
    if (newX === player.x && newY === player.y) return;
    
    // Check collision with other NPCs
    const blocked = villagers.some(other => 
      other !== v && other.map === v.map && other.x === newX && other.y === newY
    );
    if (blocked) return;
    
    // Check collision with animals
    if (sheep.map === v.map && sheep.x === newX && sheep.y === newY) return;
    if (goat.map === v.map && goat.x === newX && goat.y === newY) return;
    
    // Move!
    v.x = newX;
    v.y = newY;
  });
}

// Check if an NPC has something important (request or first meeting)
function npcHasExclamation(npc) {
  // Elder Mara has exclamation when festival is available
  if (npc.isFestivalNPC && isFestivalAvailable() && festivalProgress.currentStep < 4) {
    return true;
  }
  // Has an active request
  if (npc.request && npc.requestItem) return true;
  // Low friendship = wants to chat
  if ((friendship[npc.id] || 0) < 10) return true;
  return false;
}

// Initialize requests for some NPCs at game start
function initializeNPCRequests() {
  // Give at least 2 villagers quests at start so players can find help
  let questsAssigned = 0;
  const shuffledVillagers = [...villagers].filter(v => !v.isVendor).sort(() => Math.random() - 0.5);
  
  for (const v of shuffledVillagers) {
    // Always give first 2 non-vendor NPCs quests, then 50% chance for others
    if (questsAssigned < 2 || Math.random() < 0.5) {
      generateNPCRequest(v);
      questsAssigned++;
    }
  }
}

// Call on game start
initializeNPCRequests();

// ===== SAVE / LOAD SYSTEM =====
const SAVE_KEY = 'yarnvale_save';

function saveGame() {
  const saveData = {
    version: 7,
    timestamp: Date.now(),
    player: {
      x: player.x,
      y: player.y,
      map: currentMap
    },
    inventory: { ...inventory },
    friendship: { ...friendship },
    sheep: {
      x: sheep.x,
      y: sheep.y,
      hasWool: sheep.hasWool,
      woolTimer: sheep.woolTimer
    },
    sheep2: {
      x: sheep2.x,
      y: sheep2.y,
      hasWool: sheep2.hasWool,
      woolTimer: sheep2.woolTimer
    },
    goat: {
      x: goat.x,
      y: goat.y,
      hasFur: goat.hasFur,
      furTimer: goat.furTimer
    },
    peacock: {
      x: peacock.x,
      y: peacock.y,
      hasFeathers: peacock.hasFeathers,
      featherTimer: peacock.featherTimer
    },
    storyProgress: { ...storyProgress },
    taskProgress: { ...taskProgress },
    taskBoardOpen: taskBoardOpen,
    placedFences: [...placedFences],
    purchasedAnimals: purchasedAnimals.map(animal => ({
      type: animal.type,
      map: animal.map,
      homeX: animal.homeX,
      homeY: animal.homeY,
      x: animal.x,
      y: animal.y,
      hasResource: animal.hasResource,
      resourceTimer: animal.resourceTimer
    })),
    signpostUnlocks: {
      overworld: signpostLocations.overworld.unlocked,
      village: signpostLocations.village.unlocked,
      forest: signpostLocations.forest.unlocked,
      beach: signpostLocations.beach.unlocked,
      mountain: signpostLocations.mountain.unlocked
    },
    ordersData: {
      lastDailyRefresh: lastDailyRefresh,
      lastWeeklyRefresh: lastWeeklyRefresh,
      dailyOrders: dailyOrders,
      weeklyOrder: weeklyOrder
    },
    unlockedPerks: { ...unlockedPerks },
    festivalProgress: { ...festivalProgress },
    festivalFastTravelDiscount: festivalFastTravelDiscount
  };
  
  try {
    localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    showMessage("Game saved!");
  } catch (e) {
    showMessage("Error: Could not save game.");
    console.error('Save failed:', e);
  }
}

function loadGame() {
  try {
    const data = localStorage.getItem(SAVE_KEY);
    if (!data) {
      showMessage("No save file found.");
      return;
    }
    
    const saveData = JSON.parse(data);
    
    // Restore player position
    player.x = saveData.player.x;
    player.y = saveData.player.y;
    currentMap = saveData.player.map;
    
    // Restore inventory
    Object.assign(inventory, saveData.inventory);
    
    // Restore friendship
    Object.assign(friendship, saveData.friendship);
    
    // Restore animals
    sheep.hasWool = saveData.sheep.hasWool;
    sheep.woolTimer = saveData.sheep.woolTimer;
    goat.hasFur = saveData.goat.hasFur;
    goat.furTimer = saveData.goat.furTimer;
    
    // Restore sheep2 (version 5+)
    if (saveData.version >= 5 && saveData.sheep2) {
      sheep2.x = saveData.sheep2.x ?? sheep2.homeX;
      sheep2.y = saveData.sheep2.y ?? sheep2.homeY;
      sheep2.px = sheep2.x * TILE_SIZE;
      sheep2.py = sheep2.y * TILE_SIZE;
      sheep2.targetX = sheep2.x;
      sheep2.targetY = sheep2.y;
      sheep2.isMoving = false;
      sheep2.hasWool = saveData.sheep2.hasWool ?? true;
      sheep2.woolTimer = saveData.sheep2.woolTimer ?? 0;
    }
    
    // Restore animal positions (version 3+)
    if (saveData.version >= 3) {
      sheep.x = saveData.sheep.x ?? sheep.homeX;
      sheep.y = saveData.sheep.y ?? sheep.homeY;
      sheep.px = sheep.x * TILE_SIZE;
      sheep.py = sheep.y * TILE_SIZE;
      sheep.targetX = sheep.x;
      sheep.targetY = sheep.y;
      sheep.isMoving = false;
      
      goat.x = saveData.goat.x ?? goat.homeX;
      goat.y = saveData.goat.y ?? goat.homeY;
      goat.px = goat.x * TILE_SIZE;
      goat.py = goat.y * TILE_SIZE;
      goat.targetX = goat.x;
      goat.targetY = goat.y;
      goat.isMoving = false;
    }
    
    // Restore peacock (version 4+)
    if (saveData.version >= 4 && saveData.peacock) {
      peacock.x = saveData.peacock.x ?? peacock.homeX;
      peacock.y = saveData.peacock.y ?? peacock.homeY;
      peacock.px = peacock.x * TILE_SIZE;
      peacock.py = peacock.y * TILE_SIZE;
      peacock.targetX = peacock.x;
      peacock.targetY = peacock.y;
      peacock.isMoving = false;
      peacock.hasFeathers = saveData.peacock.hasFeathers ?? true;
      peacock.featherTimer = saveData.peacock.featherTimer ?? 0;
    }
    
    // Restore story progress (if version 2+)
    if (saveData.storyProgress) {
      Object.assign(storyProgress, saveData.storyProgress);
      // Restore shards properly
      if (saveData.storyProgress.shards) {
        Object.assign(storyProgress.shards, saveData.storyProgress.shards);
      }
      if (saveData.storyProgress.storyFlags) {
        Object.assign(storyProgress.storyFlags, saveData.storyProgress.storyFlags);
      }
    }
    
    // Restore task progress (version 3+)
    if (saveData.taskProgress) {
      Object.assign(taskProgress, saveData.taskProgress);
    }
    if (saveData.taskBoardOpen !== undefined) {
      taskBoardOpen = saveData.taskBoardOpen;
    }
    
    // Restore placed fences and purchased animals (version 6+)
    if (saveData.version >= 6) {
      if (saveData.placedFences) {
        placedFences.length = 0;
        placedFences.push(...saveData.placedFences);
      }
      if (saveData.purchasedAnimals) {
        purchasedAnimals.length = 0;
        saveData.purchasedAnimals.forEach(animalData => {
          const animal = {
            type: animalData.type,
            map: animalData.map,
            homeX: animalData.homeX,
            homeY: animalData.homeY,
            x: animalData.x,
            y: animalData.y,
            px: animalData.x * TILE_SIZE,
            py: animalData.y * TILE_SIZE,
            targetX: animalData.x,
            targetY: animalData.y,
            isMoving: false,
            moveTimer: 0,
            direction: 'down',
            hasResource: animalData.hasResource,
            resourceTimer: animalData.resourceTimer
          };
          purchasedAnimals.push(animal);
        });
      }
      if (saveData.signpostUnlocks) {
        for (const [mapId, unlocked] of Object.entries(saveData.signpostUnlocks)) {
          if (signpostLocations[mapId]) {
            signpostLocations[mapId].unlocked = unlocked;
          }
        }
      }
      if (saveData.ordersData) {
        lastDailyRefresh = saveData.ordersData.lastDailyRefresh || 0;
        lastWeeklyRefresh = saveData.ordersData.lastWeeklyRefresh || 0;
        dailyOrders = saveData.ordersData.dailyOrders || [];
        weeklyOrder = saveData.ordersData.weeklyOrder || null;
        // Check if orders need refreshing
        checkAndRefreshOrders();
      }
      if (saveData.unlockedPerks) {
        Object.assign(unlockedPerks, saveData.unlockedPerks);
      }
    }
    
    // Restore festival progress (version 7+)
    if (saveData.version >= 7) {
      if (saveData.festivalProgress) {
        Object.assign(festivalProgress, saveData.festivalProgress);
        if (saveData.festivalProgress.materialsGathered) {
          Object.assign(festivalProgress.materialsGathered, saveData.festivalProgress.materialsGathered);
        }
      }
      if (saveData.festivalFastTravelDiscount !== undefined) {
        festivalFastTravelDiscount = saveData.festivalFastTravelDiscount;
      }
    }
    
    // Update map data reference
    mapData = maps[currentMap].data;
    
    // Update environment audio for new map
    handleEnvironmentAudio(currentMap);
    
    // Invalidate map cache in case crystal shards were collected
    invalidateBaseMaps();
    
    showMessage("Game loaded!");
  } catch (e) {
    showMessage("Error: Could not load save.");
    console.error('Load failed:', e);
  }
}

function hasSaveData() {
  return localStorage.getItem(SAVE_KEY) !== null;
}

function getGiftableItems() {
  const giftable = ['wool', 'yarn', 'luxuryYarn', 'goatFur', 'feather', 'scarf', 'luxuryScarf', 
                    'mittens', 'luxuryMittens', 'socks', 'hat', 'fancyHat', 'blanket', 'featherFan'];
  return giftable.filter(item => (inventory[item] || 0) > 0);
}

function giveSelectedGift() {
  if (!currentNPC || !giftMenuOpen) return;
  
  const items = getGiftableItems();
  if (items.length === 0 || giftMenuSelection >= items.length) {
    showMessage("You don't have anything to give.");
    closeGiftMenu();
    return;
  }
  
  const item = items[giftMenuSelection];
  inventory[item]--;
  
  // Check if this fulfills a request (higher reward!)
  if (checkRequestFulfillment(currentNPC, item)) {
    // Also give some friendship for fulfilling request
    friendship[currentNPC.id] = Math.min(FRIENDSHIP_MAX, (friendship[currentNPC.id] || 0) + 20);
    checkFriendshipPerks(currentNPC.id);
    closeGiftMenu();
    closeDialogue();
    return;
  }
  
  let friendshipGain = 3;
  let reaction = "Thanks, I suppose.";
  
  if (currentNPC.lovedGifts && currentNPC.lovedGifts.includes(item)) {
    friendshipGain = 15;
    reaction = "Oh, I love this! Thank you so much!";
  } else if (currentNPC.likedGifts && currentNPC.likedGifts.includes(item)) {
    friendshipGain = 8;
    reaction = "This is nice, thank you!";
  }
  
  friendship[currentNPC.id] = Math.min(FRIENDSHIP_MAX, (friendship[currentNPC.id] || 0) + friendshipGain);
  checkFriendshipPerks(currentNPC.id);
  
  showMessage(`${currentNPC.name}: "${reaction}" (+${friendshipGain} friendship)`);
  closeGiftMenu();
  closeDialogue();
}

function drawVillagers() {
  villagers.forEach(v => {
    if (v.map !== currentMap) return;
    
    const px = v.x * TILE_SIZE;
    const py = v.y * TILE_SIZE;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 26, 8, 3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Body
    ctx.fillStyle = v.color;
    ctx.fillRect(px + 10, py + 12, 12, 14);
    
    // Legs
    ctx.fillStyle = '#2b3145';
    ctx.fillRect(px + 11, py + 24, 4, 6);
    ctx.fillRect(px + 17, py + 24, 4, 6);
    
    // Head
    ctx.beginPath();
    ctx.arc(px + 16, py + 8, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#ffcf9e';
    ctx.fill();
    
    // Hair - varies by villager
    let hairColor = '#8a6030';
    if (v.id === 'granny') hairColor = '#c0c0c0';
    else if (v.id === 'merchant') hairColor = '#3a2825';
    else if (v.id === 'shepherd') hairColor = '#c4a574';
    else if (v.id === 'gardener') hairColor = '#2e8b57';
    else if (v.id === 'elder') hairColor = '#d8d8e8'; // Silver-purple for Elder Mara
    
    ctx.fillStyle = hairColor;
    ctx.beginPath();
    ctx.arc(px + 16, py + 6, 7, Math.PI, 0);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#3a2a24';
    ctx.fillRect(px + 13, py + 7, 1, 2);
    ctx.fillRect(px + 18, py + 7, 1, 2);
    
    // Exclamation mark if NPC has something important
    if (npcHasExclamation(v)) {
      // Bobbing animation
      const bob = Math.sin(Date.now() / 200) * 2;
      const exX = px + 16;
      const exY = py - 16 + bob;
      
      // Yellow background circle
      ctx.fillStyle = '#ffdd44';
      ctx.beginPath();
      ctx.arc(exX, exY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Black exclamation mark
      ctx.fillStyle = '#222222';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('!', exX, exY);
      ctx.textBaseline = 'alphabetic';
    }
    
    // Show name when player is close
    const dist = Math.abs(player.x - v.x) + Math.abs(player.y - v.y);
    if (dist <= 2) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const nameWidth = ctx.measureText(v.name).width;
      ctx.fillRect(px + 16 - nameWidth/2 - 4, py - 12, nameWidth + 8, 14);
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(v.name, px + 16, py - 2);
      ctx.textAlign = 'left';
    }
  });
}

// Draw festival decorations in the village
function drawFestivalDecorations() {
  if (currentMap !== 'village') return;
  if (!festivalProgress.started || festivalProgress.decorationsPlaced === 0) return;
  
  const decorationSpots = [
    { x: 8, y: 5, type: 'banner' },
    { x: 10, y: 5, type: 'banner' },
    { x: 8, y: 7, type: 'lantern' },
    { x: 10, y: 7, type: 'lantern' },
    { x: 7, y: 6, type: 'garland' },
    { x: 11, y: 6, type: 'garland' }
  ];
  
  const time = Date.now() / 1000;
  
  for (let i = 0; i < festivalProgress.decorationsPlaced && i < decorationSpots.length; i++) {
    const spot = decorationSpots[i];
    const px = spot.x * TILE_SIZE;
    const py = spot.y * TILE_SIZE;
    
    if (spot.type === 'banner') {
      // Colorful yarn banner
      const wave = Math.sin(time * 2 + i) * 2;
      ctx.fillStyle = '#ffd700';
      ctx.fillRect(px + 12, py - 8 + wave, 8, 24);
      ctx.fillStyle = '#ff6b6b';
      ctx.fillRect(px + 12, py - 2 + wave, 8, 8);
      ctx.fillStyle = '#4ecdc4';
      ctx.fillRect(px + 12, py + 8 + wave, 8, 8);
      // Pole
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(px + 14, py - 12, 4, 4);
    } else if (spot.type === 'lantern') {
      // Glowing paper lantern
      const glow = 0.5 + Math.sin(time * 3 + i) * 0.3;
      ctx.fillStyle = `rgba(255, 200, 100, ${glow})`;
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 8, 10, 12, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff8844';
      ctx.beginPath();
      ctx.ellipse(px + 16, py + 8, 7, 9, 0, 0, Math.PI * 2);
      ctx.fill();
      // String
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(px + 16, py - 4);
      ctx.lineTo(px + 16, py);
      ctx.stroke();
    } else if (spot.type === 'garland') {
      // Yarn garland draped
      const sway = Math.sin(time * 1.5 + i * 2) * 3;
      ctx.strokeStyle = '#e066ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(px, py + 4);
      ctx.quadraticCurveTo(px + 16, py + 16 + sway, px + 32, py + 4);
      ctx.stroke();
      // Pom-poms
      ctx.fillStyle = '#ffcc00';
      ctx.beginPath();
      ctx.arc(px + 8, py + 10 + sway/2, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ff66aa';
      ctx.beginPath();
      ctx.arc(px + 24, py + 10 + sway/2, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // If ceremony is active, add extra glow effects
  if (festivalCeremonyActive && festivalCeremonyPhase >= 1) {
    // Ambient golden glow over village center
    const glowIntensity = 0.1 + Math.sin(time * 2) * 0.05;
    ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity})`;
    ctx.fillRect(7 * TILE_SIZE, 5 * TILE_SIZE, 5 * TILE_SIZE, 3 * TILE_SIZE);
  }
}

function drawDialogueUI() {
  if (!dialogueOpen || !currentNPC) return;
  
  const panelW = 340;
  const panelH = 160;
  const panelX = (canvas.width - panelW) / 2;
  const panelY = canvas.height - panelH - 20;

  // Dim background
  ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Panel background
  ctx.fillStyle = 'rgba(6, 12, 26, 0.95)';
  ctx.fillRect(panelX, panelY, panelW, panelH);

  // Border
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX + 0.5, panelY + 0.5, panelW - 1, panelH - 1);

  // Header with NPC name and color
  ctx.fillStyle = currentNPC.color;
  ctx.fillRect(panelX, panelY, panelW, 28);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 14px system-ui';
  ctx.fillText(currentNPC.name, panelX + 12, panelY + 19);

  // Friendship hearts
  const hearts = Math.floor((friendship[currentNPC.id] || 0) / 20);
  ctx.fillStyle = '#ff6b6b';
  ctx.font = '12px system-ui';
  let heartStr = '';
  for (let i = 0; i < 5; i++) {
    heartStr += i < hearts ? 'â™¥' : 'â™¡';
  }
  ctx.fillText(heartStr, panelX + panelW - 75, panelY + 19);

  // Dialogue text - show request if they have one, otherwise normal dialogue
  let text;
  if (currentNPC.request && currentNPC.requestItem) {
    text = currentNPC.request;
  } else {
    text = currentNPC.dialogue[dialogueIndex] || "...";
  }
  ctx.fillStyle = '#f5f7ff';
  ctx.font = '13px system-ui';
  
  // Highlight request text in yellow
  if (currentNPC.request && currentNPC.requestItem) {
    ctx.fillStyle = '#ffdd88';
  }
  
  // Word wrap
  const maxWidth = panelW - 24;
  const words = text.split(' ');
  let line = '';
  let lineY = panelY + 50;
  words.forEach(word => {
    const testLine = line + word + ' ';
    if (ctx.measureText(testLine).width > maxWidth) {
      ctx.fillText(line, panelX + 12, lineY);
      line = word + ' ';
      lineY += 18;
    } else {
      line = testLine;
    }
  });
  ctx.fillText(line, panelX + 12, lineY);

  // Options
  ctx.fillStyle = '#a9b3cd';
  ctx.font = '11px system-ui';
  ctx.fillText('[E] Next  [G] Give Gift  [Esc] Close', panelX + 12, panelY + panelH - 12);
}

function drawGiftMenuUI() {
  if (!giftMenuOpen || !currentNPC) return;
  
  const items = getGiftableItems();
  const panelW = 240;
  const panelH = Math.min(60 + items.length * 24, 200);
  const panelX = (canvas.width - panelW) / 2;
  const panelY = (canvas.height - panelH) / 2;

  // Background
  ctx.fillStyle = 'rgba(6, 12, 26, 0.95)';
  ctx.fillRect(panelX, panelY, panelW, panelH);

  // Border
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
  ctx.lineWidth = 2;
  ctx.strokeRect(panelX + 0.5, panelY + 0.5, panelW - 1, panelH - 1);

  // Header
  ctx.fillStyle = 'rgba(80, 120, 80, 0.9)';
  ctx.fillRect(panelX, panelY, panelW, 28);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 12px system-ui';
  ctx.fillText('Give a Gift', panelX + 12, panelY + 18);

  if (items.length === 0) {
    ctx.fillStyle = '#a9b3cd';
    ctx.font = '11px system-ui';
    ctx.fillText("You have nothing to give.", panelX + 12, panelY + 50);
  } else {
    let itemY = panelY + 44;
    items.forEach((itemKey, index) => {
      const isSelected = index === giftMenuSelection;
      
      if (isSelected) {
        ctx.fillStyle = 'rgba(100, 180, 255, 0.2)';
        ctx.fillRect(panelX + 4, itemY - 12, panelW - 8, 22);
      }
      
      ctx.fillStyle = isSelected ? '#ffffff' : '#a9b3cd';
      ctx.font = '11px system-ui';
      ctx.fillText(`${itemKey} (${inventory[itemKey]})`, panelX + 12, itemY);
      
      itemY += 24;
    });
  }

  // Instructions
  ctx.fillStyle = '#888';
  ctx.font = '9px system-ui';
  ctx.fillText('â†‘â†“ Select | E Give | Esc Cancel', panelX + 12, panelY + panelH - 8);
}

const tileSpriteSources = {
  // Canvas-drawn animated tiles are used for grass (0) and water (3)
  // If you want to use image assets instead, uncomment below:
  // 0: [
  //     { sheet: 'grass1', zoom: () => GRASS_ZOOM },
  //     { sheet: 'grass2', zoom: () => GRASS_ZOOM },
  //     { sheet: 'grass3', zoom: () => GRASS_ZOOM }
  // ],
  // 3: { sheet: 'terrain', row: 3, col: 0 }
};

// Ensure any tile source tweaks take effect
invalidateBaseMaps();

// If pointer mode changes (e.g., plugging in a mouse), adjust grass zoom and rebuild
try {
  const coarseMq = window.matchMedia('(pointer: coarse)');
  coarseMq.addEventListener('change', (e) => {
    GRASS_ZOOM = e.matches ? 0.45 : 0.30;
    invalidateBaseMaps();
  });
} catch (err) {
  // Some browsers donâ€™t support addEventListener on matchMedia; safe to ignore
}

function drawTileFromTileset(tileValue, tileX, tileY, targetCtx = ctx) {
  const entry = tileSpriteSources[tileValue];
  if (!entry) return false;
  const source = Array.isArray(entry)
    ? entry[(tileX + tileY) % entry.length]
    : entry;
  const asset = artAssets[source.sheet];
  if (!asset || !asset.loaded || asset.error) return false;

  const frameW = asset.frameWidth ?? SPRITE_CONFIG.tileSize;
  const frameH = asset.frameHeight ?? SPRITE_CONFIG.tileSize;
  const colIndex = source.col ?? 0;
  const rowIndex = source.row ?? 0;
  let sx = colIndex * frameW;
  let sy = rowIndex * frameH;
  let srcW = frameW;
  let srcH = frameH;

  if (source.crop) {
    sx += source.crop.x ?? 0;
    sy += source.crop.y ?? 0;
    srcW = source.crop.width ?? srcW;
    srcH = source.crop.height ?? srcH;
  } else {
    const zoomValue = typeof source.zoom === 'function' ? source.zoom() : source.zoom;
    if (typeof zoomValue === 'number' && zoomValue > 0 && zoomValue <= 1) {
      srcW = frameW * zoomValue;
      srcH = frameH * zoomValue;
    }
    sx += (frameW - srcW) / 2;
    sy += (frameH - srcH) / 2;
  }

  if (typeof source.offsetX === 'number') sx += source.offsetX;
  if (typeof source.offsetY === 'number') sy += source.offsetY;

  targetCtx.drawImage(
    asset.image,
    sx,
    sy,
    srcW,
    srcH,
    tileX * TILE_SIZE,
    tileY * TILE_SIZE,
    TILE_SIZE,
    TILE_SIZE
  );

  return true;
}

const interactableLocations = [
  {
    map: knittingSpot.map,
    x: knittingSpot.x,
    y: knittingSpot.y,
    label: 'Spinning Wheel',
    helperRange: 1,
    glow: {
      inner: 'rgba(255, 188, 224, 0.9)',
      outer: 'rgba(255, 188, 224, 0)'
    }
  },
  {
    map: marketSpot.map,
    x: marketSpot.x,
    y: marketSpot.y,
    label: 'Village Market',
    helperRange: 1,
    glow: {
      inner: 'rgba(255, 220, 170, 0.85)',
      outer: 'rgba(255, 220, 170, 0)'
    }
  }
];

let fireAnimTick = 0;
let goatAnimTick = 0;
const GOAT_CROP_BOTTOM = 0;
const GOAT_DRAW_OFFSET_Y = 10; // push goat sprite down a bit to clear trees



    let currentMap = 'overworld';
    let MAP_COLS = maps[currentMap].cols;
    let MAP_ROWS = maps[currentMap].rows;
    let mapData  = maps[currentMap].data;

    handleEnvironmentAudio(currentMap);
  ensureBaseMapCanvas(currentMap);



// =========================
// CONFIG & MAPS
// =========================

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false; // keep pixel art crisp

    canvas.addEventListener('pointerdown', ensureMobileAudioUnlock);
    canvas.addEventListener('touchstart', ensureMobileAudioUnlock);
    
    // Handle canvas touch/click for UI elements
    function handleCanvasInteraction(e) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      // Handle both mouse and touch
      let clientX, clientY;
      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      const clickX = (clientX - rect.left) * scaleX;
      const clickY = (clientY - rect.top) * scaleY;
      
      // Handle Tailor Shop touch/click FIRST (highest priority for menus)
      if (tailorShopOpen) {
        const panelW = 320;
        const panelH = 300;
        const panelX = (canvas.width - panelW) / 2;
        const panelY = (canvas.height - panelH) / 2;
        const startY = panelY + 68;
        const itemHeight = 22;
        
        // Check if clicking on an item
        for (let i = 0; i < tailorBuyPrices.length; i++) {
          const itemY = startY + i * itemHeight - 8;
          if (clickX >= panelX + 8 && clickX <= panelX + panelW - 8 &&
              clickY >= itemY && clickY <= itemY + 20) {
            if (i === tailorShopSelection) {
              // Double tap on same item = sell
              sellToTailor();
            } else {
              // Select the item
              tailorShopSelection = i;
            }
            e.preventDefault();
            return;
          }
        }
        
        // Check close area (click outside panel)
        if (clickX < panelX || clickX > panelX + panelW ||
            clickY < panelY || clickY > panelY + panelH) {
          closeTailorShop();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        return;
      }
      
      // Handle Dye Shop touch/click
      if (dyeShopOpen) {
        const panelW = 320;
        const panelH = 260;
        const panelX = (canvas.width - panelW) / 2;
        const panelY = (canvas.height - panelH) / 2;
        const startY = panelY + 55;
        const itemHeight = 32;
        
        // Check if clicking on an item
        for (let i = 0; i < dyeShopTrades.length; i++) {
          const itemY = startY + i * itemHeight - 10;
          if (clickX >= panelX + 8 && clickX <= panelX + panelW - 8 &&
              clickY >= itemY && clickY <= itemY + 28) {
            if (i === dyeShopSelection) {
              // Double tap on same item = trade
              tradeAtDyeShop();
            } else {
              // Select the item
              dyeShopSelection = i;
            }
            e.preventDefault();
            return;
          }
        }
        
        // Check close area (click outside panel)
        if (clickX < panelX || clickX > panelX + panelW ||
            clickY < panelY || clickY > panelY + panelH) {
          closeDyeShop();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        return;
      }
      
      // Handle Merchant Shop touch/click
      if (merchantShopOpen) {
        const panelW = 300;
        const panelH = 220;
        const panelX = (canvas.width - panelW) / 2;
        const panelY = (canvas.height - panelH) / 2;
        const startY = panelY + 55;
        const itemHeight = 24;
        
        // Check if clicking on an item
        for (let i = 0; i < merchantStock.length; i++) {
          const itemY = startY + i * itemHeight - 12;
          if (clickX >= panelX + 8 && clickX <= panelX + panelW - 8 &&
              clickY >= itemY && clickY <= itemY + 22) {
            if (i === merchantShopSelection) {
              // Double tap on same item = buy
              buyFromMerchant();
            } else {
              // Select the item
              merchantShopSelection = i;
            }
            e.preventDefault();
            return;
          }
        }
        
        // Check close area (click outside panel)
        if (clickX < panelX || clickX > panelX + panelW ||
            clickY < panelY || clickY > panelY + panelH) {
          closeMerchantShop();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        return;
      }
      
      // Handle Farm Shop touch/click
      if (farmShopOpen) {
        const panelW = 340;
        const panelH = 280;
        const panelX = (canvas.width - panelW) / 2;
        const panelY = (canvas.height - panelH) / 2;
        const startY = panelY + 75;
        const itemHeight = 26;
        
        // Check if clicking on an item (accounting for category headers)
        let itemY = startY;
        let lastCategory = '';
        for (let i = 0; i < farmShopItems.length; i++) {
          const item = farmShopItems[i];
          // Add spacing for animal header
          if (item.category === 'animal' && lastCategory !== 'animal') {
            itemY += 24;
          }
          lastCategory = item.category;
          
          if (clickX >= panelX + 8 && clickX <= panelX + panelW - 8 &&
              clickY >= itemY - 10 && clickY <= itemY + 16) {
            if (i === farmShopSelection) {
              // Double tap on same item = buy
              buyFromFarmShop();
            } else {
              // Select the item
              farmShopSelection = i;
            }
            e.preventDefault();
            return;
          }
          itemY += itemHeight;
        }
        
        // Check close area (click outside panel)
        if (clickX < panelX || clickX > panelX + panelW ||
            clickY < panelY || clickY > panelY + panelH) {
          closeFarmShop();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        return;
      }
      
      // Handle intro screen clicks
      if (!introDone) {
        if (introState === 'welcome' && window.welcomeBtnRect) {
          const btn = window.welcomeBtnRect;
          if (clickX >= btn.x && clickX <= btn.x + btn.w && 
              clickY >= btn.y && clickY <= btn.y + btn.h) {
            introState = 'dialogue';
            return;
          }
        } else if (introState === 'dialogue') {
          completeIntro();
          return;
        }
      }
      
      const isMobile = isCoarsePointer || showOverlayMode;
      const btnX = 8;
      const btnY = 54;
      const btnW = isMobile ? 36 : 32;
      const btnH = isMobile ? 36 : 32;
      
      // Check if clicked on task board button (when minimized or closed)
      if (taskBoardMinimized || !taskBoardOpen) {
        if (clickX >= btnX && clickX <= btnX + btnW && 
            clickY >= btnY && clickY <= btnY + btnH) {
          toggleTaskBoard();
          return;
        }
      }
      
      // Check if clicked on close button (when open)
      if (taskBoardOpen && !taskBoardMinimized) {
        const panelW = isMobile ? 160 : 220;
        const closeBtnSize = isMobile ? 22 : 20;
        const closeBtnX = btnX + panelW - closeBtnSize - 2;
        const closeBtnY = btnY + (isMobile ? 1 : 4);
        if (clickX >= closeBtnX && clickX <= closeBtnX + closeBtnSize && 
            clickY >= closeBtnY && clickY <= closeBtnY + closeBtnSize) {
          taskBoardOpen = false;
          return;
        }
      }
    }
    
    // Add both click and touch handlers for maximum compatibility
    canvas.addEventListener('click', handleCanvasInteraction);
    canvas.addEventListener('touchstart', handleCanvasInteraction, { passive: false });

 // #endregion CONFIG & MAPS   <-- move it to HERE


 // =========================
// GAME STATE
// =========================
// #region GAME_STATE

// 0 = early game, just shearing + knitting
// 1 = unlocked selling scarves at the stall
let questStage = 0;

// #endregion GAME_STATE


// =========================
// PLAYER
// =========================
// #region PLAYER
    const player = {
      x: 9,             // logical tile coords (overworld start)
      y: 10,
      speed: 4,         // pixels per frame
      px: 9 * TILE_SIZE,
      py: 10 * TILE_SIZE,
      moving: false,
      nextX: null,
      nextY: null,
      targetPx: null,
      targetPy: null,
      dir: 'down',
      spriteFrame: SPRITE_CONFIG.player.idleFrameIndex,
      spriteTick: 0
    };

    function switchMap(name, spawnX, spawnY) {
      currentMap = name;
      MAP_COLS = maps[name].cols;
      MAP_ROWS = maps[name].rows;
      mapData  = maps[name].data;

      player.x = spawnX;
      player.y = spawnY;
      player.px = spawnX * TILE_SIZE;
      player.py = spawnY * TILE_SIZE;
      player.moving = false;

      handleEnvironmentAudio(name);
      ensureBaseMapCanvas(name);
      currentInteractables = getInteractablesForMap(name);
      updateHelperLabelState(currentInteractables, true);
    }

    // Check if player walked off edge of map - automatic transitions
    function checkMapEdgeTransition() {
      // Overworld bottom edge (row 12) -> Village top
      if (currentMap === 'overworld' && player.y >= MAP_ROWS - 1) {
        if (player.x >= 8 && player.x <= 10) {
          switchMap('village', player.x, 1);
          showMessage('You head south to The Village.');
          return;
        }
      }
      
      // Village top edge (row 0) -> Overworld bottom
      if (currentMap === 'village' && player.y <= 0) {
        if (player.x >= 8 && player.x <= 10) {
          switchMap('overworld', player.x, MAP_ROWS - 2);
          showMessage("You return to Yarnya's Farm.");
          return;
        }
      }
      
      // Track village visit for task board
      if (currentMap === 'village' && !taskProgress.visitedVillage) {
        taskProgress.visitedVillage = true;
      }
      
      // Village right edge (col 18) -> Forest left
      if (currentMap === 'village' && player.x >= MAP_COLS - 1) {
        if (player.y >= 11 && player.y <= 12) {
          switchMap('forest', 1, player.y - 10);
          showMessage('You enter the forest.');
          return;
        }
      }
      
      // Forest left edge (col 0) -> Village right
      if (currentMap === 'forest' && player.x <= 0) {
        if (player.y >= 1 && player.y <= 2) {
          switchMap('village', MAP_COLS - 2, player.y + 10);
          showMessage('You return to The Village.');
          return;
        }
      }
      
      // Forest right edge (col 18) -> Wetlands left
      if (currentMap === 'forest' && player.x >= MAP_COLS - 1) {
        if (player.y >= 4 && player.y <= 8) {
          switchMap('wetlands', 1, 6);
          showMessage('You enter the misty marshes...');
          return;
        }
      }
      
      // Wetlands left edge (col 0) -> Forest right
      if (currentMap === 'wetlands' && player.x <= 0) {
        if (player.y >= 5 && player.y <= 7) {
          switchMap('forest', MAP_COLS - 2, 6);
          showMessage('You return to the forest.');
          return;
        }
      }
      
      // Wetlands top edge (row 0) -> Mountain bottom (if unlocked)
      if (currentMap === 'wetlands' && player.y <= 0) {
        if (player.x >= 7 && player.x <= 10) {
          if (canAccessMap('mountain')) {
            switchMap('mountain', 9, MAP_ROWS - 2);
            showMessage('You climb up the mountain path from the marshes.');
          } else {
            showMessage('The mountain path is blocked by fallen rocks. Perhaps with more crafting skill...');
            player.y = 1; // Push back
          }
          return;
        }
      }
      
      // Wetlands bottom edge (row 12) -> Forest entrance
      if (currentMap === 'wetlands' && player.y >= MAP_ROWS - 1) {
        if (player.x >= 7 && player.x <= 10) {
          switchMap('forest', 14, 1);
          showMessage('You head back through the southern path.');
          return;
        }
      }
      
      // Forest top edge (row 0) -> Mountain bottom (if unlocked) - direct path still available
      if (currentMap === 'forest' && player.y <= 0) {
        if (player.x >= 8 && player.x <= 10) {
          if (canAccessMap('mountain')) {
            switchMap('mountain', player.x, MAP_ROWS - 2);
            showMessage('You climb up the mountain path.');
          } else {
            showMessage('The mountain path is blocked by fallen rocks. Perhaps with more crafting skill...');
            player.y = 1; // Push back
          }
          return;
        }
      }
      
      // Mountain bottom edge -> Forest top or Wetlands (depending on exit point)
      if (currentMap === 'mountain' && player.y >= MAP_ROWS - 1) {
        if (player.x >= 8 && player.x <= 10) {
          switchMap('forest', player.x, 1);
          showMessage('You descend back to the forest.');
          return;
        }
      }
      
      // Beach left edge (col 0) -> Village (if unlocked via path tiles)
      if (currentMap === 'beach' && player.x <= 0) {
        if (player.y >= 5 && player.y <= 7) {
          switchMap('village', MAP_COLS - 2, 6);
          showMessage('You return to The Village.');
          return;
        }
      }
      
      // Village - path to beach (specific location near bottom right)
      // The beach path opens when villagers are helped
      if (currentMap === 'village' && player.x >= MAP_COLS - 1) {
        if (player.y >= 5 && player.y <= 7) {
          if (canAccessMap('beach')) {
            switchMap('beach', 1, 6);
            showMessage('You follow the sandy path to the beach.');
          } else {
            showMessage('The path to the beach is overgrown. Help more villagers to clear it!');
          }
          return;
        }
      }
      
      // Mountain cave entrance (tile 26 at position 9,3)
      if (currentMap === 'mountain' && player.x === 9 && player.y === 3) {
        if (canAccessMap('cave')) {
          switchMap('cave', 9, 10);
          showMessage('You enter the mysterious cave...');
        } else {
          showMessage('The cave entrance is sealed. You need the Beach Crystal Shard.');
        }
        return;
      }
      
      // Cave exit (door tile at bottom)
      if (currentMap === 'cave' && player.y >= MAP_ROWS - 2 && player.x === 9) {
        // Check if on door tile (6)
        const tile = mapData[player.y][player.x];
        if (tile === 6) {
          switchMap('mountain', 9, 4);
          showMessage('You exit the cave.');
          return;
        }
      }
    }

    currentInteractables = getInteractablesForMap(currentMap);
    updateHelperLabelState(currentInteractables, true);

// #endregion PLAYER


// =========================
// INPUT
// =========================
// #region INPUT

const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  w: false,
  a: false,
  s: false,
  d: false,
};

const touchDirections = {
  up: false,
  down: false,
  left: false,
  right: false
};

function showDebugStatus(text) {
  debugState.statusMessage = text;
  debugState.statusUntil = performance.now() + 2200;
}

function toggleDebugFlag(flag, label) {
  debugState[flag] = !debugState[flag];
  showDebugStatus(`${label}: ${debugState[flag] ? 'ON' : 'OFF'}`);
}

function handleDebugKeyToggle(event) {
  // Ctrl+Shift+D to toggle debug unlock all areas
  if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 'd') {
    debugUnlockAll = !debugUnlockAll;
    showDebugStatus(`Debug: All areas ${debugUnlockAll ? 'UNLOCKED' : 'locked'}`);
    showMessage(debugUnlockAll ? 'ðŸ”“ Debug: All areas unlocked!' : 'ðŸ”’ Debug: Area locks restored.');
    event.preventDefault();
    return true;
  }
  
  // Ctrl+Shift+S to show story progress
  if (event.ctrlKey && event.shiftKey && event.key.toLowerCase() === 's') {
    const progress = `Story: Ch${storyProgress.chapter} | Helped: ${storyProgress.villagersHelped} | Crafted: ${storyProgress.itemsCrafted} | Shards: ${storyProgress.shardsFound}/3`;
    showDebugStatus(progress);
    showMessage(progress);
    event.preventDefault();
    return true;
  }
  
  switch (event.key) {
    case 'F2':
      toggleDebugFlag('info', 'Debug info');
      event.preventDefault();
      return true;
    case 'F3':
      toggleDebugFlag('grid', 'Grid overlay');
      event.preventDefault();
      return true;
    case 'F4':
      toggleDebugFlag('collisions', 'Collision overlay');
      event.preventDefault();
      return true;
    default:
      return false;
  }
}

window.addEventListener('keydown', (e) => {
  if (handleDebugKeyToggle(e)) {
    return;
  }
  // Normalize single-character keys to lowercase so CapsLock/Shift don't break controls
  let key = e.key;
  if (key.length === 1) key = key.toLowerCase();

  // Handle fishing mini-game (takes priority over most menus)
  if (fishingActive) {
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      handleFishingInput('action');
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      handleFishingInput('cancel');
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle loom attune mini-game
  if (loomAttuneActive) {
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      handleLoomAttuneInput('action');
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      handleLoomAttuneInput('cancel');
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle knitting sprint mini-game
  if (knittingSprintActive) {
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      handleKnittingSprintInput('action');
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      handleKnittingSprintInput('cancel');
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle festival menu
  if (festivalMenuOpen) {
    if (e.key === 'ArrowUp' || key === 'w') {
      handleFestivalMenuInput('w');
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      handleFestivalMenuInput('s');
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      handleFestivalMenuInput('e');
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeFestivalMenu();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle gift menu
  if (giftMenuOpen) {
    const items = getGiftableItems();
    if (e.key === 'ArrowUp' || key === 'w') {
      giftMenuSelection = Math.max(0, giftMenuSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      giftMenuSelection = Math.min(items.length - 1, giftMenuSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      giveSelectedGift();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeGiftMenu();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle merchant shop
  if (merchantShopOpen) {
    if (e.key === 'ArrowUp' || key === 'w') {
      merchantShopSelection = Math.max(0, merchantShopSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      merchantShopSelection = Math.min(merchantStock.length - 1, merchantShopSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      purchaseFromMerchant();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeMerchantShop();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle dye shop
  if (dyeShopOpen) {
    if (e.key === 'ArrowUp' || key === 'w') {
      dyeShopSelection = Math.max(0, dyeShopSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      dyeShopSelection = Math.min(dyeShopTrades.length - 1, dyeShopSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      tradeAtDyeShop();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeDyeShop();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle tailor shop
  if (tailorShopOpen) {
    if (e.key === 'ArrowUp' || key === 'w') {
      tailorShopSelection = Math.max(0, tailorShopSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      tailorShopSelection = Math.min(tailorBuyPrices.length - 1, tailorShopSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      sellToTailor();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeTailorShop();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle farm shop
  if (farmShopOpen) {
    if (e.key === 'ArrowUp' || key === 'w') {
      farmShopSelection = Math.max(0, farmShopSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      farmShopSelection = Math.min(farmShopItems.length - 1, farmShopSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      buyFromFarmShop();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeFarmShop();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle fast travel menu
  if (fastTravelOpen) {
    const destinations = getAvailableFastTravelDestinations();
    if (e.key === 'ArrowUp' || key === 'w') {
      fastTravelSelection = Math.max(0, fastTravelSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      fastTravelSelection = Math.min(destinations.length - 1, fastTravelSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      executeFastTravel();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeFastTravel();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle orders board
  if (ordersBoardOpen) {
    // Tab switching with A/D
    if (e.key === 'ArrowLeft' || key === 'a') {
      ordersBoardTab = 'daily';
      ordersBoardSelection = 0;
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowRight' || key === 'd') {
      ordersBoardTab = 'weekly';
      ordersBoardSelection = 0;
      e.preventDefault();
      return;
    }
    // Selection with W/S
    if (e.key === 'ArrowUp' || key === 'w') {
      if (ordersBoardTab === 'daily') {
        ordersBoardSelection = Math.max(0, ordersBoardSelection - 1);
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      if (ordersBoardTab === 'daily') {
        ordersBoardSelection = Math.min(dailyOrders.length - 1, ordersBoardSelection + 1);
      }
      e.preventDefault();
      return;
    }
    // Complete order with E
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      tryCompleteSelectedOrder();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      closeOrdersBoard();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle build mode
  if (buildModeActive) {
    if (e.key === 'ArrowUp' || key === 'w') {
      moveBuildCursor(0, -1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      moveBuildCursor(0, 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowLeft' || key === 'a') {
      moveBuildCursor(-1, 0);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowRight' || key === 'd') {
      moveBuildCursor(1, 0);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      placeBuildItem();
      e.preventDefault();
      return;
    }
    if (key === 'q') {
      switchBuildItem();
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape') {
      exitBuildMode();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle dialogue
  if (dialogueOpen) {
    if (e.key === 'Escape') {
      closeDialogue();
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space') {
      advanceDialogue();
      e.preventDefault();
      return;
    }
    if (key === 'g') {
      openGiftMenu();
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // Handle crafting menu navigation
  if (craftingMenuOpen) {
    const availableRecipes = getAvailableRecipes();
    if (e.key === 'ArrowUp' || key === 'w') {
      craftingMenuSelection = Math.max(0, craftingMenuSelection - 1);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowDown' || key === 's') {
      craftingMenuSelection = Math.min(availableRecipes.length - 1, craftingMenuSelection + 1);
      e.preventDefault();
      return;
    }
    if (key === 'e' || e.code === 'Space' || e.key === 'Enter') {
      // Craft selected recipe
      const recipe = availableRecipes[craftingMenuSelection];
      if (canAffordRecipe(recipe)) {
        // Check if this will trigger the knitting sprint
        if (recipe.sellPrice && recipe.sellPrice > 0) {
          // Knitting sprint handles the crafting
          craftRecipe(recipe);
        } else {
          // Normal crafting
          craftRecipe(recipe);
          showMessage(`Crafted ${getRecipeOutputsText(recipe)}!`);
          if (sounds.knit) sounds.knit.play().catch(() => {});
        }
      } else {
        showMessage(`Not enough materials for ${recipe.name}.`);
      }
      e.preventDefault();
      return;
    }
    if (e.key === 'Escape' || key === 'q') {
      craftingMenuOpen = false;
      e.preventDefault();
      return;
    }
    if (key === 'i') {
      // Switch from crafting menu to inventory
      craftingMenuOpen = false;
      inventoryOpen = true;
      e.preventDefault();
      return;
    }
    e.preventDefault();
    return;
  }

  // movement keys
  if (key in keys) {
    keys[key] = true;
    e.preventDefault();
  }

  // toggle inventory with I or Esc
  if (key === 'i') {
    inventoryOpen = !inventoryOpen;
    e.preventDefault();
  }
  
  // toggle task board with T
  if (key === 't' && !inventoryOpen && !craftingMenuOpen && !dialogueOpen) {
    toggleTaskBoard();
    e.preventDefault();
  }
  
  // toggle build mode with B (only on overworld with building materials)
  if (key === 'b' && !inventoryOpen && !craftingMenuOpen && !dialogueOpen && !farmShopOpen && !tailorShopOpen && !dyeShopOpen && !merchantShopOpen) {
    if (currentMap === 'overworld') {
      toggleBuildMode();
      e.preventDefault();
    } else {
      showMessage("You can only build on your farm!");
    }
  }
  
  if (e.key === 'Escape') {
    if (optionsMenuOpen) {
      closeOptionsMenu();
      e.preventDefault();
      return;
    }
    if (inventoryOpen) {
      inventoryOpen = false;
    }
    e.preventDefault();
  }

  // Save/Load shortcuts
  if (e.key === 'F5') {
    saveGame();
    e.preventDefault();
    return;
  }
  if (e.key === 'F9') {
    loadGame();
    e.preventDefault();
    return;
  }

  // Fishing shortcut (F key on beach near water)
  if (key === 'f' && !inventoryOpen && !dialogueOpen && !craftingMenuOpen) {
    if (canStartFishing()) {
      startFishing();
      e.preventDefault();
      return;
    }
  }

  // action key: E or Space (only when inventory is closed)
  // use e.code for Space to be robust across browser key naming
  if ((key === 'e' || e.code === 'Space') && !inventoryOpen) {
    handleAction();
    e.preventDefault();
  }
});

window.addEventListener('keyup', (e) => {
  // Normalize single-character keys on keyup as well
  let key = e.key;
  if (key.length === 1) key = key.toLowerCase();

  if (key in keys) {
    keys[key] = false;
    e.preventDefault();
  }
});

// Clear input state if the window loses focus so keys don't get stuck
window.addEventListener('blur', () => {
  for (const k in keys) keys[k] = false;
});

// #endregion INPUT



// =========================
// HELPERS
// =========================
// #region HELPERS

function showMessage(text, durationMs = 3500) {
  message = text;
  // set expiry time based on current timestamp
  messageExpiryTime = performance.now() + durationMs;
}


    function isSolidTile(tx, ty) {
      if (tx < 0 || ty < 0 || tx >= MAP_COLS || ty >= MAP_ROWS) return true;
      const t = mapData[ty][tx];
      // Solid tiles: trees(2), water(3), fences(4), interior walls(7), 
      // market stall(10), well(11), ocean(17), rock(19), palm tree(21), 
      // tide pool(22), cliff(23), signpost(29), swamp water(31)
      if (t === 2 || t === 3 || t === 4 || t === 7 || t === 10 || t === 11 ||
          t === 17 || t === 19 || t === 21 || t === 22 || t === 23 || t === 29 || t === 31) return true;
      
      // Check for cottage furniture collision
      if (currentMap === 'cottage') {
        // Crafting table
        if (tx === knittingSpot.x && ty === knittingSpot.y) return true;
        // Spinning wheel / Loom
        if (tx === loomSpot.x && ty === loomSpot.y) return true;
        // Fireplace
        if (tx === fireplaceSpot.x && ty === fireplaceSpot.y) return true;
        // Other furniture (armchair, bookshelf, chest)
        for (const item of cottageFurniture) {
          if (item.map === 'cottage' && tx === item.x && ty === item.y) return true;
        }
      }
      
      // Check for sheep collision
      if (currentMap === sheep.map && tx === sheep.x && ty === sheep.y) return true;
      
      // Check for sheep2 collision
      if (currentMap === sheep2.map && tx === sheep2.x && ty === sheep2.y) return true;
      
      // Check for goat collision
      if (currentMap === goat.map && tx === goat.x && ty === goat.y) return true;
      
      // Check for peacock collision
      if (currentMap === peacock.map && tx === peacock.x && ty === peacock.y) return true;
      
      // Check for villager collisions
      for (const npc of villagers) {
        if (npc.map === currentMap && tx === npc.x && ty === npc.y) return true;
      }
      
      // Check for traveling merchant collision
      if (travelingMerchant.isPresent && currentMap === travelingMerchant.map && 
          tx === travelingMerchant.x && ty === travelingMerchant.y) return true;
      
      // Check for purchased animals collision
      for (const animal of purchasedAnimals) {
        if (animal.map === currentMap && tx === animal.x && ty === animal.y) return true;
      }
      
      return false;
    }

   function tryStartMove(dx, dy) {
  if (player.moving) return;

  const targetX = player.x + dx;
  const targetY = player.y + dy;
  if (isSolidTile(targetX, targetY)) return;

  // Start movement
  player.nextX = targetX;
  player.nextY = targetY;
  player.targetPx = targetX * TILE_SIZE;
  player.targetPy = targetY * TILE_SIZE;
  player.moving = true;

  // Play footstep SFX (ignore autoplay policy failures)
  playFootstepSound();

  // Update facing direction
  if (dx === 1)  player.dir = 'right';
  if (dx === -1) player.dir = 'left';
  if (dy === 1)  player.dir = 'down';
  if (dy === -1) player.dir = 'up';
}


    function handleKnitting() {
  // Open the crafting menu instead of auto-crafting
  craftingMenuOpen = true;
  craftingMenuSelection = 0;
  inventoryOpen = false; // Close inventory if open
  // Show back button on mobile
  if (touchBackButton) touchBackButton.classList.add('visible');
}

function handleMarket() {
  // Find all sellable items (recipes with sellPrice) and sort by value descending
  const sellableItems = craftingRecipes
    .filter(r => r.sellPrice && r.outputs)
    .map(r => {
      const outputKey = Object.keys(r.outputs)[0];
      return { 
        key: outputKey, 
        name: r.name, 
        price: r.sellPrice,
        count: inventory[outputKey] || 0
      };
    })
    .filter(item => item.count > 0)
    .sort((a, b) => b.price - a.price);

  if (sellableItems.length > 0) {
    // Sell the highest value item
    const item = sellableItems[0];
    inventory[item.key] -= 1;
    
    // Calculate friendship bonus (up to 25% extra gold based on average friendship)
    const friendshipValues = Object.values(friendship);
    const avgFriendship = friendshipValues.length > 0 
      ? friendshipValues.reduce((a, b) => a + b, 0) / friendshipValues.length 
      : 0;
    const friendshipBonus = Math.floor(item.price * (avgFriendship / FRIENDSHIP_MAX) * 0.25);
    
    // Check for Knitting Sprint bonus
    let sprintBonus = 0;
    if (sprintBonusItems[item.key] && sprintBonusItems[item.key] > 0) {
      sprintBonus = 1;
      sprintBonusItems[item.key]--;
    }
    
    const totalPrice = item.price + friendshipBonus + sprintBonus;
    
    inventory.gold += totalPrice;
    
    let bonusText = '';
    if (friendshipBonus > 0 && sprintBonus > 0) {
      bonusText = ` (+${friendshipBonus} reputation, +${sprintBonus} sprint bonus)`;
    } else if (friendshipBonus > 0) {
      bonusText = ` (+${friendshipBonus} reputation bonus)`;
    } else if (sprintBonus > 0) {
      bonusText = ` (+${sprintBonus} sprint bonus!)`;
    }
    
    showMessage(`Sold ${item.name} for ${totalPrice} gold${bonusText}`);
    if (sounds.sell) sounds.sell.play().catch(() => {});
    return;
  }

  // Nothing to sell - helpful message
  const hasMaterials = inventory.yarn > 0 || inventory.wool > 0 || inventory.goatFur > 0 || inventory.luxuryYarn > 0;
  if (hasMaterials) {
    showMessage('Craft your materials into items first! Visit the spinning wheel in your cottage.');
  } else {
    showMessage('The Village Market awaits your wares. Craft some items to sell!');
  }
}


    function handleAction() {
  if (player.moving) return; // ignore actions while sliding between tiles
  const tile = mapData[player.y][player.x];

  // Check for forageable items at player position
  const forageable = getForageableAt(currentMap, player.x, player.y);
  if (forageable) {
    collectForageable(forageable);
    return;
  }

  // Crystal shard collection (tile 27)
  if (tile === 27) {
    let shardLocation = null;
    if (currentMap === 'beach') shardLocation = 'beach';
    else if (currentMap === 'mountain') shardLocation = 'mountain';
    else if (currentMap === 'cave') shardLocation = 'cave';
    
    if (shardLocation && !storyProgress.shards[shardLocation]) {
      collectCrystalShard(shardLocation);
      // Replace the crystal tile with the base terrain
      const baseTile = currentMap === 'beach' ? 16 : 
                       currentMap === 'mountain' ? 25 : 8;
      mapData[player.y][player.x] = baseTile;
      invalidateBaseMaps(); // Redraw the map
      return;
    } else if (shardLocation && storyProgress.shards[shardLocation]) {
      showMessage('You already collected the crystal shard from here.');
      return;
    }
  }

  // Doors between overworld and cottage
  if (currentMap === 'overworld' && tile === 6) {
    switchMap('cottage', 4, 4);
    showMessage("You step into your cosy cottage.");
    return;
  } else if (currentMap === 'cottage' && tile === 6) {
    switchMap('overworld', 9, 4);
    showMessage("You head back out to Yarnya's Farm.");
    return;
  } else if (currentMap === 'cave' && tile === 6) {
    switchMap('mountain', 9, 4);
    showMessage('You exit the cave.');
    return;
  }

  // Signpost interaction - check if adjacent to a signpost
  const signpost = signpostLocations[currentMap];
  if (signpost) {
    const dx = Math.abs(player.x - signpost.x);
    const dy = Math.abs(player.y - signpost.y);
    if (dx + dy === 1 || (dx === 1 && dy === 1)) {
      // Unlock this signpost if not already
      if (!signpost.unlocked) {
        unlockSignpost(currentMap);
      }
      // Open fast travel menu
      openFastTravel();
      return;
    }
  }

  // Orders board interaction (at the market stall in village)
  if (isNearOrdersBoard()) {
    openOrdersBoard();
    return;
  }

  // Check for NPC interaction
  for (const npc of villagers) {
    if (npc.map !== currentMap) continue;
    const dx = Math.abs(player.x - npc.x);
    const dy = Math.abs(player.y - npc.y);
    if (dx + dy === 1) {
      openDialogue(npc);
      return;
    }
  }

  // Check for traveling merchant interaction
  if (travelingMerchant.isPresent && currentMap === travelingMerchant.map) {
    const dx = Math.abs(player.x - travelingMerchant.x);
    const dy = Math.abs(player.y - travelingMerchant.y);
    if (dx + dy === 1) {
      openMerchantShop();
      return;
    }
  }

  // Knitting spot â€“ only in cottage (adjacent to crafting table)
  if (isNearCraftingTable()) {
    handleKnitting();
    return;
  }

  // Crystal Loom â€“ only in cottage (for attunement mini-game)
  if (isNearLoom()) {
    startLoomAttune();
    return;
  }

  // Market stall â€“ only in overworld
  if (currentMap === marketSpot.map &&
      player.x === marketSpot.x &&
      player.y === marketSpot.y) {
    handleMarket();
    return;
  }

  // Sheep interaction â€“ only in overworld
  if (currentMap === 'overworld' && sheep.map === 'overworld') {
    const dx = Math.abs(player.x - sheep.x);
    const dy = Math.abs(player.y - sheep.y);

    // player must stand next to the sheep (N/S/E/W)
    if (dx + dy === 1) {
      if (sheep.hasWool) {
        sheep.hasWool = false;
        sheep.woolTimer = 0;
        inventory.wool += 1;
        showMessage('You gently shear the sheep and collect a bundle of soft wool.');
        
        // Play shearing sound
        if (sounds.shear) {
          sounds.shear.currentTime = 0;
          sounds.shear.play().catch(() => {});
        }
        
        // Play a random sheep sound
        const sfx = sheepSounds[Math.floor(Math.random() * sheepSounds.length)];
        sfx.currentTime = 0;
        sfx.play().catch(() => {});
      } else {
        showMessage('This sheep has already been shorn. Give its wool time to grow back.');
      }
    }
  }

  // Sheep2 interaction â€“ only in overworld
  if (currentMap === 'overworld' && sheep2.map === 'overworld') {
    const dx = Math.abs(player.x - sheep2.x);
    const dy = Math.abs(player.y - sheep2.y);

    // player must stand next to the sheep (N/S/E/W)
    if (dx + dy === 1) {
      if (sheep2.hasWool) {
        sheep2.hasWool = false;
        sheep2.woolTimer = 0;
        inventory.wool += 1;
        showMessage('You gently shear the sheep and collect a bundle of soft wool.');
        
        // Play shearing sound
        if (sounds.shear) {
          sounds.shear.currentTime = 0;
          sounds.shear.play().catch(() => {});
        }
        
        // Play a random sheep sound
        const sfx = sheepSounds[Math.floor(Math.random() * sheepSounds.length)];
        sfx.currentTime = 0;
        sfx.play().catch(() => {});
      } else {
        showMessage('This sheep has already been shorn. Give its wool time to grow back.');
      }
    }
  }

  // Goat interaction â€“ only in overworld
  if (currentMap === 'overworld' && goat.map === 'overworld') {
    const dx = Math.abs(player.x - goat.x);
    const dy = Math.abs(player.y - goat.y);
    if (dx + dy === 1) {
      if (goat.hasFur) {
        goat.hasFur = false;
        goat.furTimer = 0;
        inventory.goatFur += 1;
        showMessage('You carefully shear the goat and collect a bundle of soft goat fur.');
        if (sounds.shear) {
          sounds.shear.currentTime = 0;
          sounds.shear.play().catch(() => {});
        }
      } else {
        showMessage('This goat has already been shorn. Let its fur grow back.');
      }
    }
  }

  // Peacock interaction â€“ only in overworld
  if (currentMap === 'overworld' && peacock.map === 'overworld') {
    const dx = Math.abs(player.x - peacock.x);
    const dy = Math.abs(player.y - peacock.y);
    if (dx + dy === 1) {
      if (peacock.hasFeathers) {
        peacock.hasFeathers = false;
        peacock.featherTimer = 0;
        inventory.feather += 2; // Peacocks give 2 feathers
        trackFestivalMaterial('feather', 2);
        showMessage('You collect beautiful iridescent feathers from the peacock!');
        if (sounds.shear) {
          sounds.shear.currentTime = 0;
          sounds.shear.play().catch(() => {});
        }
      } else {
        showMessage("The peacock's tail feathers need time to regrow.");
      }
    }
  }

  // Purchased animals interaction - only in overworld
  if (currentMap === 'overworld') {
    for (const animal of purchasedAnimals) {
      if (animal.map !== 'overworld') continue;
      
      const dx = Math.abs(player.x - animal.x);
      const dy = Math.abs(player.y - animal.y);
      
      if (dx + dy === 1) {
        if (animal.hasResource) {
          animal.hasResource = false;
          animal.resourceTimer = 0;
          
          // Give resource based on animal type
          let resourceMessage = '';
          if (animal.type === 'sheep') {
            inventory.wool += 1;
            resourceMessage = 'You gently shear the sheep and collect soft wool.';
          } else if (animal.type === 'llama') {
            inventory.luxuryYarn = (inventory.luxuryYarn || 0) + 1;
            resourceMessage = 'The llama yields luxurious fine wool!';
          } else if (animal.type === 'rabbit') {
            inventory.goatFur += 1; // Using goatFur for soft fur for now
            resourceMessage = 'You collect soft fur from the rabbit!';
          } else if (animal.type === 'extraGoat') {
            inventory.goatFur += 1;
            resourceMessage = 'You shear the goat and collect soft fur.';
          }
          
          showMessage(resourceMessage);
          if (sounds.shear) {
            sounds.shear.currentTime = 0;
            sounds.shear.play().catch(() => {});
          }
        } else {
          const waitMessages = {
            sheep: "This sheep's wool is still growing back.",
            llama: "The llama needs more time to grow its fleece.",
            rabbit: "The rabbit's fur isn't ready yet.",
            extraGoat: "This goat needs time to regrow its fur."
          };
          showMessage(waitMessages[animal.type] || "This animal isn't ready yet.");
        }
        return; // Only interact with one animal at a time
      }
    }
  }
}


// #endregion HELPERS

// =========================
// UPDATE
// =========================
// #region UPDATE

function update() {
  fireAnimTick = (fireAnimTick + 1) % 100000;
  goatAnimTick = (goatAnimTick + 1) % 100000;
  updateHelperLabelState(currentInteractables);
  
  // Update NPC movement
  updateNPCMovement();
  
  // Update traveling merchant spawn/despawn
  updateTravelingMerchant();
  
  // Update forageable respawn timers
  updateForageables();
  
  // Update purchased animals
  updatePurchasedAnimals();
  
  // Update fishing mini-game
  updateFishing();
  
  // Update loom attune mini-game
  updateLoomAttune();
  
  // Update knitting sprint mini-game
  updateKnittingSprint();
  
  // --- Smooth tile movement ---
  if (player.moving) {
    const remX = player.targetPx - player.px;
    const remY = player.targetPy - player.py;

    const moveX = Math.sign(remX) * Math.min(Math.abs(remX), player.speed);
    const moveY = Math.sign(remY) * Math.min(Math.abs(remY), player.speed);

    player.px += moveX;
    player.py += moveY;

    // clamp and finish move when both axes reached target
    if (player.px === player.targetPx && player.py === player.targetPy) {
      player.moving = false;
      // Commit the logical tile only when we fully arrive to avoid mid-step interactions.
      if (typeof player.nextX === 'number' && typeof player.nextY === 'number') {
        player.x = player.nextX;
        player.y = player.nextY;
      }
      player.nextX = null;
      player.nextY = null;
      
      // Check for edge-based map transitions
      checkMapEdgeTransition();
    }
    } else {
    let dx = 0;
    let dy = 0;

    // don't allow movement while menus are open or in build mode
    const anyMenuOpen = inventoryOpen || optionsMenuOpen || merchantShopOpen || dyeShopOpen || tailorShopOpen || farmShopOpen || fastTravelOpen || ordersBoardOpen || dialogueOpen || giftMenuOpen || buildModeActive || loomAttuneActive || fishingActive || knittingSprintActive || festivalMenuOpen;
    if (!anyMenuOpen) {
      if (keys.ArrowUp || keys.w || touchDirections.up) {
        dy = -1;
        player.dir = 'up';
      } else if (keys.ArrowDown || keys.s || touchDirections.down) {
        dy = 1;
        player.dir = 'down';
      } else if (keys.ArrowLeft || keys.a || touchDirections.left) {
        dx = -1;
        player.dir = 'left';
      } else if (keys.ArrowRight || keys.d || touchDirections.right) {
        dx = 1;
        player.dir = 'right';
      }
    }

    if (dx !== 0 || dy !== 0) {
      tryStartMove(dx, dy);
    }
  }

  updatePlayerAnimationState(player.moving);
  
  // --- Animal wandering update ---
  updateAnimalWandering(sheep);
  updateAnimalWandering(sheep2);
  updateAnimalWandering(goat);
  updateAnimalWandering(peacock);
  
  // --- Sheep wool regrowth ---
  if (!sheep.hasWool) {
    sheep.woolTimer++;

    // ~10 seconds at ~60fps (tune this if you like)
    if (sheep.woolTimer > 600) {
      sheep.hasWool = true;
      sheep.woolTimer = 0;

      if (currentMap === 'overworld') {
        showMessage('Your sheep has grown its wool back.');
      }
    }
  }

  // --- Sheep2 wool regrowth ---
  if (!sheep2.hasWool) {
    sheep2.woolTimer++;
    if (sheep2.woolTimer > 600) {
      sheep2.hasWool = true;
      sheep2.woolTimer = 0;
      if (currentMap === 'overworld') {
        showMessage('Your other sheep has grown its wool back.');
      }
    }
  }

  // Goat fur regrowth
  if (!goat.hasFur) {
    goat.furTimer++;
    if (goat.furTimer > 600) {
      goat.hasFur = true;
      goat.furTimer = 0;
      if (currentMap === 'overworld') {
        showMessage("The goat's fur has grown back.");
      }
    }
  }

  // Peacock feather regrowth
  if (!peacock.hasFeathers) {
    peacock.featherTimer++;
    if (peacock.featherTimer > 900) { // 15 seconds - feathers take longer
      peacock.hasFeathers = true;
      peacock.featherTimer = 0;
      if (currentMap === 'overworld') {
        showMessage("The peacock's feathers have grown back!");
      }
    }
  }

  // --- Message fade-out (timestamp-based, frame-rate independent) ---
  if (message && performance.now() >= messageExpiryTime) {
    message = null;
  }
}
// #endregion UPDATE


// =========================
// RENDER
// =========================
// #region RENDER

    function drawTile(t, x, y, targetCtx = ctx) {
  const px = x * TILE_SIZE;
  const py = y * TILE_SIZE;
  if (drawTileFromTileset(t, x, y, targetCtx)) {
    return;
  }

  // Small deterministic variation so grass/path arenâ€™t identical
  // Variation index (0-4) for different visual styles per tile
  const variation = (x * 13 + y * 7) % 5;
  const variation2 = (x * 7 + y * 11) % 5;

  if (t === 0) {
    // GRASS - 5 distinct style variations
    const grassStyles = [
      { base: '#2f7a54', mid: '#3d8a62', light: '#4a9968', dark: '#1d4b3a' },  // Standard green
      { base: '#2a7048', mid: '#388a55', light: '#45945f', dark: '#1a4535' },  // Deeper green
      { base: '#3a8a5a', mid: '#4a9a68', light: '#5aaa78', dark: '#2a6a4a' },  // Bright meadow
      { base: '#2d6a4e', mid: '#3d7a5c', light: '#4d8a6a', dark: '#1d4a38' },  // Forest floor
      { base: '#358055', mid: '#459063', light: '#55a070', dark: '#255a40' }   // Lush green
    ];
    const style = grassStyles[variation];
    
    // Base grass gradient
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, style.base);
    g.addColorStop(0.5, style.mid);
    g.addColorStop(1, style.dark);
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    // Ground texture patches (variation in density)
    const patchCount = 2 + variation;
    for (let i = 0; i < patchCount; i++) {
      const patchX = px + ((i * 11 + variation * 5) % 24);
      const patchY = py + ((i * 7 + variation2 * 3) % 20);
      targetCtx.fillStyle = i % 2 === 0 ? 'rgba(0,40,20,0.15)' : 'rgba(80,160,80,0.1)';
      targetCtx.beginPath();
      targetCtx.ellipse(patchX + 6, patchY + 6, 5 + (i % 3), 3 + (i % 2), i * 0.5, 0, Math.PI * 2);
      targetCtx.fill();
    }

    // Animated grass blades - varying density and height by style
    const bladeCount = 5 + variation;
    const bladeHeightMod = [1, 1.2, 0.8, 1.1, 0.9][variation];
    
    for (let i = 0; i < bladeCount; i++) {
      const bladeX = px + 2 + ((i * 5 + variation * 4 + variation2 * 2) % (TILE_SIZE - 4));
      const bladeHeight = (5 + (i % 4) * 2.5) * bladeHeightMod;
      const swaySpeed = 1.5 + variation * 0.3;
      const swayOffset = Math.sin(animationTime * swaySpeed + x * 0.5 + y * 0.3 + i * 0.8) * (1.5 + variation * 0.3);
      
      // Blade shadow
      targetCtx.fillStyle = 'rgba(0,30,20,0.25)';
      targetCtx.beginPath();
      targetCtx.moveTo(bladeX + 1, py + TILE_SIZE - 1);
      targetCtx.quadraticCurveTo(bladeX + 2 + swayOffset * 0.5, py + TILE_SIZE - bladeHeight * 0.5, bladeX + 3 + swayOffset, py + TILE_SIZE - bladeHeight);
      targetCtx.lineTo(bladeX + 4 + swayOffset, py + TILE_SIZE - bladeHeight + 2);
      targetCtx.quadraticCurveTo(bladeX + 3 + swayOffset * 0.5, py + TILE_SIZE - bladeHeight * 0.5 + 1, bladeX + 3, py + TILE_SIZE - 1);
      targetCtx.fill();
      
      // Main blade - alternating colors from style
      const bladeColor = i % 3 === 0 ? style.light : (i % 3 === 1 ? style.mid : style.base);
      targetCtx.fillStyle = bladeColor;
      targetCtx.beginPath();
      targetCtx.moveTo(bladeX, py + TILE_SIZE - 1);
      targetCtx.quadraticCurveTo(bladeX + 1 + swayOffset * 0.5, py + TILE_SIZE - bladeHeight * 0.5, bladeX + 2 + swayOffset, py + TILE_SIZE - bladeHeight);
      targetCtx.lineTo(bladeX + 3 + swayOffset, py + TILE_SIZE - bladeHeight + 2);
      targetCtx.quadraticCurveTo(bladeX + 2 + swayOffset * 0.5, py + TILE_SIZE - bladeHeight * 0.5 + 1, bladeX + 2, py + TILE_SIZE - 1);
      targetCtx.fill();
    }

    // Occasional details based on variation
    if (variation === 0 && variation2 === 2) {
      // Small yellow flower
      targetCtx.fillStyle = '#f0e060';
      targetCtx.beginPath();
      targetCtx.arc(px + 22, py + 10, 2, 0, Math.PI * 2);
      targetCtx.fill();
      targetCtx.fillStyle = '#e0a030';
      targetCtx.beginPath();
      targetCtx.arc(px + 22, py + 10, 1, 0, Math.PI * 2);
      targetCtx.fill();
    } else if (variation === 2 && variation2 === 1) {
      // Clover patch
      targetCtx.fillStyle = '#2a6040';
      for (let c = 0; c < 3; c++) {
        targetCtx.beginPath();
        targetCtx.arc(px + 8 + c * 3, py + 20 - (c % 2) * 2, 2.5, 0, Math.PI * 2);
        targetCtx.fill();
      }
    } else if (variation === 4) {
      // Small mushroom
      targetCtx.fillStyle = '#c0a080';
      targetCtx.fillRect(px + 14, py + 24, 2, 4);
      targetCtx.fillStyle = '#e8d0b0';
      targetCtx.beginPath();
      targetCtx.arc(px + 15, py + 24, 3, Math.PI, 0);
      targetCtx.fill();
    }

  } else if (t === 1) {
    // PATH - 5 distinct style variations
    const pathStyles = [
      { light: '#d8b888', mid: '#c4a070', dark: '#9a7545', pebble: '#8a7055' },  // Sandy dirt
      { light: '#c8a878', mid: '#b89060', dark: '#8a6535', pebble: '#706050' },  // Brown dirt
      { light: '#d0b090', mid: '#c09a68', dark: '#907040', pebble: '#807060' },  // Tan path
      { light: '#c0a080', mid: '#a88860', dark: '#786040', pebble: '#686058' },  // Worn trail
      { light: '#d8c098', mid: '#c8a878', dark: '#9a7850', pebble: '#908070' }   // Pale dirt
    ];
    const style = pathStyles[variation];
    
    // Base path gradient
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, style.light);
    g.addColorStop(0.4, style.mid);
    g.addColorStop(1, style.dark);
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    // Worn center area (varies by style)
    const wornWidth = 12 + variation * 2;
    targetCtx.fillStyle = 'rgba(255,245,230,0.2)';
    targetCtx.fillRect(px + (TILE_SIZE - wornWidth) / 2, py + 2, wornWidth, TILE_SIZE - 4);

    // Pebbles - different patterns per variation
    const pebblePatterns = [
      [{x:5,y:8,s:2.5},{x:18,y:14,s:2},{x:25,y:6,s:1.5},{x:10,y:22,s:2}],
      [{x:8,y:6,s:2},{x:20,y:18,s:2.5},{x:14,y:26,s:1.5},{x:6,y:18,s:2}],
      [{x:4,y:12,s:2},{x:22,y:8,s:2},{x:12,y:20,s:2.5},{x:26,y:22,s:1.5}],
      [{x:10,y:5,s:1.5},{x:6,y:16,s:2},{x:20,y:24,s:2},{x:24,y:12,s:2.5}],
      [{x:7,y:10,s:2},{x:16,y:6,s:2.5},{x:24,y:18,s:2},{x:12,y:24,s:1.5},{x:4,y:22,s:2}]
    ];
    
    pebblePatterns[variation].forEach((peb, i) => {
      // Pebble shadow
      targetCtx.fillStyle = 'rgba(60,40,20,0.35)';
      targetCtx.beginPath();
      targetCtx.ellipse(px + peb.x + 1, py + peb.y + 1, peb.s, peb.s * 0.7, i * 0.3, 0, Math.PI * 2);
      targetCtx.fill();
      // Pebble
      targetCtx.fillStyle = style.pebble;
      targetCtx.beginPath();
      targetCtx.ellipse(px + peb.x, py + peb.y, peb.s, peb.s * 0.7, i * 0.3, 0, Math.PI * 2);
      targetCtx.fill();
      // Highlight
      targetCtx.fillStyle = 'rgba(255,250,240,0.3)';
      targetCtx.beginPath();
      targetCtx.ellipse(px + peb.x - 0.5, py + peb.y - 0.5, peb.s * 0.4, peb.s * 0.3, 0, 0, Math.PI * 2);
      targetCtx.fill();
    });

    // Subtle cracks/lines (varies by variation)
    if (variation === 1 || variation === 3) {
      targetCtx.strokeStyle = 'rgba(80,60,40,0.2)';
      targetCtx.lineWidth = 0.5;
      targetCtx.beginPath();
      targetCtx.moveTo(px + 8, py + 4);
      targetCtx.lineTo(px + 14, py + 12);
      targetCtx.lineTo(px + 10, py + 20);
      targetCtx.stroke();
    }

    // Edge grass tufts - animated
    const tuftSide = variation % 2;
    const tuftCount = 1 + (variation2 % 2);
    for (let i = 0; i < tuftCount; i++) {
      const tuftX = tuftSide === 0 ? px + 1 : px + TILE_SIZE - 4;
      const tuftY = py + 6 + i * 14;
      const sway = Math.sin(animationTime * 1.5 + x + y + i) * 1;
      targetCtx.fillStyle = '#3d7a50';
      targetCtx.beginPath();
      targetCtx.moveTo(tuftX, tuftY + 5);
      targetCtx.quadraticCurveTo(tuftX + sway, tuftY + 2, tuftX + 1 + sway, tuftY);
      targetCtx.quadraticCurveTo(tuftX + 2 + sway, tuftY + 2, tuftX + 2, tuftY + 5);
      targetCtx.fill();
    }

  } else if (t === 2) {
    // TREE - 5 distinct style variations with animated canopy
    const treeStyles = [
      { trunk: ['#4a2f1a','#6b4528','#4a2f1a'], canopyDark: '#1a4528', canopyMid: '#3a9055', canopyLight: '#5ec47a', size: 1.0 },   // Standard oak
      { trunk: ['#3d2515','#5a3820','#3d2515'], canopyDark: '#1a3820', canopyMid: '#2d6040', canopyLight: '#4a8858', size: 0.9 },   // Dark pine
      { trunk: ['#5a3a20','#7a5030','#5a3a20'], canopyDark: '#2a5535', canopyMid: '#45a060', canopyLight: '#65c080', size: 1.1 },   // Bright maple
      { trunk: ['#4a3525','#6a4a30','#4a3525'], canopyDark: '#1d4030', canopyMid: '#358050', canopyLight: '#55a868', size: 0.85 },  // Young tree
      { trunk: ['#3a2818','#5a4025','#3a2818'], canopyDark: '#254a38', canopyMid: '#408858', canopyLight: '#60b075', size: 1.05 }   // Mature elm
    ];
    const style = treeStyles[variation];
    
    const centerX = px + TILE_SIZE / 2;
    const treePhase = (x * 7 + y * 11) % 10;
    const swayAmount = 1.2 + variation * 0.3;
    const swaySpeed = 0.6 + variation * 0.15;
    const canopySway = Math.sin(animationTime * swaySpeed + treePhase) * swayAmount;
    
    // Tree shadow on ground - size varies
    targetCtx.fillStyle = 'rgba(0,30,20,0.35)';
    targetCtx.beginPath();
    targetCtx.ellipse(centerX + 4, py + TILE_SIZE - 3, 11 * style.size, 4.5 * style.size, 0.3, 0, Math.PI * 2);
    targetCtx.fill();

    // Trunk with bark texture - varies by style
    const trunkWidth = 8 + variation;
    const trunkX = px + (TILE_SIZE - trunkWidth) / 2;
    const trunkGrad = targetCtx.createLinearGradient(trunkX, py, trunkX + trunkWidth, py);
    trunkGrad.addColorStop(0, style.trunk[0]);
    trunkGrad.addColorStop(0.5, style.trunk[1]);
    trunkGrad.addColorStop(1, style.trunk[2]);
    targetCtx.fillStyle = trunkGrad;
    
    // Trunk shape varies
    if (variation === 1) {
      // Tapered trunk
      targetCtx.beginPath();
      targetCtx.moveTo(trunkX + 1, py + TILE_SIZE - 2);
      targetCtx.lineTo(trunkX + trunkWidth - 1, py + TILE_SIZE - 2);
      targetCtx.lineTo(trunkX + trunkWidth - 2, py + 10);
      targetCtx.lineTo(trunkX + 2, py + 10);
      targetCtx.closePath();
      targetCtx.fill();
    } else {
      targetCtx.fillRect(trunkX, py + 10, trunkWidth, TILE_SIZE - 12);
    }
    
    // Bark lines - different patterns
    targetCtx.strokeStyle = 'rgba(30,15,5,0.35)';
    targetCtx.lineWidth = 0.8;
    const barkLines = 2 + (variation % 3);
    for (let i = 0; i < barkLines; i++) {
      targetCtx.beginPath();
      const bx = trunkX + 2 + i * (trunkWidth / (barkLines + 1));
      targetCtx.moveTo(bx, py + 12);
      if (variation === 2) {
        // Curved bark
        targetCtx.quadraticCurveTo(bx + 1, py + 18, bx, py + TILE_SIZE - 4);
      } else {
        targetCtx.lineTo(bx + (variation % 2), py + TILE_SIZE - 4);
      }
      targetCtx.stroke();
    }

    // Animated canopy layers
    const canopySize = 12 * style.size;
    
    // Back layer (darker, less sway)
    const backLeafGrad = targetCtx.createRadialGradient(
      centerX + canopySway * 0.4, py + 9, 2,
      centerX + canopySway * 0.4, py + 11, canopySize + 3
    );
    backLeafGrad.addColorStop(0, style.canopyMid);
    backLeafGrad.addColorStop(1, style.canopyDark);
    targetCtx.fillStyle = backLeafGrad;
    targetCtx.beginPath();
    targetCtx.arc(centerX + canopySway * 0.4, py + 11, canopySize + 1, 0, Math.PI * 2);
    targetCtx.fill();

    // Main canopy (medium sway)
    const mainLeafGrad = targetCtx.createRadialGradient(
      centerX + canopySway * 0.7, py + 7, 3,
      centerX + canopySway * 0.7, py + 9, canopySize
    );
    mainLeafGrad.addColorStop(0, style.canopyLight);
    mainLeafGrad.addColorStop(0.6, style.canopyMid);
    mainLeafGrad.addColorStop(1, style.canopyDark);
    targetCtx.fillStyle = mainLeafGrad;
    targetCtx.beginPath();
    targetCtx.arc(centerX + canopySway * 0.7, py + 9, canopySize - 1, 0, Math.PI * 2);
    targetCtx.fill();

    // Front highlight layer (most sway)
    targetCtx.fillStyle = 'rgba(150,255,180,0.2)';
    targetCtx.beginPath();
    targetCtx.arc(centerX - 3 + canopySway, py + 5, 4 * style.size, 0, Math.PI * 2);
    targetCtx.fill();
    
    // Extra leaf clusters for some variations
    if (variation === 0 || variation === 2) {
      targetCtx.fillStyle = style.canopyMid;
      targetCtx.beginPath();
      targetCtx.arc(centerX + 8 + canopySway * 0.5, py + 12, 4, 0, Math.PI * 2);
      targetCtx.fill();
    }
    if (variation === 4) {
      targetCtx.fillStyle = style.canopyLight;
      targetCtx.beginPath();
      targetCtx.arc(centerX - 7 + canopySway * 0.6, py + 10, 3.5, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 3) {
    // WATER - enhanced with animated waves
    // Base water gradient
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#4dc8ff');
    g.addColorStop(0.5, '#2a95d8');
    g.addColorStop(1, '#1a60a8');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    // Animated wave layers
    const wavePhase = animationTime * 1.5 + x * 0.3 + y * 0.2;
    
    // Dark wave troughs
    targetCtx.strokeStyle = 'rgba(10,50,100,0.3)';
    targetCtx.lineWidth = 2;
    for (let i = 0; i < 3; i++) {
      const waveY = py + 6 + i * 10;
      const waveOffset = Math.sin(wavePhase + i * 1.2) * 3;
      targetCtx.beginPath();
      targetCtx.moveTo(px - 2, waveY + waveOffset);
      targetCtx.quadraticCurveTo(px + TILE_SIZE * 0.25, waveY - 3 + waveOffset, px + TILE_SIZE * 0.5, waveY + waveOffset);
      targetCtx.quadraticCurveTo(px + TILE_SIZE * 0.75, waveY + 3 + waveOffset, px + TILE_SIZE + 2, waveY + waveOffset);
      targetCtx.stroke();
    }

    // Bright wave crests / shimmer
    targetCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    targetCtx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      const waveY = py + 4 + i * 10;
      const waveOffset = Math.sin(wavePhase + i * 1.2) * 3;
      targetCtx.beginPath();
      targetCtx.moveTo(px + 2, waveY + waveOffset);
      targetCtx.quadraticCurveTo(px + TILE_SIZE * 0.25, waveY - 2 + waveOffset, px + TILE_SIZE * 0.5, waveY + waveOffset);
      targetCtx.quadraticCurveTo(px + TILE_SIZE * 0.75, waveY + 2 + waveOffset, px + TILE_SIZE - 2, waveY + waveOffset);
      targetCtx.stroke();
    }

    // Sparkle highlights
    const sparkleIntensity = (Math.sin(animationTime * 3 + x * 2 + y) + 1) * 0.3;
    targetCtx.fillStyle = `rgba(255,255,255,${sparkleIntensity})`;
    targetCtx.beginPath();
    targetCtx.arc(px + 8 + (variation * 4), py + 7, 2, 0, Math.PI * 2);
    targetCtx.fill();
    targetCtx.beginPath();
    targetCtx.arc(px + 22 - (variation * 3), py + 20, 1.5, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 4) {
    // FENCE - enhanced with wood grain and shadows
    // Post shadows
    targetCtx.fillStyle = 'rgba(40,25,10,0.4)';
    targetCtx.fillRect(px + 5, py + 9, 5, TILE_SIZE - 6);
    targetCtx.fillRect(px + TILE_SIZE - 6, py + 9, 5, TILE_SIZE - 6);

    // Rail shadow
    targetCtx.fillStyle = 'rgba(40,25,10,0.3)';
    targetCtx.fillRect(px + 2, py + 14, TILE_SIZE - 4, 9);

    // Main rail with gradient
    const railGrad = targetCtx.createLinearGradient(px, py + 11, px, py + 21);
    railGrad.addColorStop(0, '#ddb87a');
    railGrad.addColorStop(0.3, '#c9a46b');
    railGrad.addColorStop(1, '#a88550');
    targetCtx.fillStyle = railGrad;
    targetCtx.fillRect(px, py + 11, TILE_SIZE, 10);

    // Rail wood grain
    targetCtx.strokeStyle = 'rgba(100,60,30,0.25)';
    targetCtx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      targetCtx.beginPath();
      targetCtx.moveTo(px + 2, py + 13 + i * 3);
      targetCtx.lineTo(px + TILE_SIZE - 2, py + 13 + i * 3);
      targetCtx.stroke();
    }

    // Posts with gradient
    const postGrad = targetCtx.createLinearGradient(px + 3, py, px + 8, py);
    postGrad.addColorStop(0, '#7a5530');
    postGrad.addColorStop(0.5, '#9a7045');
    postGrad.addColorStop(1, '#7a5530');
    targetCtx.fillStyle = postGrad;
    targetCtx.fillRect(px + 3, py + 6, 5, TILE_SIZE - 7);
    targetCtx.fillRect(px + TILE_SIZE - 8, py + 6, 5, TILE_SIZE - 7);

    // Post wood grain
    targetCtx.strokeStyle = 'rgba(50,30,15,0.3)';
    for (let i = 0; i < 2; i++) {
      // Left post grain
      targetCtx.beginPath();
      targetCtx.moveTo(px + 4 + i * 2, py + 8);
      targetCtx.lineTo(px + 4 + i * 2, py + TILE_SIZE - 3);
      targetCtx.stroke();
      // Right post grain
      targetCtx.beginPath();
      targetCtx.moveTo(px + TILE_SIZE - 7 + i * 2, py + 8);
      targetCtx.lineTo(px + TILE_SIZE - 7 + i * 2, py + TILE_SIZE - 3);
      targetCtx.stroke();
    }

    // Post caps (top highlights)
    targetCtx.fillStyle = 'rgba(255,230,180,0.4)';
    targetCtx.fillRect(px + 3, py + 6, 5, 2);
    targetCtx.fillRect(px + TILE_SIZE - 8, py + 6, 5, 2);

  } else if (t === 5) {
    // COTTAGE ROOF â€“ tiled effect
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#d59b62');
    g.addColorStop(1, '#a36434');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    // tile rows
    targetCtx.strokeStyle = 'rgba(90,50,30,0.5)';
    targetCtx.beginPath();
    targetCtx.moveTo(px, py + TILE_SIZE / 2);
    targetCtx.lineTo(px + TILE_SIZE, py + TILE_SIZE / 2);
    targetCtx.stroke();

  } else if (t === 6) {
    // DOOR â€“ more contrasty
    targetCtx.fillStyle = '#6a3a22';
    targetCtx.fillRect(px + 6, py + 4, TILE_SIZE - 12, TILE_SIZE - 4);

    // top trim
    targetCtx.fillStyle = '#3b2114';
    targetCtx.fillRect(px + 6, py + 4, TILE_SIZE - 12, 4);

    // handle
    targetCtx.fillStyle = '#f7e3a1';
    targetCtx.fillRect(px + TILE_SIZE - 12, py + TILE_SIZE - 12, 3, 3);

  } else if (t === 7) {
    // INTERIOR WALL â€“ wooden boards
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#4a3733');
    g.addColorStop(1, '#2b1c1b');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    targetCtx.strokeStyle = 'rgba(20,10,10,0.6)';
    targetCtx.beginPath();
    targetCtx.moveTo(px, py + TILE_SIZE / 2);
    targetCtx.lineTo(px + TILE_SIZE, py + TILE_SIZE / 2);
    targetCtx.stroke();

  } else if (t === 8) {
    // INTERIOR FLOOR â€“ nicer planks
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#d8b07d');
    g.addColorStop(1, '#a8743e');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

    targetCtx.strokeStyle = 'rgba(120,80,40,0.45)';
    targetCtx.lineWidth = 1;
    targetCtx.beginPath();
    // plank line
    targetCtx.moveTo(px, py + TILE_SIZE / 2);
    targetCtx.lineTo(px + TILE_SIZE, py + TILE_SIZE / 2);
    targetCtx.stroke();

  } else if (t === 9) {
    // STONE PATH - cobblestone for village
    targetCtx.fillStyle = '#7a7a7a';
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    targetCtx.fillStyle = '#5a5a5a';
    targetCtx.fillRect(px + 2, py + 2, 12, 12);
    targetCtx.fillRect(px + 16, py + 16, 12, 12);
    targetCtx.fillStyle = '#6a6a6a';
    targetCtx.fillRect(px + 16, py + 2, 12, 12);
    targetCtx.fillRect(px + 2, py + 16, 12, 12);

  } else if (t === 10) {
    // MARKET STALL
    targetCtx.fillStyle = '#8b4513';
    targetCtx.fillRect(px + 4, py + 8, TILE_SIZE - 8, TILE_SIZE - 8);
    targetCtx.fillStyle = '#cd853f';
    targetCtx.fillRect(px + 2, py + 4, TILE_SIZE - 4, 6);
    // awning
    targetCtx.fillStyle = '#c41e3a';
    targetCtx.fillRect(px, py, TILE_SIZE, 6);

  } else if (t === 11) {
    // WELL
    targetCtx.fillStyle = '#696969';
    targetCtx.beginPath();
    targetCtx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 12, 0, Math.PI * 2);
    targetCtx.fill();
    targetCtx.fillStyle = '#1a4d6e';
    targetCtx.beginPath();
    targetCtx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 8, 0, Math.PI * 2);
    targetCtx.fill();
    // roof supports
    targetCtx.fillStyle = '#8b4513';
    targetCtx.fillRect(px + 6, py + 2, 3, 10);
    targetCtx.fillRect(px + TILE_SIZE - 9, py + 2, 3, 10);

  } else if (t === 12) {
    // FLOWER PATCH
    targetCtx.fillStyle = '#2f7a54';
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // flowers
    const flowerColors = ['#ff6b9d', '#ffeb3b', '#ff5722', '#e91e63'];
    for (let i = 0; i < 5; i++) {
      const fx = px + 4 + (i * 6) % 24;
      const fy = py + 4 + Math.floor(i / 4) * 12 + (variation * 3);
      targetCtx.fillStyle = flowerColors[i % flowerColors.length];
      targetCtx.beginPath();
      targetCtx.arc(fx, fy, 3, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 13) {
    // BUSH - for forest
    targetCtx.fillStyle = '#2f7a54';
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    targetCtx.fillStyle = '#1d5a3a';
    targetCtx.beginPath();
    targetCtx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, 12, 0, Math.PI * 2);
    targetCtx.fill();
    targetCtx.fillStyle = '#2a6a4a';
    targetCtx.beginPath();
    targetCtx.arc(px + TILE_SIZE/2 - 4, py + TILE_SIZE/2 - 2, 8, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 14) {
    // BRIDGE
    targetCtx.fillStyle = '#46c0ff';
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    targetCtx.fillStyle = '#8b7355';
    targetCtx.fillRect(px + 2, py, TILE_SIZE - 4, TILE_SIZE);
    targetCtx.strokeStyle = '#5a4a3a';
    targetCtx.lineWidth = 2;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 2, py);
    targetCtx.lineTo(px + 2, py + TILE_SIZE);
    targetCtx.moveTo(px + TILE_SIZE - 2, py);
    targetCtx.lineTo(px + TILE_SIZE - 2, py + TILE_SIZE);
    targetCtx.stroke();

  } else if (t === 15) {
    // SIGN POST - map transition marker
    targetCtx.fillStyle = '#2f7a54';
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // post
    targetCtx.fillStyle = '#8b4513';
    targetCtx.fillRect(px + 14, py + 10, 4, 22);
    // sign
    targetCtx.fillStyle = '#deb887';
    targetCtx.fillRect(px + 6, py + 4, 20, 12);
    targetCtx.fillStyle = '#654321';
    targetCtx.font = '8px system-ui';
    targetCtx.fillText('â†’', px + 12, py + 13);

  } else if (t === 16) {
    // SAND - beach terrain
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#f4d9a0');
    g.addColorStop(1, '#e8c878');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // sand texture dots
    targetCtx.fillStyle = 'rgba(200,160,80,0.4)';
    if (variation === 0) targetCtx.fillRect(px + 5, py + 8, 2, 2);
    if (variation === 1) targetCtx.fillRect(px + 20, py + 12, 2, 2);
    if (variation === 2) targetCtx.fillRect(px + 12, py + 22, 2, 2);
    if (variation === 3) targetCtx.fillRect(px + 25, py + 6, 2, 2);

  } else if (t === 17) {
    // OCEAN - deep animated water
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#1a5590');
    g.addColorStop(0.3, '#2080c0');
    g.addColorStop(0.7, '#2090d0');
    g.addColorStop(1, '#1a6090');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Animated wave layers
    const wavePhase = x * 0.3 + y * 0.5;
    const waveTime = animationTime * 1.2 + wavePhase;
    
    // Dark wave troughs
    targetCtx.strokeStyle = 'rgba(15, 60, 100, 0.4)';
    targetCtx.lineWidth = 3;
    targetCtx.beginPath();
    const trough1 = Math.sin(waveTime * 0.6) * 4;
    targetCtx.moveTo(px - 2, py + 22 + trough1);
    targetCtx.quadraticCurveTo(px + 16, py + 18 + trough1, px + 34, py + 22 + trough1);
    targetCtx.stroke();
    
    // Main wave crest
    targetCtx.strokeStyle = 'rgba(255, 255, 255, 0.45)';
    targetCtx.lineWidth = 2;
    targetCtx.beginPath();
    const wave1 = Math.sin(waveTime) * 4;
    targetCtx.moveTo(px - 2, py + 10 + wave1);
    targetCtx.quadraticCurveTo(px + 16, py + 6 + wave1, px + 34, py + 10 + wave1);
    targetCtx.stroke();
    
    // Secondary shimmer
    targetCtx.strokeStyle = 'rgba(200, 235, 255, 0.35)';
    targetCtx.lineWidth = 1;
    const wave2 = Math.sin(waveTime + 1.5) * 3;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 4, py + TILE_SIZE - 6 + wave2);
    targetCtx.quadraticCurveTo(px + 16, py + TILE_SIZE - 10 + wave2, px + 28, py + TILE_SIZE - 6 + wave2);
    targetCtx.stroke();
    
    // Sparkle effect
    if (Math.sin(waveTime * 2.5 + variation) > 0.75) {
      targetCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      targetCtx.beginPath();
      targetCtx.arc(px + 8 + (variation * 5), py + 8 + (variation * 3), 1.5, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 18) {
    // SHELLS - decorative sand with shells
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#f4d9a0');
    g.addColorStop(1, '#e8c878');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // shells
    targetCtx.fillStyle = '#ffefd5';
    targetCtx.beginPath();
    targetCtx.arc(px + 10 + (variation * 3), py + 14, 4, 0, Math.PI, true);
    targetCtx.fill();
    targetCtx.fillStyle = '#ffe4c4';
    targetCtx.beginPath();
    targetCtx.arc(px + 22 - (variation * 2), py + 20, 3, 0, Math.PI, true);
    targetCtx.fill();

  } else if (t === 19) {
    // ROCK - boulder (solid)
    targetCtx.fillStyle = currentMap === 'beach' ? '#f4d9a0' : (currentMap === 'cave' ? '#3a3a3a' : '#4a5a4a');
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    const g = targetCtx.createRadialGradient(px + 16, py + 14, 4, px + 16, py + 16, 14);
    g.addColorStop(0, '#8a8a8a');
    g.addColorStop(1, '#4a4a4a');
    targetCtx.fillStyle = g;
    targetCtx.beginPath();
    targetCtx.ellipse(px + 16, py + 18, 12, 10, 0, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 20) {
    // DRIFTWOOD - beach decoration
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#f4d9a0');
    g.addColorStop(1, '#e8c878');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // driftwood log
    targetCtx.fillStyle = '#a08060';
    targetCtx.save();
    targetCtx.translate(px + 16, py + 16);
    targetCtx.rotate((variation * 0.3) - 0.4);
    targetCtx.fillRect(-12, -3, 24, 6);
    targetCtx.restore();

  } else if (t === 21) {
    // PALM TREE (solid) - with animated fronds
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#f4d9a0');
    g.addColorStop(1, '#e8c878');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Shadow
    targetCtx.fillStyle = 'rgba(80, 60, 20, 0.25)';
    targetCtx.beginPath();
    targetCtx.ellipse(px + 18, py + TILE_SIZE - 4, 10, 4, 0, 0, Math.PI * 2);
    targetCtx.fill();
    
    // trunk with bark texture
    const trunkG = targetCtx.createLinearGradient(px + 13, py, px + 19, py);
    trunkG.addColorStop(0, '#6a4a10');
    trunkG.addColorStop(0.5, '#9b7420');
    trunkG.addColorStop(1, '#6a4a10');
    targetCtx.fillStyle = trunkG;
    targetCtx.fillRect(px + 13, py + 12, 6, 20);
    
    // bark rings
    targetCtx.strokeStyle = 'rgba(60, 40, 10, 0.4)';
    targetCtx.lineWidth = 1;
    for (let i = 0; i < 4; i++) {
      targetCtx.beginPath();
      targetCtx.moveTo(px + 13, py + 15 + i * 5);
      targetCtx.lineTo(px + 19, py + 15 + i * 5);
      targetCtx.stroke();
    }
    
    // Animated leaf sway
    const leafSway = Math.sin(animationTime * 0.8 + x * 0.5) * 2;
    
    // Left frond
    targetCtx.fillStyle = '#1a7a1a';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + 9);
    targetCtx.quadraticCurveTo(px + 6 + leafSway, py + 10, px + 2 + leafSway * 1.5, py + 18);
    targetCtx.lineTo(px + 6 + leafSway, py + 15);
    targetCtx.quadraticCurveTo(px + 10, py + 11, px + 16, py + 12);
    targetCtx.fill();
    
    // Right frond  
    targetCtx.fillStyle = '#228b22';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + 9);
    targetCtx.quadraticCurveTo(px + 26 - leafSway, py + 10, px + 30 - leafSway * 1.5, py + 18);
    targetCtx.lineTo(px + 26 - leafSway, py + 15);
    targetCtx.quadraticCurveTo(px + 22, py + 11, px + 16, py + 12);
    targetCtx.fill();
    
    // Top frond
    targetCtx.fillStyle = '#2a9a2a';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + 7);
    targetCtx.lineTo(px + 14 + leafSway * 0.5, py + 2);
    targetCtx.lineTo(px + 18 + leafSway * 0.5, py + 2);
    targetCtx.lineTo(px + 20, py + 10);
    targetCtx.fill();
    targetCtx.fill();

  } else if (t === 22) {
    // TIDE POOL - shallow water on beach
    const g = targetCtx.createLinearGradient(px, py, px + TILE_SIZE, py + TILE_SIZE);
    g.addColorStop(0, '#1e5799');
    g.addColorStop(1, '#2989d8');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // rocks around edge
    targetCtx.fillStyle = '#6a6a6a';
    targetCtx.beginPath();
    targetCtx.arc(px + 6, py + 8, 4, 0, Math.PI * 2);
    targetCtx.arc(px + 26, py + 24, 5, 0, Math.PI * 2);
    targetCtx.arc(px + 8, py + 26, 4, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 23) {
    // CLIFF - mountain wall (solid)
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#5a5a6a');
    g.addColorStop(1, '#3a3a4a');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // rock texture
    targetCtx.strokeStyle = 'rgba(0,0,0,0.3)';
    targetCtx.lineWidth = 1;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 4, py + 12);
    targetCtx.lineTo(px + 20, py + 8);
    targetCtx.moveTo(px + 8, py + 24);
    targetCtx.lineTo(px + 28, py + 20);
    targetCtx.stroke();

  } else if (t === 24) {
    // MOUNTAIN PATH
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#7a8a7a');
    g.addColorStop(1, '#5a6a5a');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // gravel
    targetCtx.fillStyle = 'rgba(90,90,90,0.5)';
    if (variation === 0) targetCtx.fillRect(px + 8, py + 6, 3, 3);
    if (variation === 1) targetCtx.fillRect(px + 18, py + 18, 3, 3);
    if (variation === 2) targetCtx.fillRect(px + 6, py + 22, 3, 3);

  } else if (t === 25) {
    // SNOW GRASS - mountain grass
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#6a8a6a');
    g.addColorStop(1, '#4a6a4a');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // snow patches
    targetCtx.fillStyle = 'rgba(255,255,255,0.3)';
    targetCtx.beginPath();
    targetCtx.arc(px + 8 + (variation * 5), py + 12, 6, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 26) {
    // CAVE ENTRANCE
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, '#5a5a6a');
    g.addColorStop(1, '#3a3a4a');
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // dark cave opening
    targetCtx.fillStyle = '#1a1a2a';
    targetCtx.beginPath();
    targetCtx.arc(px + 16, py + 20, 10, Math.PI, 0, true);
    targetCtx.lineTo(px + 26, py + 32);
    targetCtx.lineTo(px + 6, py + 32);
    targetCtx.closePath();
    targetCtx.fill();

  } else if (t === 27) {
    // CRYSTAL SHARD - collectible/interactable
    const bgColor = currentMap === 'beach' ? '#f4d9a0' : 
                    currentMap === 'mountain' ? '#6a8a6a' : '#3a3a3a';
    targetCtx.fillStyle = bgColor;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    // glowing crystal
    const glowPhase = (Date.now() / 500) % (Math.PI * 2);
    const glowIntensity = 0.5 + Math.sin(glowPhase) * 0.3;
    targetCtx.fillStyle = `rgba(150, 200, 255, ${glowIntensity})`;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + 6);
    targetCtx.lineTo(px + 22, py + 16);
    targetCtx.lineTo(px + 20, py + 26);
    targetCtx.lineTo(px + 12, py + 26);
    targetCtx.lineTo(px + 10, py + 16);
    targetCtx.closePath();
    targetCtx.fill();
    // highlight
    targetCtx.fillStyle = 'rgba(255,255,255,0.6)';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 14, py + 10);
    targetCtx.lineTo(px + 18, py + 14);
    targetCtx.lineTo(px + 14, py + 18);
    targetCtx.closePath();
    targetCtx.fill();

  } else if (t === 28) {
    // GATE - walkable fence opening
    // Draw grass base first
    const grassG = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    grassG.addColorStop(0, '#2f7a54');
    grassG.addColorStop(0.5, '#3d8a62');
    grassG.addColorStop(1, '#1d4b3a');
    targetCtx.fillStyle = grassG;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Gate posts on sides
    const postGrad = targetCtx.createLinearGradient(px, py, px + 6, py);
    postGrad.addColorStop(0, '#7a5530');
    postGrad.addColorStop(0.5, '#9a7045');
    postGrad.addColorStop(1, '#7a5530');
    targetCtx.fillStyle = postGrad;
    targetCtx.fillRect(px, py + 4, 5, TILE_SIZE - 6);
    targetCtx.fillRect(px + TILE_SIZE - 5, py + 4, 5, TILE_SIZE - 6);
    
    // Gate horizontal bars (open design)
    targetCtx.fillStyle = '#a88550';
    targetCtx.fillRect(px + 5, py + 8, TILE_SIZE - 10, 3);
    targetCtx.fillRect(px + 5, py + TILE_SIZE - 10, TILE_SIZE - 10, 3);
    
    // Vertical bars (spaced out for open look)
    targetCtx.fillStyle = '#9a7045';
    for (let i = 0; i < 3; i++) {
      const barX = px + 8 + i * 8;
      targetCtx.fillRect(barX, py + 8, 2, TILE_SIZE - 18);
    }
    
    // Post caps
    targetCtx.fillStyle = 'rgba(255,230,180,0.4)';
    targetCtx.fillRect(px, py + 4, 5, 2);
    targetCtx.fillRect(px + TILE_SIZE - 5, py + 4, 5, 2);

  } else if (t === 29) {
    // SIGNPOST - fast travel point
    // Draw grass base first
    const grassG = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    grassG.addColorStop(0, '#2f7a54');
    grassG.addColorStop(0.5, '#3d8a62');
    grassG.addColorStop(1, '#1d4b3a');
    targetCtx.fillStyle = grassG;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Signpost pole
    const poleX = px + 13;
    const poleGrad = targetCtx.createLinearGradient(poleX, py, poleX + 6, py);
    poleGrad.addColorStop(0, '#6a4520');
    poleGrad.addColorStop(0.5, '#8a6530');
    poleGrad.addColorStop(1, '#6a4520');
    targetCtx.fillStyle = poleGrad;
    targetCtx.fillRect(poleX, py + 8, 6, TILE_SIZE - 8);
    
    // Sign board (pointing right) 
    targetCtx.fillStyle = '#a08050';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 8, py + 6);
    targetCtx.lineTo(px + 28, py + 6);
    targetCtx.lineTo(px + 30, py + 12);
    targetCtx.lineTo(px + 28, py + 18);
    targetCtx.lineTo(px + 8, py + 18);
    targetCtx.closePath();
    targetCtx.fill();
    
    // Sign border
    targetCtx.strokeStyle = '#5a3510';
    targetCtx.lineWidth = 1;
    targetCtx.stroke();
    
    // Sign text line decorations
    targetCtx.fillStyle = '#4a2510';
    targetCtx.fillRect(px + 10, py + 9, 12, 2);
    targetCtx.fillRect(px + 10, py + 13, 8, 2);
    
    // Flag/ribbon on top
    targetCtx.fillStyle = '#d44040';
    targetCtx.beginPath();
    targetCtx.moveTo(px + 14, py + 2);
    targetCtx.lineTo(px + 22, py + 2);
    targetCtx.lineTo(px + 20, py + 5);
    targetCtx.lineTo(px + 22, py + 8);
    targetCtx.lineTo(px + 14, py + 8);
    targetCtx.closePath();
    targetCtx.fill();
    
    // Post cap
    targetCtx.fillStyle = '#4a2510';
    targetCtx.fillRect(poleX - 1, py + 6, 8, 3);

  } else if (t === 30) {
    // WETLAND GRASS - marshy green grass
    const wetGrassStyles = [
      { base: '#3a6050', mid: '#4a7060', light: '#5a8070', dark: '#2a4a40' },
      { base: '#386055', mid: '#487065', light: '#588075', dark: '#284a45' },
      { base: '#3c6555', mid: '#4c7565', light: '#5c8575', dark: '#2c4f45' }
    ];
    const style = wetGrassStyles[variation % 3];
    
    // Base gradient
    const g = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    g.addColorStop(0, style.base);
    g.addColorStop(0.5, style.mid);
    g.addColorStop(1, style.dark);
    targetCtx.fillStyle = g;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Wet mud patches
    targetCtx.fillStyle = 'rgba(60, 50, 40, 0.25)';
    for (let i = 0; i < 2 + variation; i++) {
      const mudX = px + ((i * 13 + variation * 7) % 22);
      const mudY = py + ((i * 9 + variation2 * 5) % 20);
      targetCtx.beginPath();
      targetCtx.ellipse(mudX + 5, mudY + 5, 6, 4, i * 0.3, 0, Math.PI * 2);
      targetCtx.fill();
    }
    
    // Swamp grass blades (taller, darker)
    for (let i = 0; i < 4 + variation; i++) {
      const bladeX = px + 3 + ((i * 6 + variation * 3) % (TILE_SIZE - 6));
      const bladeHeight = 8 + (i % 3) * 3;
      const sway = Math.sin(animationTime * 1.2 + x * 0.4 + y * 0.3 + i) * 2;
      
      targetCtx.fillStyle = i % 2 === 0 ? style.light : style.mid;
      targetCtx.beginPath();
      targetCtx.moveTo(bladeX, py + TILE_SIZE - 1);
      targetCtx.quadraticCurveTo(bladeX + 1 + sway * 0.5, py + TILE_SIZE - bladeHeight * 0.5, bladeX + 2 + sway, py + TILE_SIZE - bladeHeight);
      targetCtx.lineTo(bladeX + 3 + sway, py + TILE_SIZE - bladeHeight + 2);
      targetCtx.quadraticCurveTo(bladeX + 2 + sway * 0.5, py + TILE_SIZE - bladeHeight * 0.5 + 1, bladeX + 2, py + TILE_SIZE - 1);
      targetCtx.fill();
    }

  } else if (t === 31) {
    // SWAMP WATER - murky shallow water (solid/impassable)
    // Base murky water color
    const waterG = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    waterG.addColorStop(0, '#3a5a50');
    waterG.addColorStop(0.5, '#2a4a40');
    waterG.addColorStop(1, '#1a3a30');
    targetCtx.fillStyle = waterG;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Animated ripples
    const ripplePhase = animationTime + x * 0.5 + y * 0.3;
    for (let i = 0; i < 3; i++) {
      const rippleX = px + 8 + ((i * 11 + variation * 5) % 18);
      const rippleY = py + 8 + ((i * 7 + variation2 * 3) % 18);
      const rippleSize = 3 + Math.sin(ripplePhase + i * 2) * 1.5;
      
      targetCtx.strokeStyle = 'rgba(100, 140, 120, 0.4)';
      targetCtx.lineWidth = 1;
      targetCtx.beginPath();
      targetCtx.ellipse(rippleX, rippleY, rippleSize, rippleSize * 0.5, 0, 0, Math.PI * 2);
      targetCtx.stroke();
    }
    
    // Algae patches
    targetCtx.fillStyle = 'rgba(60, 100, 70, 0.3)';
    targetCtx.beginPath();
    targetCtx.ellipse(px + 10 + variation * 3, py + 12, 6, 4, 0, 0, Math.PI * 2);
    targetCtx.fill();

  } else if (t === 32) {
    // REEDS - tall marsh reeds (walkable)
    // Draw wetland grass base first
    const wetBase = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    wetBase.addColorStop(0, '#3a6050');
    wetBase.addColorStop(1, '#2a4a40');
    targetCtx.fillStyle = wetBase;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Tall reeds
    for (let i = 0; i < 4; i++) {
      const reedX = px + 4 + i * 7 + (variation % 3);
      const reedHeight = 20 + (i % 3) * 4;
      const sway = Math.sin(animationTime * 0.8 + i * 0.5 + x * 0.3) * 3;
      
      // Reed stem
      targetCtx.strokeStyle = '#5a7a50';
      targetCtx.lineWidth = 2;
      targetCtx.beginPath();
      targetCtx.moveTo(reedX, py + TILE_SIZE);
      targetCtx.quadraticCurveTo(reedX + sway * 0.3, py + TILE_SIZE - reedHeight * 0.5, reedX + sway, py + TILE_SIZE - reedHeight);
      targetCtx.stroke();
      
      // Reed top (cattail shape)
      targetCtx.fillStyle = '#8a6040';
      targetCtx.beginPath();
      targetCtx.ellipse(reedX + sway, py + TILE_SIZE - reedHeight - 2, 2, 5, 0, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 33) {
    // LILY PADS - on water (solid/walkable)
    // Water base
    const waterG = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    waterG.addColorStop(0, '#3a5a50');
    waterG.addColorStop(1, '#2a4a40');
    targetCtx.fillStyle = waterG;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Lily pad - large circular leaf
    const padX = px + 16;
    const padY = py + 16;
    const padSize = 10 + variation;
    
    // Pad shadow
    targetCtx.fillStyle = 'rgba(0, 30, 20, 0.3)';
    targetCtx.beginPath();
    targetCtx.ellipse(padX + 2, padY + 2, padSize, padSize * 0.7, 0, 0, Math.PI * 2);
    targetCtx.fill();
    
    // Main pad
    targetCtx.fillStyle = '#4a8a50';
    targetCtx.beginPath();
    targetCtx.ellipse(padX, padY, padSize, padSize * 0.7, 0, 0.2, Math.PI * 2 - 0.2);
    targetCtx.lineTo(padX, padY);
    targetCtx.fill();
    
    // Pad veins
    targetCtx.strokeStyle = '#3a7a40';
    targetCtx.lineWidth = 1;
    for (let v = 0; v < 4; v++) {
      const angle = v * (Math.PI / 3) + 0.5;
      targetCtx.beginPath();
      targetCtx.moveTo(padX, padY);
      targetCtx.lineTo(padX + Math.cos(angle) * padSize * 0.8, padY + Math.sin(angle) * padSize * 0.5);
      targetCtx.stroke();
    }
    
    // Small flower (occasional)
    if (variation2 === 1) {
      const bob = Math.sin(animationTime * 1.5) * 2;
      targetCtx.fillStyle = '#ffa0d0';
      for (let p = 0; p < 5; p++) {
        const petalAngle = p * (Math.PI * 2 / 5);
        const petalX = padX + Math.cos(petalAngle) * 4;
        const petalY = padY - 3 + bob + Math.sin(petalAngle) * 3;
        targetCtx.beginPath();
        targetCtx.ellipse(petalX, petalY, 2, 3, petalAngle, 0, Math.PI * 2);
        targetCtx.fill();
      }
      targetCtx.fillStyle = '#ffff80';
      targetCtx.beginPath();
      targetCtx.arc(padX, padY - 3 + bob, 2, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 34) {
    // INDIGO DYE PLANT - harvestable (foraging spot)
    // Wetland grass base
    const wetBase = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    wetBase.addColorStop(0, '#3a6050');
    wetBase.addColorStop(1, '#2a4a40');
    targetCtx.fillStyle = wetBase;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Plant stem
    const sway = Math.sin(animationTime * 1.2 + x + y) * 2;
    targetCtx.strokeStyle = '#4a7a50';
    targetCtx.lineWidth = 3;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + TILE_SIZE - 2);
    targetCtx.quadraticCurveTo(px + 16 + sway * 0.3, py + 18, px + 16 + sway * 0.5, py + 8);
    targetCtx.stroke();
    
    // Indigo flower clusters
    const flowerColors = ['#4040a0', '#5050b0', '#6060c0'];
    for (let f = 0; f < 3; f++) {
      const fX = px + 12 + f * 4 + sway * (0.3 + f * 0.2);
      const fY = py + 6 + f * 4;
      targetCtx.fillStyle = flowerColors[f];
      targetCtx.beginPath();
      targetCtx.arc(fX, fY, 3, 0, Math.PI * 2);
      targetCtx.fill();
    }
    
    // Sparkle effect (harvestable indicator)
    const sparkle = Math.sin(animationTime * 3) > 0.5;
    if (sparkle) {
      targetCtx.fillStyle = 'rgba(150, 150, 255, 0.6)';
      targetCtx.beginPath();
      targetCtx.arc(px + 14 + sway, py + 5, 2, 0, Math.PI * 2);
      targetCtx.fill();
    }

  } else if (t === 35) {
    // VIOLET DYE PLANT - harvestable (foraging spot)
    // Wetland grass base
    const wetBase = targetCtx.createLinearGradient(px, py, px, py + TILE_SIZE);
    wetBase.addColorStop(0, '#3a6050');
    wetBase.addColorStop(1, '#2a4a40');
    targetCtx.fillStyle = wetBase;
    targetCtx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
    
    // Plant stem
    const sway = Math.sin(animationTime * 1.1 + x * 0.5 + y * 0.7) * 2;
    targetCtx.strokeStyle = '#4a7a50';
    targetCtx.lineWidth = 2;
    targetCtx.beginPath();
    targetCtx.moveTo(px + 16, py + TILE_SIZE - 2);
    targetCtx.quadraticCurveTo(px + 16 + sway * 0.4, py + 16, px + 16 + sway * 0.6, py + 6);
    targetCtx.stroke();
    
    // Violet flowers
    const violetBob = Math.sin(animationTime * 2) * 1;
    for (let f = 0; f < 3; f++) {
      const fX = px + 10 + f * 6 + sway * (0.2 + f * 0.15);
      const fY = py + 4 + Math.abs(f - 1) * 3 + violetBob;
      
      // Petals
      targetCtx.fillStyle = '#9040a0';
      for (let p = 0; p < 5; p++) {
        const pAngle = p * (Math.PI * 2 / 5) - Math.PI / 2;
        targetCtx.beginPath();
        targetCtx.ellipse(fX + Math.cos(pAngle) * 2.5, fY + Math.sin(pAngle) * 2.5, 2, 3, pAngle, 0, Math.PI * 2);
        targetCtx.fill();
      }
      // Center
      targetCtx.fillStyle = '#ffff60';
      targetCtx.beginPath();
      targetCtx.arc(fX, fY, 1.5, 0, Math.PI * 2);
      targetCtx.fill();
    }
    
    // Sparkle
    const sparkle = Math.sin(animationTime * 2.5 + 1) > 0.5;
    if (sparkle) {
      targetCtx.fillStyle = 'rgba(200, 150, 255, 0.6)';
      targetCtx.beginPath();
      targetCtx.arc(px + 18 + sway, py + 6, 2, 0, Math.PI * 2);
      targetCtx.fill();
    }
  }
}


function getPlayerAnimationFrames(dirOverride = player.dir) {
  const useLeft = SPRITE_CONFIG.mirrorRightFromLeft && dirOverride === 'right';
  const dir = useLeft ? 'left' : dirOverride;
  return SPRITE_CONFIG.player.animations[dir] || SPRITE_CONFIG.player.animations.down;
}

function getPlayerFrameCanvas(frameIndex, mirrored = false, dir = player.dir) {
  const cacheKey = `${dir}-${frameIndex}-${mirrored ? 'm' : 'n'}`;
  if (playerFrameCache.has(cacheKey)) return playerFrameCache.get(cacheKey);

  const directionalAsset = artAssets.playerDirections?.[dir];
  const asset = (directionalAsset && directionalAsset.loaded && !directionalAsset.error)
    ? directionalAsset
    : artAssets.player;
  if (!asset.loaded || asset.error) return null;

  const cols = asset.columns ?? SPRITE_CONFIG.player.columns;
  const fw = asset.frameWidth ?? SPRITE_CONFIG.player.frameWidth;
  const fh = asset.frameHeight ?? SPRITE_CONFIG.player.frameHeight;
  const sx = (frameIndex % cols) * fw;
  const sy = Math.floor(frameIndex / cols) * fh;

  const off = document.createElement('canvas');
  off.width = TILE_SIZE;
  off.height = TILE_SIZE;
  const offCtx = off.getContext('2d');
  offCtx.imageSmoothingEnabled = false; // preserve sprite sharpness when drawing to cache

  offCtx.save();
  if (mirrored) {
    offCtx.scale(-1, 1);
    offCtx.translate(-TILE_SIZE, 0);
  }

  offCtx.drawImage(
    asset.image,
    sx,
    sy,
    fw,
    fh,
    0,
    0,
    TILE_SIZE,
    TILE_SIZE
  );
  offCtx.restore();

  // Color-key the top-left pixel (assumed background) to transparent to remove unwanted fill
  const img = offCtx.getImageData(0, 0, TILE_SIZE, TILE_SIZE);
  const data = img.data;
  const keyR = data[0];
  const keyG = data[1];
  const keyB = data[2];
  const tol = 6;
  for (let i = 0; i < data.length; i += 4) {
    const dr = Math.abs(data[i] - keyR);
    const dg = Math.abs(data[i + 1] - keyG);
    const db = Math.abs(data[i + 2] - keyB);
    if (dr <= tol && dg <= tol && db <= tol) {
      data[i + 3] = 0;
    }
  }
  offCtx.putImageData(img, 0, 0);

  playerFrameCache.set(cacheKey, off);
  return off;
}

function updatePlayerAnimationState(isMoving) {
  const frames = getPlayerAnimationFrames();
  if (!frames || frames.length === 0) return;

  if (isMoving) {
    player.spriteTick = (player.spriteTick + 1) % 10000;
    if (player.spriteTick % SPRITE_CONFIG.player.speedTicks === 0) {
      player.spriteFrame = (player.spriteFrame + 1) % frames.length;
    }
  } else {
    player.spriteTick = 0;
    player.spriteFrame = Math.min(frames.length - 1, SPRITE_CONFIG.player.idleFrameIndex);
  }
}

function drawPlayerFromSprites() {
  const directional = artAssets.playerDirections?.[player.dir];
  const hasDirectional = directional && directional.loaded && !directional.error;
  const primaryAsset = hasDirectional ? directional : artAssets.player;
  if (!primaryAsset.loaded || primaryAsset.error) return false;

  const mirrorRight = !hasDirectional && SPRITE_CONFIG.mirrorRightFromLeft && player.dir === 'right';
  const frames = getPlayerAnimationFrames(mirrorRight ? 'left' : player.dir);
  if (!frames || frames.length === 0) return false;

  const frameIndex = frames[Math.min(frames.length - 1, player.spriteFrame)] ?? frames[0];
  const frameCanvas = getPlayerFrameCanvas(frameIndex, mirrorRight, player.dir);
  if (!frameCanvas) return false;

  const drawX = Math.round(player.px);
  const drawY = Math.round(player.py);
  ctx.drawImage(frameCanvas, drawX, drawY);

  return true;
}

    function drawPlayer() {
  if (drawPlayerFromSprites()) {
    return;
  }
  const px = player.px;
  const py = player.py;

  // simple shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(px + 16, py + 24, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // body
  ctx.fillStyle = '#f4b3ff'; // cosy knitted jumper
  ctx.fillRect(px + 10, py + 10, 12, 18);

  // legs
  ctx.fillStyle = '#2b3145';
  ctx.fillRect(px + 11, py + 26, 4, 6);
  ctx.fillRect(px + 17, py + 26, 4, 6);

  // head
  ctx.beginPath();
  ctx.arc(px + 16, py + 8, 6, 0, Math.PI * 2);
  ctx.fillStyle = '#ffcf9e';
  ctx.fill();

  // hair (simple bob)
  ctx.beginPath();
  ctx.arc(px + 16, py + 6, 7, Math.PI, 0);
  ctx.fillStyle = '#e48bd9';
  ctx.fill();

  // scarf
  ctx.fillStyle = '#ffd9a6';
  ctx.fillRect(px + 10, py + 15, 12, 4);
  ctx.fillRect(px + 19, py + 15, 3, 7);

  // tiny face details â€“ eyes
  ctx.fillStyle = '#3a2a24';
  ctx.fillRect(px + 13, py + 7, 1, 2);
  ctx.fillRect(px + 18, py + 7, 1, 2);
}

function drawGoat() {
  if (currentMap !== goat.map) return;

  // Use pixel position for smooth movement
  const px = Math.round(goat.px);
  const py = Math.round(goat.py);

  const asset = artAssets.goat;
  if (asset && asset.loaded && !asset.error) {
    const cols = asset.columns || 3;
    const fw = asset.frameWidth || (asset.image.width / cols);
    const fh = asset.frameHeight || asset.image.height;
    // Animate faster when moving
    const animSpeed = goat.isMoving ? 8 : 12;
    const frame = cols ? Math.floor(goatAnimTick / animSpeed) % cols : 0;
    const sx = frame * fw;
    const sy = 0;
    // Scale full frame into the tile, with a small upward offset for padding
    ctx.drawImage(asset.image, sx, sy, fw, fh, px, py + GOAT_DRAW_OFFSET_Y, TILE_SIZE, TILE_SIZE);
  } else {
    // fallback simple goat shape
    ctx.fillStyle = '#d9d5cc';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 18, 12, 9, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#b6ae9e';
    ctx.beginPath();
    ctx.ellipse(px + 10, py + 14, 7, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(px + 5, py + 11, 3, 3);
    ctx.fillRect(px + 12, py + 11, 3, 3);
  }
}

function drawSheep() {
  // Draw main sheep
  drawSingleSheep(sheep);
  // Draw second sheep
  drawSingleSheep(sheep2);
}

function drawSingleSheep(s) {
  if (currentMap !== s.map) return;

  // Use pixel position for smooth movement
  const px = Math.round(s.px);
  const py = Math.round(s.py);

  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(px + 16, py + 24, 10, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // body
  if (s.hasWool) {
    // fluffy
    ctx.fillStyle = '#fdf9f2';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 18, 11, 9, 0, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // trimmed
    ctx.fillStyle = '#e6dccb';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 18, 9, 7, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // head - position based on facing direction
  let headOffsetX = -6;
  let headOffsetY = -4;
  if (s.facing === 'right') headOffsetX = 6;
  else if (s.facing === 'up') { headOffsetX = 0; headOffsetY = -8; }
  else if (s.facing === 'down') { headOffsetX = 0; headOffsetY = 0; }
  
  ctx.fillStyle = '#d3c0aa';
  ctx.beginPath();
  ctx.ellipse(px + 16 + headOffsetX, py + 14 + headOffsetY, 6, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // little ears
  ctx.fillRect(px + 11 + headOffsetX, py + 10 + headOffsetY, 3, 3);
  ctx.fillRect(px + 17 + headOffsetX, py + 10 + headOffsetY, 3, 3);

  // face details
  ctx.fillStyle = '#3a2a24';
  ctx.fillRect(px + 14 + headOffsetX, py + 14 + headOffsetY, 1, 2);
  ctx.fillRect(px + 17 + headOffsetX, py + 14 + headOffsetY, 1, 2);
}

function drawPeacock() {
  if (currentMap !== peacock.map) return;

  const px = Math.round(peacock.px);
  const py = Math.round(peacock.py);
  
  // Update display timer for tail animation
  peacock.displayTimer = (peacock.displayTimer + 1) % 360;
  const fanAmount = peacock.hasFeathers ? 0.8 + Math.sin(peacock.displayTimer * 0.02) * 0.2 : 0.3;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.beginPath();
  ctx.ellipse(px + 16, py + 26, 12, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Draw tail feathers (behind body) if has feathers
  if (peacock.hasFeathers) {
    const tailColors = ['#1a5f7a', '#2d8b6e', '#1e7b5e', '#156a8a', '#0d5070'];
    const eyeColor = '#d4af37';
    const numFeathers = 7;
    
    for (let i = 0; i < numFeathers; i++) {
      const angle = ((i - 3) / 3) * fanAmount * 0.8;
      const featherLen = 18 + Math.sin(i * 1.5) * 3;
      
      // Feather stem
      ctx.strokeStyle = tailColors[i % tailColors.length];
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px + 16, py + 18);
      const endX = px + 16 + Math.sin(angle) * featherLen;
      const endY = py + 18 - Math.cos(angle) * featherLen;
      ctx.lineTo(endX, endY);
      ctx.stroke();
      
      // Eye spot at end of feather
      ctx.fillStyle = '#0a3a4a';
      ctx.beginPath();
      ctx.arc(endX, endY, 4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = eyeColor;
      ctx.beginPath();
      ctx.arc(endX, endY, 2.5, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#1a5f7a';
      ctx.beginPath();
      ctx.arc(endX, endY, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  } else {
    // Bare tail - just small stumps
    ctx.fillStyle = '#2a6a7a';
    ctx.beginPath();
    ctx.ellipse(px + 16, py + 10, 4, 6, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Body
  ctx.fillStyle = '#1a5f7a';
  ctx.beginPath();
  ctx.ellipse(px + 16, py + 20, 8, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Neck position based on facing
  let neckOffsetX = 0;
  let neckOffsetY = -6;
  if (peacock.facing === 'left') neckOffsetX = -4;
  else if (peacock.facing === 'right') neckOffsetX = 4;
  else if (peacock.facing === 'up') neckOffsetY = -8;
  else if (peacock.facing === 'down') neckOffsetY = -4;

  // Neck
  ctx.fillStyle = '#1a5f7a';
  ctx.beginPath();
  ctx.ellipse(px + 16 + neckOffsetX, py + 16 + neckOffsetY, 4, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.fillStyle = '#1a5f7a';
  ctx.beginPath();
  ctx.arc(px + 16 + neckOffsetX, py + 10 + neckOffsetY, 5, 0, Math.PI * 2);
  ctx.fill();

  // Crown feathers
  ctx.fillStyle = '#d4af37';
  for (let i = -1; i <= 1; i++) {
    ctx.beginPath();
    ctx.moveTo(px + 16 + neckOffsetX + i * 2, py + 10 + neckOffsetY);
    ctx.lineTo(px + 16 + neckOffsetX + i * 3, py + 4 + neckOffsetY);
    ctx.lineTo(px + 17 + neckOffsetX + i * 2, py + 10 + neckOffsetY);
    ctx.fill();
  }

  // Beak
  ctx.fillStyle = '#8b7355';
  ctx.beginPath();
  const beakDir = peacock.facing === 'left' ? -1 : peacock.facing === 'right' ? 1 : 0;
  ctx.moveTo(px + 16 + neckOffsetX + beakDir * 5, py + 11 + neckOffsetY);
  ctx.lineTo(px + 16 + neckOffsetX + beakDir * 8, py + 12 + neckOffsetY);
  ctx.lineTo(px + 16 + neckOffsetX + beakDir * 5, py + 13 + neckOffsetY);
  ctx.fill();

  // Eye
  ctx.fillStyle = '#1a1a1a';
  ctx.beginPath();
  ctx.arc(px + 15 + neckOffsetX + (peacock.facing === 'right' ? 2 : 0), py + 9 + neckOffsetY, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Legs
  ctx.strokeStyle = '#8b7355';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(px + 13, py + 24);
  ctx.lineTo(px + 12, py + 30);
  ctx.moveTo(px + 19, py + 24);
  ctx.lineTo(px + 20, py + 30);
  ctx.stroke();
}

function drawFurniture() {
  if (currentMap === fireplaceSpot.map) {
    const px = fireplaceSpot.x * TILE_SIZE;
    const py = fireplaceSpot.y * TILE_SIZE;

    ctx.fillStyle = '#2d1a14';
    ctx.fillRect(px + 2, py + 8, TILE_SIZE - 4, TILE_SIZE - 6);

    ctx.fillStyle = '#553429';
    ctx.fillRect(px, py + 6, TILE_SIZE, 5);

    ctx.fillStyle = '#26130f';
    ctx.fillRect(px + 6, py + 16, TILE_SIZE - 12, TILE_SIZE - 20);

    const flicker = 6 + Math.sin(fireAnimTick * 0.25) * 3;
    const sway = Math.sin(fireAnimTick * 0.4) * 2;

    ctx.fillStyle = '#f8d87c';
    ctx.beginPath();
    ctx.ellipse(px + 16 + sway, py + 20, 7, flicker, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff964b';
    ctx.beginPath();
    ctx.ellipse(px + 16 + sway * 0.6, py + 21, 4, flicker - 2, 0, 0, Math.PI * 2);
    ctx.fill();

    const glow = ctx.createRadialGradient(px + 16, py + 24, 2, px + 16, py + 24, 28);
    glow.addColorStop(0, 'rgba(255, 173, 85, 0.45)');
    glow.addColorStop(1, 'rgba(255, 173, 85, 0)');
    ctx.fillStyle = glow;
    ctx.fillRect(px - 20, py - 4, TILE_SIZE + 40, TILE_SIZE + 28);
  }

  if (currentMap === 'cottage') {
    cottageFurniture.forEach((item) => {
      if (item.map !== currentMap) return;
      const px = item.x * TILE_SIZE;
      const py = item.y * TILE_SIZE;

      if (item.type === 'armchair') {
        ctx.fillStyle = '#5f3b5b';
        ctx.fillRect(px + 4, py + 8, TILE_SIZE - 8, TILE_SIZE - 6);
        ctx.fillStyle = '#784d74';
        ctx.fillRect(px + 8, py + 12, TILE_SIZE - 16, TILE_SIZE - 16);
        ctx.fillStyle = '#f8d7d9';
        ctx.fillRect(px + 12, py + 18, TILE_SIZE - 24, 6);
      } else if (item.type === 'bookshelf') {
        ctx.fillStyle = '#3b2a26';
        ctx.fillRect(px + 6, py + 2, TILE_SIZE - 12, TILE_SIZE - 2);
        ctx.fillStyle = '#6a4737';
        ctx.fillRect(px + 8, py + 6, TILE_SIZE - 16, 4);
        ctx.fillRect(px + 8, py + 14, TILE_SIZE - 16, 4);
        ctx.fillStyle = '#d4bf8f';
        ctx.fillRect(px + 10, py + 4, 6, 4);
        ctx.fillStyle = '#a89ed8';
        ctx.fillRect(px + 18, py + 12, 5, 6);
      } else if (item.type === 'chest') {
        ctx.fillStyle = '#7d4f2a';
        ctx.fillRect(px + 8, py + 12, TILE_SIZE - 16, TILE_SIZE - 8);
        ctx.fillStyle = '#b97f3a';
        ctx.fillRect(px + 8, py + 12, TILE_SIZE - 16, 8);
        ctx.fillStyle = '#2a1b10';
        ctx.fillRect(px + 14, py + 16, TILE_SIZE - 28, 4);
      }
    });
  }

  // Draw Crafting Table at knittingSpot
  if (currentMap === knittingSpot.map) {
    const px = knittingSpot.x * TILE_SIZE;
    const py = knittingSpot.y * TILE_SIZE;

    // Wooden table base
    ctx.fillStyle = '#5a4030';
    ctx.fillRect(px + 4, py + 12, TILE_SIZE - 8, TILE_SIZE - 14);
    
    // Table top
    ctx.fillStyle = '#7a5840';
    ctx.fillRect(px + 2, py + 8, TILE_SIZE - 4, 8);
    
    // Table surface details - yarn and needles
    ctx.fillStyle = '#d68caf';  // Pink yarn ball
    ctx.beginPath();
    ctx.arc(px + 10, py + 11, 4, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#88c4e8';  // Blue yarn ball
    ctx.beginPath();
    ctx.arc(px + 22, py + 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Knitting needles
    ctx.strokeStyle = '#c0c0c0';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(px + 14, py + 6);
    ctx.lineTo(px + 20, py + 14);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(px + 18, py + 6);
    ctx.lineTo(px + 12, py + 14);
    ctx.stroke();
  }

  // Draw Spinning Wheel/Loom at loomSpot (separate from crafting table)
  if (currentMap === loomSpot.map) {
    const lx = loomSpot.x * TILE_SIZE;
    const ly = loomSpot.y * TILE_SIZE;

    // Base magical glow (always visible - it's a Crystal Loom!)
    const baseGlow = 0.35 + 0.15 * Math.sin(Date.now() / 500);
    ctx.fillStyle = `rgba(180, 100, 255, ${baseGlow})`;
    ctx.beginPath();
    ctx.arc(lx + TILE_SIZE/2, ly + TILE_SIZE/2, 20, 0, Math.PI * 2);
    ctx.fill();
    
    // Outer glow ring
    ctx.strokeStyle = `rgba(200, 150, 255, ${0.3 + 0.2 * Math.sin(Date.now() / 400)})`;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(lx + TILE_SIZE/2, ly + TILE_SIZE/2, 22, 0, Math.PI * 2);
    ctx.stroke();

    // Wooden frame base
    ctx.fillStyle = '#4a3423';
    ctx.fillRect(lx + 2, ly + 6, TILE_SIZE - 4, TILE_SIZE - 8);

    // Wheel (large circle) - with crystal shimmer
    ctx.fillStyle = '#8a6747';
    ctx.beginPath();
    ctx.arc(lx + TILE_SIZE/2, ly + TILE_SIZE/2 + 2, 10, 0, Math.PI * 2);
    ctx.fill();
    
    // Crystal center (the magical part)
    const crystalGlow = 0.6 + 0.3 * Math.sin(Date.now() / 400);
    ctx.fillStyle = `rgba(200, 160, 255, ${crystalGlow})`;
    ctx.beginPath();
    ctx.arc(lx + TILE_SIZE/2, ly + TILE_SIZE/2 + 2, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Wheel spokes (animated)
    ctx.strokeStyle = '#7a5737';
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
      ctx.beginPath();
      const angle = (i * Math.PI / 2) + (Date.now() / 1000);
      ctx.moveTo(lx + TILE_SIZE/2, ly + TILE_SIZE/2 + 2);
      ctx.lineTo(lx + TILE_SIZE/2 + Math.cos(angle) * 8, ly + TILE_SIZE/2 + 2 + Math.sin(angle) * 8);
      ctx.stroke();
    }

    // Yarn on wheel
    ctx.fillStyle = '#f2d27a';
    ctx.beginPath();
    ctx.arc(lx + 8, ly + 10, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Enhanced magical glow when loom is attuned (has bonus crafts)
    if (loomAttuneBonusCrafts > 0) {
      ctx.fillStyle = `rgba(220, 180, 255, ${0.4 + 0.25 * Math.sin(Date.now() / 200)})`;
      ctx.beginPath();
      ctx.arc(lx + TILE_SIZE/2, ly + TILE_SIZE/2, 16, 0, Math.PI * 2);
      ctx.fill();
      
      // Sparkle particles
      for (let i = 0; i < 3; i++) {
        const sparkleAngle = (Date.now() / 300) + (i * Math.PI * 2 / 3);
        const sparkleX = lx + TILE_SIZE/2 + Math.cos(sparkleAngle) * 12;
        const sparkleY = ly + TILE_SIZE/2 + Math.sin(sparkleAngle) * 12;
        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + 0.3 * Math.sin(Date.now() / 150 + i)})`;
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  if (currentMap === marketSpot.map) {
    const mx = marketSpot.x * TILE_SIZE;
    const my = marketSpot.y * TILE_SIZE;

    ctx.fillStyle = '#3a2830';
    ctx.fillRect(mx + 2, my + 16, TILE_SIZE - 4, TILE_SIZE - 6);

    ctx.fillStyle = '#8c4c5a';
    ctx.fillRect(mx + 2, my + 4, TILE_SIZE - 4, 10);

    ctx.fillStyle = '#f5d4e0';
    ctx.fillRect(mx + 4, my + 6, TILE_SIZE - 8, 4);

    ctx.fillStyle = '#e28faf';
    ctx.fillRect(mx + 4, my + 10, TILE_SIZE - 8, 3);

    ctx.fillStyle = '#f2f2ff';
    ctx.fillRect(mx + TILE_SIZE - 10, my + 20, 4, 10);
  }
}



function getMapOffsets() {
  const mapWidth = MAP_COLS * TILE_SIZE;
  const mapHeight = MAP_ROWS * TILE_SIZE;
  const offsetX = Math.max(0, (canvas.width - mapWidth) / 2);
  const offsetY = Math.max(0, (canvas.height - mapHeight) / 2);
  return { offsetX, offsetY };
}

function drawDebugGridOverlay() {
  if (!debugState.grid) return;
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 1;
  for (let x = 0; x <= MAP_COLS; x++) {
    const px = x * TILE_SIZE;
    ctx.beginPath();
    ctx.moveTo(px, 0);
    ctx.lineTo(px, MAP_ROWS * TILE_SIZE);
    ctx.stroke();
  }
  for (let y = 0; y <= MAP_ROWS; y++) {
    const py = y * TILE_SIZE;
    ctx.beginPath();
    ctx.moveTo(0, py);
    ctx.lineTo(MAP_COLS * TILE_SIZE, py);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDebugCollisionOverlay() {
  if (!debugState.collisions) return;
  ctx.save();
  ctx.fillStyle = 'rgba(255,64,64,0.2)';
  for (let y = 0; y < MAP_ROWS; y++) {
    for (let x = 0; x < MAP_COLS; x++) {
      if (isSolidTile(x, y)) {
        ctx.fillRect(x * TILE_SIZE + 1, y * TILE_SIZE + 1, TILE_SIZE - 2, TILE_SIZE - 2);
      }
    }
  }
  ctx.restore();
}

function drawDebugWorldOverlays(offsetX, offsetY) {
  if (!debugState.grid && !debugState.collisions) return;
  ctx.save();
  ctx.translate(offsetX, offsetY);
  drawDebugCollisionOverlay();
  drawDebugGridOverlay();
  ctx.restore();
}

function drawDebugInfoPanel() {
  const showStatus = debugState.statusMessage && performance.now() < debugState.statusUntil;
  if (!debugState.info && !showStatus) return;

  const lines = [];
  if (debugState.info) {
    lines.push(`Map: ${currentMap}`);
    lines.push(`Player tile: ${player.x}, ${player.y}`);
    lines.push(`Player px: ${Math.round(player.px)}, ${Math.round(player.py)}`);
    lines.push(`Overlay: ${showOverlayMode ? 'mobile' : 'desktop'}`);
  }
  if (showStatus) {
    lines.push(debugState.statusMessage);
  }
  if (!lines.length) return;

  const panelWidth = 210;
  const panelHeight = 20 + lines.length * 14;
  ctx.save();
  ctx.fillStyle = 'rgba(6,12,26,0.78)';
  ctx.fillRect(12, 12, panelWidth, panelHeight);
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.strokeRect(12.5, 12.5, panelWidth - 1, panelHeight - 1);
  ctx.fillStyle = '#c5e0ff';
  ctx.font = '11px "Cascadia Code", "Fira Code", monospace';
  ctx.textBaseline = 'top';
  lines.forEach((line, idx) => {
    ctx.fillText(line, 20, 18 + idx * 14);
  });
  ctx.restore();
}



function render() {
  // Background sky
  const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
  sky.addColorStop(0, '#182c4e');
  sky.addColorStop(0.6, '#07131f');
  sky.addColorStop(1, '#020509');
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const { offsetX, offsetY } = getMapOffsets();
  const interactables = currentInteractables || [];

  ctx.save();
  ctx.translate(offsetX, offsetY);

  // Draw all tiles fresh each frame for animation support
  for (let y = 0; y < MAP_ROWS; y++) {
    for (let x = 0; x < MAP_COLS; x++) {
      drawTile(mapData[y][x], x, y);
    }
  }

  drawFurniture();

  drawInteractableGlows(interactables);
  
  // Draw forageable items
  drawForageables();

  drawGoat();
  drawSheep();
  drawPeacock();
  drawPurchasedAnimals();
  drawFestivalDecorations();
  drawVillagers();
  drawTravelingMerchant();

  drawPlayer();

  drawInteractableLabels(interactables);

  ctx.restore();

  drawDebugWorldOverlays(offsetX, offsetY);

        // HUD â€“ minimal (Wool + Gold only)
  ctx.save();

  const hudX = 8;
  const hudY = 8;
  const hudW = 150;
  const hudH = 40;

  // subtle background
  ctx.fillStyle = 'rgba(5, 8, 16, 0.55)';
  ctx.fillRect(hudX, hudY, hudW, hudH);

  // border
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.18)';
  ctx.lineWidth = 1;
  ctx.strokeRect(hudX + 0.5, hudY + 0.5, hudW - 1, hudH - 1);

  // Zone name label
  ctx.fillStyle = '#a9b3cd';
  ctx.font = '10px system-ui';
  ctx.fillText(getZoneDisplayName(currentMap), hudX + 8, hudY + 14);

  // Wool icon + count
  ctx.fillStyle = '#f8f0d8';
  ctx.beginPath();
  ctx.arc(hudX + 14, hudY + 26, 4, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#f5f7ff';
  ctx.font = '12px system-ui';
  ctx.fillText(`Wool: ${inventory.wool}`, hudX + 24, hudY + 29);

  // Gold icon + count
  ctx.fillStyle = '#f4c945';
  ctx.beginPath();
  ctx.arc(hudX + 95, hudY + 26, 4, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#f5f7ff';
  ctx.fillText(`G: ${inventory.gold}`, hudX + 105, hudY + 29);

  ctx.restore();

  // Beach fishing hint
  if (!fishingActive && canStartFishing()) {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 60, 120, 0.8)';
    ctx.beginPath();
    ctx.roundRect(canvas.width / 2 - 70, canvas.height - 75, 140, 24, 6);
    ctx.fill();
    ctx.fillStyle = '#88ddff';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸŽ£ Press F to Fish', canvas.width / 2, canvas.height - 58);
    ctx.textAlign = 'left';
    ctx.restore();
  }
  
  // Loom attune hint
  if (!loomAttuneActive && isNearLoom()) {
    ctx.save();
    ctx.fillStyle = 'rgba(80, 40, 100, 0.8)';
    ctx.beginPath();
    ctx.roundRect(canvas.width / 2 - 85, canvas.height - 75, 170, 24, 6);
    ctx.fill();
    ctx.fillStyle = '#e8c0f8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸ§¶ Press E to Attune Loom', canvas.width / 2, canvas.height - 58);
    ctx.textAlign = 'left';
    ctx.restore();
  }
  
  // Crafting table hint
  if (!craftingMenuOpen && isNearCraftingTable()) {
    ctx.save();
    ctx.fillStyle = 'rgba(90, 60, 40, 0.8)';
    ctx.beginPath();
    ctx.roundRect(canvas.width / 2 - 70, canvas.height - 75, 140, 24, 6);
    ctx.fill();
    ctx.fillStyle = '#f0d8c0';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('ðŸª¡ Press E to Craft', canvas.width / 2, canvas.height - 58);
    ctx.textAlign = 'left';
    ctx.restore();
  }
  
  // Debug: Show player position on beach (temporary)
  if (currentMap === 'beach') {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(canvas.width - 120, 8, 110, 20);
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px monospace';
    ctx.fillText(`Pos: ${player.x}, ${player.y}`, canvas.width - 115, 22);
    ctx.restore();
  }



  // Message box - centered, compact, subtle
  if (message) {
    ctx.font = '13px system-ui';
    const textWidth = ctx.measureText(message).width;
    const boxW = Math.min(canvas.width - 40, textWidth + 40);
    const boxH = 36;
    const boxX = (canvas.width - boxW) / 2;
    const boxY = canvas.height - boxH - 16;

    // Rounded rectangle background
    ctx.fillStyle = 'rgba(7,11,22,0.75)';
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxW, boxH, 12);
    ctx.fill();

    // Subtle border
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxW, boxH, 12);
    ctx.stroke();

    // Message text - centered
    ctx.fillStyle = '#f5f7ff';
    ctx.textAlign = 'center';
    ctx.fillText(message, canvas.width / 2, boxY + 23);
    ctx.textAlign = 'left'; // Reset alignment
  }

    // -----------------------------
  // INVENTORY PANEL
  // -----------------------------
  if (inventoryOpen) {
    const panelW = 380;
    const panelH = Math.min(520, canvas.height - 20); // Taller panel, responsive to screen
    const panelX = (canvas.width - panelW) / 2;
    const panelY = (canvas.height - panelH) / 2;

    // background
    ctx.fillStyle = 'rgba(6, 12, 26, 0.94)';
    ctx.fillRect(panelX, panelY, panelW, panelH);

    // border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.22)';
    ctx.lineWidth = 2;
    ctx.strokeRect(panelX + 0.5, panelY + 0.5, panelW - 1, panelH - 1);

    // header bar
    ctx.fillStyle = 'rgba(18, 32, 64, 0.95)';
    ctx.fillRect(panelX, panelY, panelW, 40);

    // title
    ctx.fillStyle = '#f5f7ff';
    ctx.font = '18px system-ui';
    ctx.fillText('Inventory', panelX + 20, panelY + 26);

    // small hint text
    ctx.fillStyle = '#a9b3cd';
    ctx.font = '11px system-ui';
    ctx.fillText('Press I or Esc to close', panelX + panelW - 150, panelY + 26);

    const rowHeight = 22;
    let currentY = panelY + 52;

    // --- MATERIALS SECTION (Two columns) ---
    ctx.fillStyle = '#7a8ba8';
    ctx.font = '10px system-ui';
    ctx.fillText('MATERIALS', panelX + 16, currentY);
    ctx.fillText('FORAGED', panelX + panelW/2 + 8, currentY);
    currentY += 18;

    const materials = [
      { name: 'Wool', key: 'wool', color: '#f8f0d8' },
      { name: 'Goat Fur', key: 'goatFur', color: '#d6d0c6' },
      { name: 'Yarn', key: 'yarn', color: '#f098c8' },
      { name: 'Luxury Yarn', key: 'luxuryYarn', color: '#c8a0f0' },
      { name: 'Feathers', key: 'feather', color: '#1a7f9a' }
    ];
    
    const forageables = [
      { name: 'Mushroom', key: 'mushroom', color: '#c49a6c' },
      { name: 'Berries', key: 'berries', color: '#8b3a62' },
      { name: 'Wild Flower', key: 'wildFlower', color: '#d4a5e8' },
      { name: 'Resin', key: 'resin', color: '#d4a020' },
      { name: 'Shell', key: 'shell', color: '#f5e6d3' }
    ];

    const maxRows = Math.max(materials.length, forageables.length);
    for (let i = 0; i < maxRows; i++) {
      // Left column - materials
      if (i < materials.length) {
        const mat = materials[i];
        ctx.fillStyle = mat.color;
        ctx.beginPath();
        ctx.arc(panelX + 28, currentY - 3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#a9b3cd';
        ctx.font = '11px system-ui';
        ctx.fillText(mat.name, panelX + 40, currentY);
        ctx.fillStyle = '#f5f7ff';
        ctx.fillText(`${inventory[mat.key]}`, panelX + panelW/2 - 30, currentY);
      }
      // Right column - forageables
      if (i < forageables.length) {
        const mat = forageables[i];
        ctx.fillStyle = mat.color;
        ctx.beginPath();
        ctx.arc(panelX + panelW/2 + 20, currentY - 3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#a9b3cd';
        ctx.font = '11px system-ui';
        ctx.fillText(mat.name, panelX + panelW/2 + 32, currentY);
        ctx.fillStyle = '#f5f7ff';
        ctx.fillText(`${inventory[mat.key]}`, panelX + panelW - 30, currentY);
      }
      currentY += rowHeight;
    }

    // --- CRAFTED ITEMS SECTION ---
    currentY += 8;
    ctx.fillStyle = '#7a8ba8';
    ctx.font = '10px system-ui';
    ctx.fillText('CRAFTED ITEMS', panelX + 16, currentY);
    currentY += 18;

    const craftedItems = [
      { name: 'Socks', key: 'socks', color: '#a8d8a8', price: 8 },
      { name: 'Scarf', key: 'scarf', color: '#f2d27a', price: 10 },
      { name: 'Hat', key: 'hat', color: '#7eb8e8', price: 12 },
      { name: 'Berry Jam', key: 'berryJam', color: '#8b3a62', price: 12 },
      { name: 'Mittens', key: 'mittens', color: '#e8d0c0', price: 15 },
      { name: 'Mush. Basket', key: 'mushroomBasket', color: '#c49a6c', price: 15 },
      { name: 'Lux. Socks', key: 'luxurySocks', color: '#e8c0f0', price: 18 },
      { name: 'Teal Socks', key: 'tealSocks', color: '#30b0b0', price: 18 },
      { name: 'Lux. Mittens', key: 'luxuryMittens', color: '#e0b8f0', price: 20 },
      { name: 'Teal Scarf', key: 'tealScarf', color: '#20a0a0', price: 22 },
      { name: 'Amber Hat', key: 'amberHat', color: '#d4a020', price: 24 },
      { name: 'Lux. Scarf', key: 'luxuryScarf', color: '#d8a0f8', price: 25 },
      { name: 'Shell Necklace', key: 'shellNecklace', color: '#f0e8d0', price: 25 },
      { name: 'Amber Mittens', key: 'amberMittens', color: '#e0b040', price: 28 },
      { name: 'Blanket', key: 'blanket', color: '#f0c8a0', price: 30 },
      { name: 'Shell Chimes', key: 'shellChimes', color: '#c8e0f0', price: 35 },
      { name: 'Fancy Hat', key: 'fancyHat', color: '#1a7f9a', price: 35 },
      { name: 'Feather Fan', key: 'featherFan', color: '#2d8b6e', price: 40 }
    ];
    
    // Also show dyes if any
    const dyes = [
      { name: 'Amber Dye', key: 'amberDye', color: '#d4a020' },
      { name: 'Teal Dye', key: 'tealDye', color: '#20a0a0' },
      { name: 'Brown Dye', key: 'brownDye', color: '#8b6914' },
      { name: 'Pearl Thread', key: 'pearlThread', color: '#f0e8dc' }
    ];
    const ownedDyes = dyes.filter(d => inventory[d.key] > 0);

    // Draw crafted items in two columns
    const colWidth = (panelW - 32) / 2;
    for (let i = 0; i < craftedItems.length; i++) {
      const item = craftedItems[i];
      const col = i % 2;
      const row = Math.floor(i / 2);
      const itemX = panelX + 16 + col * colWidth;
      const itemY = currentY + row * rowHeight;
      
      ctx.fillStyle = item.color;
      ctx.beginPath();
      ctx.arc(itemX + 8, itemY - 3, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#a9b3cd';
      ctx.font = '10px system-ui';
      ctx.fillText(item.name, itemX + 16, itemY);
      ctx.fillStyle = '#f5f7ff';
      ctx.font = '10px system-ui';
      ctx.fillText(`${inventory[item.key]}`, itemX + colWidth - 20, itemY);
    }
    currentY += Math.ceil(craftedItems.length / 2) * rowHeight;
    
    // Show dyes if owned
    if (ownedDyes.length > 0) {
      currentY += 4;
      ctx.fillStyle = '#7a8ba8';
      ctx.font = '10px system-ui';
      ctx.fillText('DYES', panelX + 16, currentY);
      currentY += 14;
      ownedDyes.forEach(dye => {
        ctx.fillStyle = dye.color;
        ctx.beginPath();
        ctx.arc(panelX + 28, currentY - 3, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#a9b3cd';
        ctx.font = '12px system-ui';
        ctx.fillText(dye.name, panelX + 44, currentY);
        ctx.fillStyle = '#f5f7ff';
        ctx.fillText(`${inventory[dye.key]}`, panelX + panelW - 40, currentY);
        currentY += rowHeight;
      });
    }

    // --- CURRENCY SECTION ---
    currentY += 8;
    ctx.fillStyle = '#7a8ba8';
    ctx.font = '10px system-ui';
    ctx.fillText('CURRENCY', panelX + 16, currentY);
    currentY += 18;

    ctx.fillStyle = '#f4c945';
    ctx.beginPath();
    ctx.arc(panelX + 28, currentY - 3, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#a9b3cd';
    ctx.font = '12px system-ui';
    ctx.fillText('Gold', panelX + 44, currentY);
    ctx.fillStyle = '#f4c945';
    ctx.font = '14px system-ui';
    ctx.fillText(`${inventory.gold}`, panelX + panelW - 40, currentY);
  }

  // -----------------------------
  // CRAFTING MENU PANEL
  // -----------------------------
  if (craftingMenuOpen) {
    // Responsive sizing - narrower on touch devices to avoid touch controls
    const isMobile = isCoarsePointer || showOverlayMode;
    const menuW = isMobile ? 220 : 400;
    const menuH = isMobile ? Math.min(canvas.height - 10, 360) : 380;
    const menuX = (canvas.width - menuW) / 2;
    const menuY = isMobile ? 5 : (canvas.height - menuH) / 2;

    // Dim background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Panel background
    ctx.fillStyle = 'rgba(6, 12, 26, 0.95)';
    ctx.fillRect(menuX, menuY, menuW, menuH);

    // Border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
    ctx.lineWidth = 2;
    ctx.strokeRect(menuX + 0.5, menuY + 0.5, menuW - 1, menuH - 1);

    // Header bar
    ctx.fillStyle = 'rgba(80, 50, 40, 0.9)';
    ctx.fillRect(menuX, menuY, menuW, 40);

    // Title
    ctx.fillStyle = '#f5f7ff';
    ctx.font = isMobile ? '14px system-ui' : '18px system-ui';
    ctx.fillText('ðŸ§¶ Crafting', menuX + 12, menuY + 26);

    // Controls hint (desktop only)
    if (!isMobile) {
      ctx.fillStyle = '#a9b3cd';
      ctx.font = '10px system-ui';
      ctx.fillText('â†‘â†“ Select | E Craft | Esc Close | I Inventory', menuX + menuW - 230, menuY + 26);
    } else {
      // Mobile hint
      ctx.fillStyle = '#a9b3cd';
      ctx.font = '8px system-ui';
      ctx.fillText('â–²â–¼ Sel | Act: Craft', menuX + menuW - 95, menuY + 26);
    }

    // Calculate visible area for scrolling
    const recipeHeight = isMobile ? 32 : 38;
    const visibleAreaTop = menuY + (isMobile ? 38 : 48);
    const visibleAreaBottom = menuY + menuH - (isMobile ? 32 : 44);
    const visibleCount = Math.floor((visibleAreaBottom - visibleAreaTop) / recipeHeight);
    
    // Calculate scroll offset to keep selection visible
    let scrollOffset = 0;
    if (craftingMenuSelection >= visibleCount) {
      scrollOffset = craftingMenuSelection - visibleCount + 1;
    }

    // Clip drawing to visible area
    ctx.save();
    ctx.beginPath();
    ctx.rect(menuX, visibleAreaTop, menuW, visibleAreaBottom - visibleAreaTop);
    ctx.clip();

    // Draw recipes (only show available/unlocked recipes)
    const availableRecipes = getAvailableRecipes();
    availableRecipes.forEach((recipe, index) => {
      const visualIndex = index - scrollOffset;
      const rowY = visibleAreaTop + visualIndex * recipeHeight;
      
      // Skip if outside visible area
      if (rowY < visibleAreaTop - recipeHeight || rowY > visibleAreaBottom) return;
      
      const isSelected = index === craftingMenuSelection;
      const canAfford = canAffordRecipe(recipe);

      // Selection highlight
      if (isSelected) {
        ctx.fillStyle = canAfford ? 'rgba(100, 180, 255, 0.25)' : 'rgba(255, 100, 100, 0.2)';
        ctx.fillRect(menuX + 4, rowY, menuW - 8, recipeHeight - 2);
        
        // Selection indicator
        ctx.fillStyle = canAfford ? '#64b4ff' : '#ff6464';
        ctx.fillRect(menuX + 4, rowY, 3, recipeHeight - 2);
      }

      // Recipe color dot
      ctx.fillStyle = canAfford ? recipe.color : '#555';
      ctx.beginPath();
      ctx.arc(menuX + (isMobile ? 16 : 22), rowY + recipeHeight / 2 - 1, isMobile ? 4 : 5, 0, Math.PI * 2);
      ctx.fill();

      // Recipe name + price on same line for mobile
      ctx.fillStyle = canAfford ? '#f5f7ff' : '#666';
      ctx.font = isMobile ? 'bold 10px system-ui' : 'bold 12px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(recipe.name, menuX + (isMobile ? 26 : 36), rowY + (isMobile ? 12 : 13));

      // Price on right (mobile: same line as name)
      if (recipe.sellPrice) {
        ctx.textAlign = 'right';
        ctx.fillStyle = canAfford ? '#f4c945' : '#554422';
        ctx.font = isMobile ? '9px system-ui' : '10px system-ui';
        ctx.fillText(`${recipe.sellPrice}g`, menuX + menuW - 8, rowY + (isMobile ? 12 : 26));
        ctx.textAlign = 'left';
      }

      // Inputs text (second line)
      const inputsStr = Object.entries(recipe.inputs)
        .map(([item, amount]) => `${amount}${item.replace('goatFur', 'fur').replace('luxuryYarn', 'lux').replace('wool', 'wl').replace('yarn', 'yn')}`)
        .join('+');
      
      ctx.fillStyle = canAfford ? '#7a8ba8' : '#555';
      ctx.font = isMobile ? '8px system-ui' : '10px system-ui';
      ctx.fillText(inputsStr, menuX + (isMobile ? 26 : 36), rowY + (isMobile ? 24 : 26));

      // Output (mobile: second line right side)
      if (!isMobile) {
        ctx.textAlign = 'right';
        const outputKey = Object.keys(recipe.outputs)[0];
        const outputAmt = recipe.outputs[outputKey];
        ctx.fillStyle = canAfford ? '#7cd87c' : '#555';
        ctx.fillText(`â†’ ${outputAmt} ${outputKey.replace('luxuryYarn', 'lux').replace('luxuryScarf', 'luxScarf').replace('luxuryMittens', 'luxMitt')}`, menuX + menuW - 14, rowY + 13);
        ctx.textAlign = 'left';
      }
    });

    ctx.restore();

    // Scroll indicators
    if (scrollOffset > 0) {
      ctx.fillStyle = '#7a8ba8';
      ctx.font = isMobile ? '8px system-ui' : '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('â–²', menuX + menuW / 2, visibleAreaTop + 8);
    }
    if (scrollOffset + visibleCount < availableRecipes.length) {
      ctx.fillStyle = '#7a8ba8';
      ctx.font = isMobile ? '8px system-ui' : '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('â–¼', menuX + menuW / 2, visibleAreaBottom - 2);
    }
    ctx.textAlign = 'left';

    // Footer with materials
    const footerH = isMobile ? 28 : 36;
    ctx.fillStyle = 'rgba(18, 32, 64, 0.95)';
    ctx.fillRect(menuX, menuY + menuH - footerH, menuW, footerH);

    ctx.fillStyle = '#a9b3cd';
    ctx.font = isMobile ? '8px system-ui' : '10px system-ui';
    if (isMobile) {
      const matText = `W:${inventory.wool} F:${inventory.goatFur} Y:${inventory.yarn} L:${inventory.luxuryYarn}`;
      ctx.fillText(matText, menuX + 6, menuY + menuH - 10);
    } else {
      ctx.fillStyle = '#7a8ba8';
      ctx.font = '9px system-ui';
      ctx.fillText('MATERIALS:', menuX + 10, menuY + menuH - 22);
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#a9b3cd';
      const matText = `Wool:${inventory.wool} Fur:${inventory.goatFur} Yarn:${inventory.yarn} Lux:${inventory.luxuryYarn}`;
      ctx.fillText(matText, menuX + 10, menuY + menuH - 8);
    }
  }

  // NPC Dialogue and Gift UI
  drawDialogueUI();
  drawGiftMenuUI();
  
  // Traveling Merchant Shop UI
  drawMerchantShopUI();
  
  // Village Vendor Shops UI
  drawDyeShopUI();
  drawTailorShopUI();
  
  // Farm Shop UI
  drawFarmShopUI();
  
  // Build Mode UI (cursor and HUD)
  drawBuildModeUI();
  
  // Fast Travel UI
  drawFastTravelUI();
  
  // Orders Board UI
  drawOrdersBoardUI();
  
  // Festival Menu UI
  drawFestivalMenuUI();
  
  // Fishing Mini-Game UI
  drawFishingUI();
  
  // Loom Attune Mini-Game UI
  drawLoomAttuneUI();
  
  // Knitting Sprint Mini-Game UI
  drawKnittingSprintUI();
  
  // Task Board UI (drawn last so it's on top, but before debug)
  drawTaskBoardUI();
  
  // Intro screen (drawn on top of everything)
  if (!introDone) {
    drawIntroScreen();
  }

  drawDebugInfoPanel();

}

// #endregion RENDER

// =========================
// MAIN LOOP
// =========================
// #region MAIN LOOP
function loop() {
  // Update animation time for tile effects
  animationTime += 0.05;
  
  update();
  render();
  requestAnimationFrame(loop);
}

loop();

// #endregion MAIN LOOP

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('Yarnvale: Service Worker registered', reg.scope))
      .catch(err => console.log('Yarnvale: Service Worker registration failed', err));
  });
}

  </script>
</body>
</html>
